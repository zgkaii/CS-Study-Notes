- [树](#树)
- [二叉树](#二叉树)
  - [二叉树的遍历](#二叉树的遍历)
- [二叉查找树](#二叉查找树)
  - [查找操作](#查找操作)
  - [插入操作](#插入操作)
  - [删除操作](#删除操作)
- [平衡二叉树](#平衡二叉树)
- [红黑树](#红黑树)
  - [实现红黑树基本思想](#实现红黑树基本思想)
  - [插入操作](#插入操作-1)
  - [删除操作](#删除操作-1)
- [参考](#参考)


# 树

在计算机科学中，**树**（Tree）是用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)。

关于“树”，还有三个比较相似的概念：**高度**（Height）、**深度**（Depth）、**层**（Level）。

* 节点的高度：节点到叶子节点的最长路径（边数）
* 节点的深度：根节点到这个节点所经历的边的个数
* 节点的层数：节点的深度+ 1
* 树的高度：根节点的高度

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210512195839924.png" width="450px"/>
</div>

# 二叉树

每个节点最多含有两个子树的树称为二叉树（Binary Tree）。

- 完全二叉树：对于一棵二叉树，假设其深度为d（d>1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点**从左向右**连续地紧密排列，这样的二叉树被称为完全二叉树；
  - 满二叉树：所有叶节点都在最底层的完全二叉树；

如何理解完全二叉树呢？这里需要先了解，**如何表示（或者存储）一棵二叉树**？

想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

**链式存储法**中，树的每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。

基于数组的**顺序存储法**，把根节点存储在下标` i = 1`的位置，那左子节点存储在下标`2 * i = 2 `的位置，右子节点存储在` 2 * i + 1 = 3 `的位置。以此类推，B 节点的左子节点存储在`2 * i = 2 * 2 = 4` 的位置，右子节点存储在`2 * i + 1 = 2 * 2 + 1 = 5`的位置。我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），就可以通过下标计算，把整棵树都串起来。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210512200815100.png" width="500px"/>
</div>

## 二叉树的遍历

二叉树的经典遍历方法有三种：前序遍历、中序遍历与后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

* 前序遍历：对于树任意节点，先打印这个节点，再打印它的左子树，最后打印它的右子树。
* 中序遍历：对于树任意节点，先打印它的左子树，再打印这个节点，最后打印它的右子树。
* 后序遍历：对于树任意节点，先打印它的左子树，再打印它的右子树，最后打印这个节点。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210512201336375.png" width="600px"/>
</div>

**实际上，二叉树的前、中、后序遍历就是一个递归的过程**。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。而写递归代码的关键，就是写递推公式。

```c++
前序遍历的递推公式
preOrder(r) = print r -> preOrder(r->left) -> preOrder(r->right)

中序遍历的递推公式
inOrder(r) = inOrder(r->left) -> print r ->  inOrder(r->right)

后序遍历的递推公式
postOrder(r) = postOrder(r->left) -> postOrder(r->right) -> print r   
```

这三种遍历方式的代码：

```c++
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}
 
void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}
 
void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```

> 二叉树的遍历时间为O(n)。

# 二叉查找树

二叉查找树（Binary Search Tree)也称二叉搜索树、有序二叉树、二叉排序树。二叉查找树要求，**在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。** 

二叉查找树以支持**快速地查找最大节点和最小节点、前驱节点和后继节点**；此**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效**。因此，二叉查找树也叫作二叉排序树。

在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟**树的高度**成正比。当二叉查找树在根节点的左右子树极度不平衡，完全退化成了链表，时间复杂度就变成了 O(n)；另外极端情况是二叉查找树变成完全二叉树，时间复杂度就变为O(logn)。

## 查找操作

在二叉查找树中查找一个节点时，我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

代码实现如下：

```java
public class BinarySearchTree {
  private Node tree;
 
  public Node find(int data) {
    Node p = tree;
    while (p != null) {
      if (data < p.data) p = p.left;
      else if (data > p.data) p = p.right;
      else return p;
    }
    return null;
  }
 
  public static class Node {
    private int data;
    private Node left;
    private Node right;
 
    public Node(int data) {
      this.data = data;
    }
  }
}
```

## 插入操作

二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

代码实现：

```java
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }
 
  Node p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
```

## 删除操作

针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。

* 第一种情况：要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。
* 第二种情况：如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。
* 第三种情况：如果要删除的节点有两个子节点。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210512203104944.png" width="600px"/>
</div>

代码实现：

```java
public void delete(int data) {
  Node p = tree; // p 指向要删除的节点，初始化指向根节点
  Node pp = null; // pp 记录的是 p 的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到
 
  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP 表示 minP 的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将 minP 的数据替换到 p 中
    p = minP; // 下面就变成了删除 minP 了
    pp = minPP;
  }
 
  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p 的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;
 
  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```

------

**问题**：既然有了高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有什么地方必须要用二叉树来做的呢？

**解答**：

* 散列表存储无序，输出有序数据需要额外排序；对于二叉查找树，中序遍历直接输出即可。
* 散列表扩容耗时多，遇到哈希冲突性能不稳定；尽管二叉查找树也不稳定，但是平衡二叉查找树性能非常稳定，时间复杂度稳定在 O(logn)。
* 散列表的构造比二叉查找树要复杂，需要考虑散列函数的设计、冲突解决办法、扩容、缩容等；平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

# 平衡二叉树

平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是[AVL 树](https://zh.wikipedia.org/wiki/AVL树)，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。

**平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。**

# 红黑树

红黑树（“Red-Black Tree”，简称 R-B Tree）是一种不严格的平衡二叉查找树。红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

* 每个节点或者说黑色，或者是红色；

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（叶子结点即指树尾端NIL指针或NULL结点），也就是说，叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210515174131296.png" width="500px"/>
</div>

> 图中叶子节点都省略未画出

虽然平衡二叉查找树的操作效率很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。

红黑树只是做到了近似平衡，并不是严格的平衡，它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的**。红黑树的高度近似 log~2~n，插入、删除、查找操作的时间复杂度都是 O(logn)**。红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

## 实现红黑树基本思想

魔方复原时是可以依照公式，，红黑树的平衡过程跟魔方复原非常神似，大致过程就是：**遇到什么样的节点排布，我们就对应怎么去调整**。

先介绍两个非常重要的操作，**左旋（rotate left）**、**右旋（rotate right）**。左旋全称其实是叫**围绕某个节点的左旋**，那右旋就叫**围绕某个节点的右旋**。图中的 a，b，r 表示子树，可以为空。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021051517510428.png" width="500px"/>
</div>

## 插入操作

**红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上**。

关于插入操作的平衡调整，有这样两种特殊情况：

* 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
* 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。

其他情况就需要我们进行调整，调整的手段有：**左右旋转**和**改变颜色**。

红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作**关注节点**。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。

新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。

| 情况   | 现象说明                                                                    | 处理策略                                                                                                                                                                  |
| ------ | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| CASE 1 | 关注节点的父节点是红色，叔叔节点也是红色。                                  | (01) 将“父节点”设为黑色。<br/>(02) 将“叔叔节点”设为黑色。<br/>(03) 将“祖父节点”设为“红色”。<br/>(04) 将“祖父节点”设为“关注节点”(红色节点)；<br/>跳到 CASE 2 或者 CASE 3。 |
| CASE 2 | 关注节点的父节点是红色，叔叔节点是黑色，<br/>且当前节点是其父节点的右孩子。 | (01) 将关注节点的父节点作为新的关注节点。<br/>(02) 以关注节点为支点进行左旋。<br/>跳到 CASE 3。                                                                           |
| CASE 3 | 关注节点的父节点是红色，叔叔节点是黑色，<br/>且当前节点是其父节点的左孩子。 | (01) 将“父节点”设为“黑色”。<br/>(02) 将“祖父节点”设为“红色”。<br/>(03) 以“祖父节点”为支点进行右旋。<br/>调整完成。                                                        |

> 上面三种情况Case处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。
>
> 详细图解见——[https://www.processon.com](https://www.processon.com/view/5d302e03e4b058ef96abffe6?fromnew=1)

## 删除操作

删除操作的平衡调整分为两步，第一步是**针对删除节点初步调整**。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是**针对关注节点进行二次调整**，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。

> 红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。

| 情况   | **现象说明**                                                                                       | **处理策略**                                                                                                                                                                 |
| ------ | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Case 1 | x是"黑+黑"节点，x的兄弟节点是红色。<br/>(此时x的父节点和x的兄弟节点的子节点都是黑节点)。           | (01) 将x的兄弟节点设为“黑色”。<br/>(02) 将x的父节点设为“红色”。<br/>(03) 对x的父节点进行左旋。<br/>(04) 左旋后，重新设置x的兄弟节点。                                        |
| Case 2 | x是“黑+黑”节点，x的兄弟节点是黑色，<br/>x的兄弟节点的两个孩子都是黑色。                            | (01) 将x的兄弟节点设为“红色”。<br/>(02) 设置“x的父节点”为“新的x节点”。                                                                                                       |
| Case 3 | x是“黑+黑”节点，x的兄弟节点是黑色；<br/>x的兄弟节点的左孩子是红色，右孩子是黑色的。                | (01) 将x兄弟节点的左孩子设为“黑色”。<br/>(02) 将x兄弟节点设为“红色”。<br/>(03) 对x的兄弟节点进行右旋。 <br/>(04) 右旋后，重新设置x的兄弟节点。                               |
| Case 4 | x是“黑+黑”节点，x的兄弟节点是黑色；<br/>x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。 | (01) 将x父节点颜色 赋值给 x的兄弟节点。<br/>(02) 将x父节点设为“黑色”。<br/>(03) 将x兄弟节点的右子节设为“黑色”。<br/>(04) 对x的父节点进行左旋。 <br/>(05) 设置“x”为“根节点”。 |

> 详细图解见——[https://www.processon.com](https://www.processon.com/view/5d311edde4b02015bd828c6f?fromnew=1)

------

**问题**：为什么红黑树的定义中，要求叶子节点是黑色的空节点？

**解答**：为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为上面刚刚讲的那几种情况。

# 参考

* [红黑树(一)之 原理和算法详细介绍](https://www.cnblogs.com/skywang12345/p/3245399.html)
* [红黑树(五)之 Java的实现](https://www.cnblogs.com/skywang12345/p/3624343.html)

