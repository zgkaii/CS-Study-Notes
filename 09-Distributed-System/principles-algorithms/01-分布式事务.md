<!-- MarkdownTOC -->

- [什么是分布式事务？](#什么是分布式事务)
- [分布式事务的实现方案？](#分布式事务的实现方案)
  - [XA分布式事务](#xa分布式事务)
    - [什么是XA](#什么是xa)
    - [MySQL XA事务的实现](#mysql-xa事务的实现)
    - [XA事务的缺点](#xa事务的缺点)
  - [BASE柔性事务](#base柔性事务)
    - [什么是BASE柔性事务](#什么是base柔性事务)
    - [TCC](#tcc)
    - [SAGA](#saga)
    - [AT](#at)
    - [柔性事务对ACID的支持](#柔性事务对acid的支持)
- [如何选择分布式事务呢？](#如何选择分布式事务呢)
- [参考资料](#参考资料)

<!-- /MarkdownTOC -->
# 什么是分布式事务？

分布式事务，可以理解为：**分布式条件下，多个节点操作的整体事务一致性**。

例如在微服务场景下，业务 A 和业务 B 关联，事务 A 成功，事务 B 失败，由于跨系统，就会导致不被感知。此时从整体来看，数据是不一致的。此时，业务系统只能拿到不完全的 A 服务数据，缺失 B 服务的数据。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630143021971.png" width="500px"/>
</div>

随着互联网的发展，业务系统的复杂度及数据量都在显著提升，集中式环境已经不能满足业务的需要了，只能按照业务为单位进行数据拆分(包含：垂直拆分与水平拆分)；以及按照业务为单位提供服务，从早期的集中式转变为面向服务架构的分布式应用环境。这种场景中采用分布式事务来保持不同资源服务器的数据一致性是很有必要的。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630142611507.png" width="400px"/>
</div>

# 分布式事务的实现方案？

如何实现分布式事务呢？通常由两个思路：

1、理想状态：直接像直接像单机数据库事务一样，多个数据库自动通过某种协调机制，实现了跨数据库节点的一致性。

* 使用场景：要求严格的一致性，比如金融交易类业务。

2、一般情况：可以容忍一段时间的数据不一致，最终通过超时终止，调度补偿，等等方式，实现 数据的最终状态一致性。

* 使用场景：准实时或非实时的处理，比如 T+1的各类操作，或者电商类操作。

按照这两种思路，可以把分布式事务方案分为：

* 强一致性：XA
* 弱一致性
  * 不用事务，业务侧补偿冲正： 
  * 所谓的柔性事务，使用一套事务框架保证最终一致的事务：TCC、SAGA、AT

## XA分布式事务

### 什么是XA

基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA 分布式事务。 XA 整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。

**XA**是X/Open DTP组织（X/Open DTP group）定义的两阶段提交协议，XA被许多数据库（如Oracle、DB2、SQL Server、MySQL）和中间件等工具(如CICS 和 Tuxedo)本地支持 。X/Open DTP模型主要有如下角色：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630144950746.png" width="600px"/>
</div>

其中主要角色有：

* 应用程序（Application Program ，简称 **AP**）： 用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作；
* 资源管理器（Resource Manager，简称 **RM**）： 如数据库、文件系统等，并提供访问资源的方式；
* 事务管理器 （Transaction Manager ，简称 **TM**）：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。

XA 主要规定了RM与TM之间的交互，下面来看下XA规范中定义的RM 和 TM交互的接口：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630145449952.png" width="500px"/>
</div>

其中重要的接口有：

* `xa_start` ：负责开启或者恢复一个事务分支；
* `xa_end`： 负责取消当前线程与事务分支的关联；
* `xa_prepare`：询问 RM 是否准备好提交事务分支；
* `xa_commit`：通知 RM 提交事务分支；
* `xa_rollback`： 通知 RM 回滚事务分支；
* `xa_recover` : 需要恢复的 XA 事务。

XA规范的基础是**两阶段提交协议**，其中：

* 第一阶段：事务管理器TM 请求所有的资源管理器RM 预提交（prepare）各自的事务分支，以确认RM是否有能力提交各自事务。
* 第二阶段：事务管理器TM 根据第一阶段资源管理器RM预提交的结果，决定提交还是回滚事务。

### MySQL XA事务的实现

MySQL 从5.0.3开始支持 `InnoDB` 引擎的 XA 分布式事务，MySQL Connector/J 从5.0.0版本开始支持 XA。DTP 模型中，MySQL 属于资源管理器（RM）。分布式事务中存在多个 RM，由事务管理器 TM 来统一进行协调。

MySQL下XA事务语法：

```mysql
XA {START|BEGIN} xid [JOIN|RESUME]  启动一个XA事务 (xid必须是一个唯一值; [JOIN|RESUME]字句不被支持) 
XA END xid [SUSPEND [FOR MIGRATE]]  结束一个XA事务 ( [SUSPEND [FOR MIGRATE]] 字句不被支持)
XA PREPARE xid   				    准备
XA COMMIT xid [ONE PHASE]           提交XA事务
XA ROLLBACK xid                     回滚XA事务
XA RECOVER                          查看处于PREPARE 阶段的所有XA事务
```

MySQL XA 事务状态图如下：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021063015140946.png" width="800px"/>
</div>

需要注意的是，**XA 事务和非XA 事务（即本地事务）时互斥的**。例如，已经执行了XA START命令开启了一个XA事务后，则本地事务不会启动，直到XA事务被提交或被回滚为止。相反地，如果已经使用了START TRANSACTION启动本地事务，那么XA事务不能被使用，直到本地事务提交或者回滚为止。

完整的 XA 事务处理过程：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630152019207.png" width="800px"/>
</div>

------

思考问题：XA 过程中，事务失败怎么办？ 

1、业务 SQL 执行过程，某个 RM 崩溃怎么处理？回滚 

2、全部 prepare 后，某个 RM 崩溃怎么处理？ 回滚

3、commit 时，某个 RM 崩溃怎么办？重试commit

------

单个 MySQL 的内部操作：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630152219943.png" width="800px"/>
</div>

**5.7对 MySQL XA 的优化/bug 修复**

`MySQL<5.7`版本会出现的问题 ： 已经 prepare 的事务，在客户端退出或者服务宕机的时候，2PC 的事务会被回滚 ；在服务器故障重启提交后，相应的 `binlog` 被丢失。

> MySQL 5.6版本在客户端退出的时候，自动把已经 prepare 的事务回滚了，那么 MySQL 为什么要这样做？这主要取决于 MySQL 的内部实现， MySQL 5.7以前的版本，对于 prepare 的事务， MySQL 是不会记录 binlog 的（官方说是减少 fsync，起到了优化的作用）。只有当分布式事务提交的时候才会把前面的操作写入 binlog 信息，所以对于 binlog 来说，分布式事务与普通的事务没有区别，而 prepare 以前的操作信息都保存在连接的 IO_CACHE 中，如果这个时候客户退 出了，以前的 binlog 信息都会被丢失，再次重连后允许提交的话，会造成 Binlog 丢失，从而造成主从数据的不一致，所 以官方在客户端退出的时候直接把已经 prepare 的事务都回滚了！

`MySQL>5.7`版本的优化（https://dev.mysql.com/worklog/task/?id=6860） 

* MySQL 对于分布式事务，在 prepare 的时候就完成了写 binlog 的操作，通过新增一种叫 `XA_prepare_log_event`的 event 类型来实现，这是与以前版本的主要区别（以前版本 prepare 时不写binlog）

### XA事务的缺点

XA事务的确能保证强一致性，但是也有如下几个缺点：（注意**XA事务并不会改变隔离级别**）

* **同步阻塞问题**

全局事务内部包含了多个独立的事务分支，这一组事务分支要不都成功，要不都失败，各个事务分支的ACID特性共同构成了全局事务的ACID特性。也就是将单个事务分支的支持的ACID特性提升一个层次（up a level）到分布式事务的范畴。即使在非分布式事务中（即本地事务），如果对操作读很敏感，我们也需要将事务隔离级别设置为SERIALIZABLE。而对于分布式事务来说，更是如此，可重复读隔离级别不足以保证分布式事务一致性。 （一般情况下，不需要调高隔离级别）

也就是说，如果我们使用MySQL来支持XA分布式事务的话，那么最好将事务隔离级别设置为SERIALIZABLE。地球人都知道， SERIALIZABLE（串行化）是四个事务隔离级别中最高的一个级别，也是执行效率最低的一个级别。

* **单点故障** 

由于协调者的重要性，一旦协调者TM发生故障，参与者RM会一直阻塞下去，尤其在第二阶段，协调者发生故障，那么所有的参与者还处于锁定事务资源的状态中，而无法继续完成事务操作。（如果协调者挂掉，可以重新选举一个协调者，但是无法解决因 为协调宕机导致的参与者处于阻塞状态的问题）。（成熟的XA框架需要考虑TM的高可用性）

* **数据不一致** 

在二阶段提交的阶段二中，当协调者向参与者发功commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接收到了commit请求，而在这部分参与者接到commit请求之后就会执行commit操 作。但是其他部分未接到commit请求的机器则无法执行事务提交，于是整个分布式系统便出现了数据不一致的现象。（极端情况下，一定有事务失败问题，需要监控和人工处理）

如何解决呢？

推荐使用使用`ShardingSphere`。`ShardingSphere` 支持基于 XA 的强一致性事务解决方案，可以通过 SPI 注入不同的第三方组件作为事务管理器实现 XA 协议，如 `Atomikos` 和 `Narayana` 。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630153151535.png" width="800px"/>
</div>

## BASE柔性事务

### 什么是BASE柔性事务

如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称为柔 性事务。 

BASE 是**基本可用、柔性状态和最终一致性**这三个要素的缩写。

* 基本可用（Basically Available）保证分布式事务参与方不一定同时在线。
* 柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。
* 而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。

在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的理念 则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。**通过放宽对强一致性要求，来换取系统吞吐量的提升**。

`本地事务 -> XA（2PC）-> BASE`的对比如下：

| 对比     | 本地事务         | 两（三）阶段事务 | 柔性事务      |
| -------- | ---------------- | ---------------- | ------------- |
| 业务改造 | 无               | 无               | 实现相关接口  |
| 一致性   | 不支持           | 支持             | 最终一致      |
| 隔离性   | 不支持           | 支持             | 业务保证方    |
| 并发性能 | 无影响           | 严重衰退         | 略微衰退      |
| 适合场景 | 业务方处理不一致 | 短事务&低并发    | 长事务&高并发 |

BASE 柔性事务常见模式：

* TCC：通过手动补偿处理

* AT：通过自动补偿处理

### TCC

TCC 模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有 服务业务的 Try 状态来操作，如果都成功，则进行 Confirm 操作，如果任意一个 Try 发生错误，则全 部 Cancel.

TCC 使用要求就是业务接口都必须实现三段逻辑： 

1. **准备操作 Try**：完成所有业务检查，预留必须的业务资源。
2. **确认操作 Confirm**：真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源。 因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。 
3. **取消操作 Cancel**：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

TCC 不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务，不同于 AT 的是**需要自行定义各个阶段的逻辑，对业务有侵入**。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630155411134.png" width="800px"/>
</div>

TCC 需要注意的几个问题： 

* **允许空回滚** ：事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；
  * TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚，TCC服务在实现时应当允许空回滚的执行。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630161325327.png" width="600px"/>
</div>

* **防悬挂控制** ：事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，出现了二阶段Cancel请求比一阶段Try请求先执行的情况；
  * 用户在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630161325162.png" width="600px"/>
</div>

* **幂等设计**：无论是网络数据包重传，还是异常事务的补偿执行，都会导致TCC服务的Try、Confirm或者Cancel操作被重复执行。
  * 在实现TCC服务时，需要考虑幂等控制，即Try、Confirm、Cancel 执行一次和执行多次的业务结果是一样的。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630161324823.png" width="400px"/>
</div>

### SAGA

Saga 核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

Saga 的组成如下：

- 每个 Saga 由一系列 sub-transaction Ti 组成;
- 每个Ti 都有对应的补偿动作 Ci ，补偿动作用于撤销 Ti 造成的结果。这里的每个 T ，都是一个本地事务;
- 可以看到，和 TCC 相比，**Saga 没有“预留 try”动作 ，它的 Ti 就是直接提交到库**。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630162030512.png" width="400px"/>
</div>

Saga的执行顺序有两种：

- 子事务序列 T1, T2, …, Tn得以完成 (最佳情况)。
- 或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 < j < n, 得以完成。

Saga 定义了两种恢复策略：

- 向后恢复：补偿所有已完成的事务，如果任一子事务失败。

- 向前恢复：重试失败的事务，假设每个子事务最终都会成功。


### AT

AT 模式是一种无侵入的分布式事务解决方案，支持两阶段提交，自动生成反向 SQL。Seata框架，实现了该模式。

在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630161653405.png" width="600px"/>
</div>

### 柔性事务对ACID的支持

* 原子性（Atomicity）：完全支持。
* 一致性（Consistency）：只提供最终一致性支持。也就是说，在某个时间点，会出现 A 库和 B 库的数据违反一致性要求的情况。
* 隔离性（Isolation）：不完全保证，通常为了系统的吞吐和性能，会一定程度上放弃对隔离性的要求。
* 持久性（Durability）：完全支持。跟本地事务一样，只要 commit 则数据被持久。 

**隔离级别** 

* 一般情况下都是读已提交（全局锁）、读未提交（无全局锁）。

# 如何选择分布式事务呢？

1、业务上有强一致性要求的场景时，优先考虑 XA 规范的两阶段提交；

2、业务上只需要最终一致性的场景时，可以在根据具体场景在柔性事务方案中进行选择。

* AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。
* TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。
* Saga 模式是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。

# 参考资料

* [分布式事务之TCC服务设计和实现注意事项](https://segmentfault.com/a/1190000015612188)
*  [再有人问你分布式事务，把这篇扔给他](https://juejin.im/post/5b5a0bf9f265da0f6523913b)
* [分布式事务 Seata Saga 模式首秀以及三种模式详解](https://juejin.cn/post/6844903913691283469)
* [如何选择分布式事务解决方案？](https://developer.aliyun.com/article/762770)

