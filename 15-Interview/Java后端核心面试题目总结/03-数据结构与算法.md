# 数据结构

## 数组与链表有什么区别？应用场景？

数组和链表都是一种线性表的数据结构。区别在于：

* **连续 VS 不连续**：数组是用连续的内存空间来存储相同类型的数据，而链表不需要连续的内存空间，它通过指针将一组零碎的内存块串联起来。
* **时间复杂度**：随机访问的时间复杂度上数组为O(1)，链表为O(n)；插入、删除操作上数组为O(n)，链表为O(1)。
  * 数组访问不一定大于链表，比如双向链表空间换时间，插入、删除、查找都O(1)。
* 应用场景选择——**OOM VS 内存碎片**：数组由于内存空间连续的特性，容易产生OOM；对链表频繁地插入删除操作容易产生内存碎片，频繁GC。

## 栈与队列有什么区别？应用场景？

栈和队列也是一种操作受限的线性表的数据结构，只允许一端插入和删除数据：

* 栈：先进后出（生活中叠盘子），数组实现则是顺序栈，链表实现则是链式栈，入栈出栈时间复杂度为O(1)；
* 队列：先进先出（排队买票），数组实现则是顺序队列，链表实现则是链式队列，出队入队时间复杂度为O(1);

应用场景：

* 栈：函数调用、表达式求值等底层实现；
* 队列：**阻塞队列**、并发队列。

## 什么是跳表？为什么会有跳表？

> [https://juejin.cn/post/6844903955831619597](https://juejin.cn/post/6844903955831619597)

数组随机访问时间复杂度O(1)指的是**通过下标进行随机访问**的时间复杂度为O(1)，而二分查找算法就需要按照下标随机访问元素。如何在链表上实现类似的快速地“二分查找”呢？这就的引出跳表了。

跳表是一种各方面性能都比较优秀的**动态数据结构**，它通过在链表上加上索引层，实现类似于二分查找的效果，插入、删除、查询时间复杂度皆为 `O(logn)`。

**引申**：为什么 `Redis` 要用跳表来实现有序集合，而不是红黑树？

* 插入、删除、查找时间复杂度一样，但按照区间来查找数据这个操作，红黑树的效率没有跳表高；
* 跳表实现更简单、灵活，但需要自己实现；很多编程语言中的 Map 类型通过红黑树来实现的。

## 谈谈你对散列表的理解？散列表应用场景？

散列表又称“哈希表”，他是基于数组随机访问特性拓展而来的，主要存储`key-value`键值对数据。为了保证存储的key能够随机并均匀分布，就要用到散列函数（又称“哈希函数“）处理，把key映射成一个可以唯一标识key的散列值（哈希值）。

但是，就算业界著名的[MD5](https://zh.wikipedia.org/wiki/MD5)、[SHA](https://zh.wikipedia.org/wiki/SHA家族)、[CRC](https://zh.wikipedia.org/wiki/循環冗餘校驗)等哈希算法，也无法完全避免这种**散列冲突**。而且，因为数组的存储空间有限，也会加大散列冲突的概率。

如何在插入数据时处理散列冲突呢？这里有两种方法：

* **开放寻址法**：有冲突就重新找一个空位置再插入。如线性探测/二叉探测/双重散列找新位置。
* **链表法**：数组中每个位置对应一个“桶（bucket）”或者“槽（slot）”，桶中存储一条链表，有冲突就把数据加到链表上。这样时间复杂度：插入O(1)，删除、查找O(k)  （k为链表节点个数）。

如何设计一个散列表呢？主要关注两点：

* 散列函数：不能太复杂、生成的值要尽量随机并均匀分布。
* **装载因子**：**散列表的装载因子 = 填入表中的元素个数 / 散列表的长度。装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大，查询会慢（需动态扩容）。不易过大也不易过小，例如`HashMap`装载因子为0.75**。
* 解决冲突方法： **`LinkedHashMap` 就采用了链表法解决冲突，`ThreadLocalMap` 是通过线性探测的开放寻址法来解决冲突**。
  * 开放寻址法：数据都存储在数组中，查询快，序列化简单，但删除数据难，冲突代价更大。
  * 链表法：对大装载因子容忍度更大，更灵活可扩展，比如用红黑树替换链表；但节点零散分布在内存中，不连续。
  * 总结一下，**数据量小、装载因子小，适合开放寻址法；存储大对象、大数据量，要求更灵活地扩展，适合链表法**。

散列表的应用？

* HashMap、LRU（链表+HashMap O(1) ）、Redis 有序集合、LinkedHashMap（双向链表+散列表）

## 谈谈你对二叉树的理解?

树是非线性的数据结构，存储方法主要有两种：

* 基于指针或引用的链式存储法（常见）
* 基于数组的顺序存储法（堆就是完成二叉树的数组存储）

关于树的基本操作有：

* 前序遍历（本身-> 左 -> 右），中序遍历（左->本身->右），后序遍历（左->右->本身），层序遍历（逐层向下）

二叉查找树（BST 树）特点是左节点<根节点<右节点，查找、删除、插入时间复杂度都为都是`O(logn)`。

* 引申：有了散列表O(1) 为什么还要二叉树`O(logn)`？
  * 散列表无序存储、扩容耗时多、哈希冲突导致性能不稳定、构造复杂、装载因子浪费内存。
* **二叉查找树最坏情况下可能会退化成链表，查询时间复杂度变为了O(n)**，为解决这个树平衡问题，有了平衡二叉查找树（AVL）树与`2-3树`等。

平衡二叉查找树（AVL树）中任意一个节点的左右子树的**高度相差不能大于 1**。

## 谈谈你对红黑树的理解？

什么是红黑树？

* `2-3树`是为了树是一种非常巧妙的结构，在保持树结构的基础上，它允许在一个节点中可以有两个元素，等元素数量等于 3 个时候再进行调整。通过这种方式来保证二叉查找树的平衡性。`2-3树`查找、删除、插入时间复杂度都能保持在`O(logn)`。

* 实际上`2-3 树`转红黑树是由概念模型 `2-3-4树`转换而来的。

* 红黑树的规则为：

  * **根节点是黑色的；**
  * **每个节点或者说黑色，或者是红色；**

  - **每个叶子节点都是黑色的空节点（叶子结点即指树尾端NIL指针或NULL结点），也就是说，叶子节点不存储数据；**
  - **任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；**
  - **每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；**

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210515174131296.png" width="500px"/>
</div>

> 图中叶子节点都省略未画出

红黑树的时间复杂度是多少？

* 红黑树的高度近似 log~2~n，**红黑树的插入、删除、查找各种操作性能都比较稳定，时间复杂度都是 `O(logn)`。**

红黑树中插入新的节点时怎么保持平衡？

* **红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上**。
* 关于插入操作的平衡调整，有这样两种特殊情况：
  * 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
  * 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。
* 其他插入CASE平衡的核心思想是：通过左旋或者右旋，将红色的节点移到根节点；然后，将根节点设为黑色。

红黑树的数据结构都用在哪些场景？ 

* Java的集合框架 (HashMap、TreeMap、TreeSet)、Nginx的Timer管理、Linux虚拟内存管理以及C++的STL等等。

红黑树和平衡二叉树的比较**，`HashMap`为什么不使用平衡二叉树（AVL）**？

* AVL树的平衡更加严格，频繁的插入/删除操作的性能代价大，更适合查找密集型任务。
* 红黑树则更适合于插入/删除密集型任务。
* AVL树的旋转比红黑树的旋转更难实现和调试。

# 算法

## 常见排序算法

> [十大经典排序算法-简析](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90.md)

## 二分查找

> [二分查找](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md)

## 递归与迭代

> [递归与迭代](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3.md)

## 分治与回溯

> [分治与回溯](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E5%88%86%E6%B2%BB%E4%B8%8E%E5%9B%9E%E6%BA%AF.md)

## 深度优先搜索与广度优先搜索

> [深度优先搜索与广度优先搜索](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.md)

## 贪心算法与动态规划

> [贪心算法与动态规划](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md)

## 位运算

> [位运算](https://github.com/zgkaii/CS-Study-Notes/blob/master/03-Data-Structures%26Algorithms/algorithm/%E7%AE%97%E6%B3%95%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.md)

# 常见算法题

1. 链表反转、数组反转
2. LRU缓存
3. 判断链表是不是循环链表
4. 找出字符串中最长的对称子串
5. 动态规划-0-1背包问题公式推导
6. 1000万个数如何取出最大的10个数
7. 杨辉三角形问题
8. 深度优先搜索与广度优先搜索
9. 树的前、中、后序遍历、层次遍历