## 01 谈谈你对Java平台的理解？"Java是解释执行"这句话对吗？

Java作为一门面向对象的编程语言，最显著的特性有两个方面，一是**跨平台**的特性，也就是所谓的“一次编译，到处运行”；另外一个特性是Java通过**垃圾回收器**（GC）回收分配和回收内存。而实现这些特性的基础就是Java虚拟机（JVM），所以我们经常说JVM是Java语言的核心。

"Java是解释执行"这句话并不完全正确。我们编写的`.java`源文件先是通过`javac`编译器编译成`bytecode`字节码文件，然后通过JVM内嵌的解释器将字节码文件转换成机器码。但是，我们常用的JVM例如`Hotspot JVM`中，提供了 JIT（Just-In-Time）编译器，也就是所谓的动态编译器。**JIT编译器**能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就是属于编译执行了。



## 02 什么是面向对象？它与面向过程有什么区别？

面向对象（OOP）是一种编程范式或者说是一种编程风格。它以**类或对象**作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。

相较于面向对象编程，面向过程编程以**过程或者方法**作为组织代码的基本单元。起主要的特点就是数据和方法相分离。

面向对象相较于面向过程编程有如下两个优势：

* 面向对象编程更能应付大规模的复杂程序开发；
* 面向对象编程有更丰富的特性（封装、抽象、继承、多态），写出的代码扩展性、复用性、可维护性更好。

**谈谈对封装、抽象、继承、多态的理解？**



**重载和重写的区别？**



## 03 谈谈接口和抽象类有什么区别？

（1）抽象类和接口的语法特性

| 比较点            | 抽象类 | 接口                  |
| ----------------- | ------ | --------------------- |
| 成员变量类型      | 无限制 | `public static final` |
| 静态代码/静态方法 | 无限制 | 禁止                  |
| 类的继承          | 单继承 | 可多继承              |
| 方法体            | 可包含 | 禁止                  |

（2）设计目的

* 抽象类是对整个类整体进行抽象，包括属性、行为，是一种`is-a`的**继承**关系，主要是为了解决代码复用问题；而接口仅仅是对方法的抽象，是一种`has-a`的**组合**关系，表示某一组行为特性，主要是为了解耦，隔离接口和具体实现，提高代码的扩展性。
* 抽象类作为很多子类的父类，它是一种模板式设计；接口是一种行为规范，它是一种辐射式设计。

 **继承和组合的区别在哪？**

- 继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 `extends` 明确标识，在设计时一般没有争议性。
- 组合：组合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 `has-a` 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。
  - 比如，计算机与 CPU 、公司与员工的关系等。
  - 表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。详细可参考 [《怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？》](https://www.zhihu.com/question/21862257) 文章。



## 04 什么是内部类？匿名内部类呢？

简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。当然，详细的可以看看 [搞懂 JAVA 内部类](https://juejin.cn/post/6844903566293860366) 文章。

**内部类的作用是什么？**

内部类提供了更好的封装，除了该外部类，其他类都不能访问。

**Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？**

可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。

**内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？**

一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。



## 05 Java 中的几种基本数据类型是什么？各自占用多少字节？

Java支持的数据类型包括基本数据类型和引用类型。

其中**引用类型**有如下8种：

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |
| ------------ | ------- | -------- | ------------------------------------------ |
| 字节型       | byte    | 1 字节   | -128~127                                   |
| 短整型       | short   | 2 字节   | -32768~32767                               |
| 整型         | int     | 4字节    | -2147483648~2147483647                     |
| 长整型       | long    | 8字节    | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float   | 4字节    | +/-3.4E+38F（6~7 个有效位）                |
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |
| 字符型       | char    | 2 字节   | ISO 单一字符集                             |
| 单元格       | boolean | 1 字节   | true 或 false                              |

**引用类型**声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。

- 引用类型包括类、接口、数组等。
- 特别注意，String 是引用类型不是基本类型。

**什么是值传递和引用传递？**

- 值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。
- 引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。

一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。



## 06 String、StringBuffer、StringBuilder有什么区别？String为什么是不可变的？

String是Java中非常基础而又重要的类，它提供了构造和处理字符串的各种逻辑。String类是典型的immutable类，被声明为final class，所以的属性都是不可变的。也正是也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。这些频繁的操作往往对应用性能有很大的影响。

StringBuffe是为了解决String拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。

StringBuilder是Java 1.5中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。

> 效率：StringBuilder > StringBuffer > String

查看源码发现，String类是被final关键字修饰，也就是说String类是不可变的，这样做的好处在哪里呢？

* 保证String对象的安全性。
* 保证hash值不会被频繁变更，确保了唯一性。
* 可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 `String str = new String(“abc”)`。
  * 当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。
  * `String str = new String(“abc”) `这种方式，首先在编译类文件时，"abc"常量字符串将会放入到常量结构中，在类加载时，“abc"将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的"abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。



## 07 equals()与==和hashcode()的区别与联系？

[==、equals()与hashcode()的区别和联系](https://blog.csdn.net/KAIZ_LEARN/article/details/113704826)已经阐述清楚：

* **==运算符**比较基本数据类型时，比较的是实际内容值是否相同；比较引用数据类型时，比较的是堆内存地址是否相同。
* **equals() **方法主要用于判断两个对象的值是否相等（当然这是在equals()被重写的情况下）；未重写的equals() 方法与`==`运算符类似，比较的是对象的内存地址。
* 需要注意的是当equals()方法被重写时，hashCode()也要被重写；

引申问题：**为什么equals()方法被重写时，hashCode()也要被重写？**

* hashCode() 的作用是获取哈希码（hashcode），也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。在使用Object的equals()方法进行对象比较时，Java会首先计算出两个对象的hashcode并进行对比（这个过程非常简单而且节省JVM的时间），如果两个两个对象的hashcode相同，则直接判定为两对象相等。

* 按照一般hashCode()方法的实现来说，equals()相等的两个对象，hashcode()必须保持相等；equals()不相等的两个对象，hashcode()未必不相等。
* 因此，在使用`HashSet, HashTable, HashMap`等等这些本质是**散列表**数据结构的集合类时，重写hashCode()是很有必要的。



## 08 int和Integer有什么区别？

Java语言中，有8类原始数据类型（boolean、byte 、short、char、int、float、double、long），int就是其中一类。Integer是对int的包装类，它有一个int 类型的字段存储数据，并且提供了比如数学运算，字符串转换等基本操作。Java 5引进了自动装箱与自动拆箱的功能，从`int->Integer`的过程即自动装箱，`Integer->int`即自动拆箱。

引申问题1：**有了基本类型为什么还需要包装类**？

* Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。
* 另外，使用ArrayList，HashMap中时，像int，double等基本类型是放不进去的，因为容器都是装object的，这时就需要这些基本类型的包装类了。

引申问题2：**基本类型和包装类型二者的主要区别**？

* 声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间。
* 存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用。
* 初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null。
* 使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。


引申问题3：**Integer 的值缓存范围**？

* 关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，**这个值默认缓存是 -128 到 127 之间。**



## 09 Exception和Error有什么区别？运行时异常与一般异常又有什么区别？

Exception和Error都是Throwable类的子类，但它们体现了Java平台设计者处理异常时的不同思想。Exception是程序正常运行中，可以预料的意外情况，应该及时捕获进行相应处理，就比如我们人体感冒一样；而Error是正常情况下不太可能出现的情况，绝大多数的的Error都会导致程序（如JVM）处于非正常、不可恢复的状态，例如`OutofMemory`内存溢出错误。

Exception可以分为可检查异常和不检查异常。可检查就是指在编译器就得显示地捕获处理，是编译期检查的一部分；而不可查异常就是所谓的**运行时异常**，类似`NullPointerException、ArrayIndexOutOfBoundsException `之类，通常是一些代码可以避免的逻辑错误，并不一定要在编译期就强制指出。



## 10 谈谈final、finally、 finalize有什么不同？

final 修饰类、方法和变量有不同的含义。final修饰的class不可以被继承，final修饰的变量不可被修改，final修饰的方法也是不可被重写（overrride）的。

finally 是Java保证重点代码一定要被执行的一种机制。我们可以使用`try-finally`和`try-catch-finally`来关闭JDBC连接、保证unclok锁等动作。

finalize 是`java.lang.Object`类中一个方法，设计目的是用来保证对象在垃圾回收前完成特定的资源回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。



## 11 什么是Java序列化？

序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：

- **序列化**：把Java对象转换为字节序列。
- **反序列化**：把字节序列恢复为原先的Java对象。

> 我们不能将序列化局限在 Java 对象转换成二进制数组，我们还可以将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串。

**Serializable接口有什么用呢？**

将需要被序列化的类，实现 `Serializable` 接口，该接口没有需要实现的方法，`implements Serializable` 只是为了标注该对象是可被序列化的。

如果一个对象既不是**字符串**、**数组**、**枚举**，而且也没有实现`Serializable`接口的话，在序列化时就会抛出`NotSerializableException`异常！

**Java 序列化中，如果有些字段不想进行序列化怎么办？**

凡是被`static`修饰的字段都是不会被序列化的。因为序列化保存的是**对象的状态**而非类的状态，所以会忽略`static`静态域也是理所应当的。

对于不想进行序列化的变量，一般使用 `transient` 关键字来修饰。

- 当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。
- 当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。
- `transient` 只能修饰变量，不能修饰类和方法。



## 12 如何实现对象拷贝/克隆 (深拷贝与浅拷贝)？

浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。

深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且**修改新对象不会影响原对象**。

实现**浅拷贝**：实现 Cloneable 接口，并重写 Object 类中的 `#clone()` 方法。

实现**深拷贝**一般有两种方式：

- 实现 Cloneable 接口，并重写 Object 类中的 `#clone()` 方法也可以实现深拷贝。与浅拷贝的区别在于重写`#clone()`方法时创建拷贝类的一个新对象，这样就和原始对象相互独立。
- 实现 Serializable 接口，通过对象的序列化和反序列化实现拷贝，可以实现真正的深拷贝。

具体的代码实现，可以看看 [《Java深拷贝和浅拷贝》](https://juejin.cn/post/6844903806577164302) 文章。

实际场景下，我们使用的拷贝比较少，更多是对象之间的属性拷贝。例如说，将 DO 的属性复制到 DTO 中，又或者将 DTO 的属性复制到 VO 中。此时，我们一般使用 BeanUtils 工具类。具体的使用，看看 [《浅谈 BeanUtils 的拷贝，深度拷贝》](https://www.cnblogs.com/tison/p/7840647.html) 文章。



## 13 强引用、软引用、弱引用、虚引用有什么区别？

这些不同的引用类型的区别主要体现在垃圾回收的时候可达性的区别。

强引用——不回收

* 强引用就是我们常见的普通对象引用，只要强引用还指向一个对象（可触及），垃圾回收器就永远不会回收掉它。相对地，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因（循环依赖）。

软引用——内存不足回收

* 软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集。在系统发生内存溢出前时，JVM才会回收这些被弱引用关联的对象。软引用通常用来实现内存敏感的缓存。比如：**高速缓存**就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

弱引用——发现即回收

* 在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。软引用、弱引用都非常适合来保存那些**可有可无的缓存数据**。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

虚引用——对象回收跟踪

* 虚引用又称“幻象引用”，我们不能通过它访问对象。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。**为一个对象设置虚引用关联的目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知**。



## 14 说说反射机制及其用途？

Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，**反射机制指的是程序在运行时能够获取自身的信息的一种能力。**

通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。

反射的主要应用场景有：

- **开发通用框架** - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。例如Spring框架实例化对象时，Spring 会读取配置文件`applicationContext.xml`并解析出里面所有的 标签实例化到`IOC`容器中；又比如使用JDBC连接数据库时，指定连接数据库的`驱动类`时用到反射加载驱动类。
- **动态代理** - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。
- **注解** - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。
- **可扩展性功能** - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。

**反射中Class.forName 和 ClassLoader 区别？**

这两者，都可用来对类进行加载。差别在于：

- `Class#forName(...)` 方法，除了将类的 `.class` 文件加载到JVM 中之外，还会对类进行解释，执行类中的 `static` 块。
- `ClassLoader`只干一件事情，就是将 `.class` 文件加载到 JVM 中，不会执行 `static` 中的内容，只有在 `newInstance`才会去执行 `static` 块。

> `Class#forName(name, initialize, loader)` 方法，带参函数也可控制是否加载 `static` 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。



## 15 动态代理是基于什么原理？它与静态代理有什么区别？

动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。

实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。



## 16 Java提供了哪些IO方式？ NIO如何实现多路复用？

Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。

首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。`java.io` 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。

很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。

第二，在 Java 1.4 中引入了 NIO 框架（`java.nio` 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。



## 17 Java有几种文件拷贝方式？哪一种最高效？

Java 有多种比较典型的文件拷贝实现方式，比如：利用 `java.io` 类库，直接为源文件构建一个 `FileInputStream` 读取，然后再为目标文件构建一个 `FileOutputStream`，完成写入工作。

或者，利用 `java.nio` 类库提供的 transferTo 或 transferFrom 方法实现。

当然，Java 标准类库本身已经提供了几种 `Files.copy` 的实现。对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式**可能更快**，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。



## 18 什么时候用断言（assert）？

断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。

- 一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。

- 断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为`true`；如果表达式的值为 `false` ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：

  ```java
  assert(a > 0); // throws an AssertionError if a <= 0
  ```

  - 断言可以有两种形式：
    - `assert Expression1;` 。
    - `assert Expression1 : Expression2;` 。
    - Expression1 应该总是产生一个布尔值。
    - Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。

- 要在运行时启用断言，可以在启动 JVM 时使用 `-enableassertions` 或者 `-ea` 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 `-da` 或者 `-disableassertions` 标记。要在系统类中启用或禁用断言，可使用 `-esa` 或 `-dsa` 标记。还可以在包的基础上启用或者禁用断言。

当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。

另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。



## 19 Java对象的创建方式有几种呢？

Java对象创建方式有5种：

- 用**new关键字**创建对象，需要使用构造器。
- 使用**反射机制**创建对象，用**Class类或Constructor类的newInstance()方法**，需要使用构造器。 
- 通过**Object类的clone**方法，需要实现Cloneable接口，重写Object类的clone方法。
- 使用**反序列化**。



## 20 什么是注解？

从 Java5 版本之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation），是 Java 平台中非常重要的一部分。注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。

注解常见的作用有以下几种：

* 生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @see、@param 和 @return 等；

* 跟踪代码依赖性，实现替代配置文件功能。比较常见的是Spring 2.5开始的基于注解配置，作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；

* 在编译时进行格式检查。如把 @Override 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。



## 21 Object有哪些方法，有什么作用？

http://www.justdojava.com/2019/08/21/javaBasic-Object/



## 22 Java8 Stream流实现原理？



## 23 既然有了字节流,为什么还要有字符流?

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。



## 24 聊聊你对Java泛型的理解？



## 25 为什么 Java 中只有值传递？



## 26 什么是零拷贝？

https://www.cnblogs.com/rickiyang/p/13265043.html



## 27 了解Java新特性吗？



## 28 服务端获取客户端要调用的接口信息后，怎么找到对应的实现类的？

