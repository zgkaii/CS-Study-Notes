## 01 谈谈你对Java平台的理解？"Java是解释执行"这句话对吗？

Java作为一门面向对象的编程语言，最显著的特性有两个方面，一是跨平台的特性，也就是所谓的“一次编译，到处运行”；另外一个特性是Java通过垃圾回收器（GC）回收分配和回收内存。而实现这些特性的基础就是Java虚拟机（JVM），所以我们经常说JVM是Java语言的核心。

"Java是解释执行"这句话并不完全正确。我们编写的`.java`源文件先是通过`javac`编译器编译成`bytecode`字节码文件，然后通过JVM内嵌的解释器将字节码文件转换成机器码。但是，我们常用的JVM例如`Hotspot JVM`中，提供了 JIT（Just-In-Time）编译器，也就是所谓的动态编译器。JIT编译器能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就是属于编译执行了。



## 02 Exception和Error有什么区别？运行时异常与一般异常又有什么区别？

Exception和Error都是Throwable类的子类，但它们体现了Java平台设计者处理异常时的不同思想。Exception是程序正常运行中，可以预料的意外情况，应该及时捕获进行相应处理，就比如我们人体感冒一样；而Error是正常情况下不太可能出现的情况，绝大多数的的Error都会导致程序（如JVM）处于非正常、不可恢复的状态，例如`OutofMemory`内存溢出错误。

Exception可以分为可检查异常和不检查异常。可检查就是指在编译器就得显示地捕获处理，是编译期检查的一部分；而不可查异常就是所谓的**运行时异常**，类似`NullPointerException、ArrayIndexOutOfBoundsException `之类，通常是一些代码可以避免的逻辑错误，并不一定要在编译期就强制指出。



## 03 谈谈final、finally、 finalize有什么不同？

final 修饰类、方法和变量有不同的含义。final修饰的class不可以被继承，final修饰的变量不可被修改，final修饰的方法也是不可被重写（overrride）的。

finally 是Java保证重点代码一定要被执行的一种机制。我们可以使用`try-finally`和`try-catch-finally`来关闭JDBC连接、保证unclok锁等动作。

finalize 是`java.lang.Object`类中一个方法，设计目的是用来保证对象在垃圾回收前完成特定的资源回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。



## 04 强引用、软引用、弱引用、虚引用有什么区别？

这些不同的引用类型的区别主要体现在垃圾回收的时候可达性的区别。

强引用——不回收

* 强引用就是我们常见的普通对象引用，只要强引用还指向一个对象（可触及），垃圾回收器就永远不会回收掉它。相对地，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因（循环依赖）。

软引用——内存不足回收

* 软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集。在系统发生内存溢出前时，JVM才会回收这些被弱引用关联的对象。软引用通常用来实现内存敏感的缓存。比如：**高速缓存**就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

弱引用——发现即回收

* 在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。软引用、弱引用都非常适合来保存那些**可有可无的缓存数据**。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

虚引用——对象回收跟踪

* 虚引用又称“幻象引用”，我们不能通过它访问对象。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。**为一个对象设置虚引用关联的目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知**。



## 05 String、StringBuffer、StringBuilder有什么区别？

String是Java中非常基础而又重要的类，它提供了构造和处理字符串的各种逻辑。String类是典型的immutable类，被声明为final class，所以的属性都是不可变的。也正是也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。这些频繁的操作往往对应用性能有很大的影响。

StringBuffe是为了解决String拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。

StringBuilder是Java 1.5中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。

> 效率：StringBuilder > StringBuffer > String



## 06 动态代理是基于什么原理？

反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时**自省**（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。

动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。

实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。



## 07 int和Integer有什么区别？

Java语言中，有8类原始数据类型（boolean、byte 、short、char、int、float、double、long），int就是其中一类。Integer是对int的包装类，它有一个int 类型的字段存储数据，并且提供了比如数学运算，字符串转换等基本操作。Java 5引进了自动装箱与自动拆箱的功能，从`int->Integer`的过程即自动装箱，`Integer->int`即自动拆箱。

引申问题1：有了基本类型为什么还需要包装类？

* Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。
* 另外，使用ArrayList，HashMap中时，像int，double等基本类型是放不进去的，因为容器都是装object的，这时就需要这些基本类型的包装类了。

引申问题2：基本类型和包装类型二者的主要区别？

* 声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间。
* 存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用。
* 初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null。
* 使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。


引申问题：Integer 的值缓存范围？

* 关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，**这个值默认缓存是 -128 到 127 之间。**



## 08 Java提供了哪些IO方式？ NIO如何实现多路复用？

Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。

首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。`java.io` 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。

很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。

第二，在 Java 1.4 中引入了 NIO 框架（`java.nio` 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。



## 09 Java有几种文件拷贝方式？哪一种最高效？

Java 有多种比较典型的文件拷贝实现方式，比如：利用 `java.io` 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。或者，利用 `java.nio` 类库提供的 transferTo 或 transferFrom 方法实现。

当然，Java 标准类库本身已经提供了几种 `Files.copy` 的实现。对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式**可能更快**，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。



## 10 谈谈接口和抽象类有什么区别？

2）设计层面上的区别

* 抽象类是对整个类整体进行抽象，包括属性、行为；接口却是对类局部（行为）进行抽象。
* 抽象类作为很多子类的父类，它是一种模板式设计；接口是一种行为规范，它是一种辐射式设计。

Java中使用abstract表示抽象类，interface表示接口。

（1）抽象类和接口的语法特性

| 比较点            | 抽象类 | 接口                  |
| ----------------- | ------ | --------------------- |
| 成员变量类型      | 无限制 | `public static final` |
| 静态代码/静态方法 | 无限制 | 禁止                  |
| 类的继承          | 单继承 | 可多继承              |
| 方法体            | 可包含 | 禁止                  |

（2）设计目的

* 抽象类是对整个类整体进行抽象，包括属性、行为，是一种`is-a`的关系，主要是为了解决代码复用问题；而接口仅仅是对方法的抽象，是一种`has-a`的关系，表示某一组行为特性，主要是为了解耦，隔离接口和具体实现，提高代码的扩展性。
*  抽象类作为很多子类的父类，它是一种模板式设计；接口是一种行为规范，它是一种辐射式设计。

