- [01 简述一下计算机网络体系结构](#01-简述一下计算机网络体系结构)
- [02 如果设计一个聊天系统，应该用 TCP 还是 UDP？为什么？](#02-如果设计一个聊天系统应该用-tcp-还是-udp为什么)
- [03 TCP 如何保证传输可靠性?](#03-tcp-如何保证传输可靠性)
- [04 什么是 TCP 滑动窗口？](#04-什么是-tcp-滑动窗口)
- [05 TCP 三次握手和四次挥手](#05-tcp-三次握手和四次挥手)
  - [三次握手](#三次握手)
    - [第2次握手传回了ACK，为什么也传回了SYN？](#第2次握手传回了ack为什么也传回了syn)
    - [为什么要三次握手？两次握手不行吗？](#为什么要三次握手两次握手不行吗)
  - [四次挥手](#四次挥手)
    - [为什么要四次挥手？](#为什么要四次挥手)
    - [为何一定要等 2MSL ？](#为何一定要等-2msl-)
- [06 简述一下 ping 的原理？](#06-简述一下-ping-的原理)
- [07 什么是HTTP？](#07-什么是http)
  - [HTTP有哪些状态码？](#http有哪些状态码)
  - [HTTP与HTTPS有什么区别？](#http与https有什么区别)
  - [HTTP 1.0和HTTP 1.1的主要区别是什么?](#http-10和http-11的主要区别是什么)
  - [Cookie的作用是什么?和Session有什么区别？](#cookie的作用是什么和session有什么区别)
  - [URI和URL的区别是什么?](#uri和url的区别是什么)
  - [HTTP是不保存状态的协议，如何保存用户状态?](#http是不保存状态的协议如何保存用户状态)
  - [HTTP长连接，短连接区别？](#http长连接短连接区别)
- [08 IP 地址与 MAC 地址的区别](#08-ip-地址与-mac-地址的区别)
- [09 请求转发和重定向的区别](#09-请求转发和重定向的区别)
- [10 在浏览器中输入 URL 地址到显示主页的过程，整个过程会使用哪些协议](#10-在浏览器中输入-url-地址到显示主页的过程整个过程会使用哪些协议)

## 01 简述一下计算机网络体系结构

计算机网络体中有OSI网络分层模型、TCP/IP网络分层模型和五层协议参考模型，其中：

* **OSI模型（7层）**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。（复杂不适用）
* **TCP/IP模型（4层）**：网络接口层、 网际层、运输层、 应用层。（广泛应用）
* **五层协议模型（5层）**：物理层、数据链路层、网络层、运输层、 应用层。（学习参考）

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613091951851.png" width="600px"/>
</div>

TCP/IP协议簇如下：
<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613091818566.jpg" width="550px"/>
</div>
## 02 如果设计一个聊天系统，应该用 TCP 还是 UDP？为什么？

TCP 与UDP的区别主要有：

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" width="850px"/>
</div>

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。UDP是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。（可靠，面向连接，时延大，适用于大文件）
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接（送数据之前必须先建立连接，数据传送结束后要释放连接）的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。（不可靠，无连接，时延小，适用于小文件）

现在的移动端IM、推送系统，既面对移动互联网的不确定性，又面对智能终端频繁的系统休眠、网络切换，还要考虑服务端的承载成本，对于在线服务而言UDP是比TCP更适合的方式。但是由于数据完整性、安全性的需要，又不应完全放弃TCP的可靠与安全。

所以，个人认为，更恰当的方式应该是：两种通信协议同时使用，各有侧重。UDP用于保持大量终端的在线与控制，应用与业务则通过TCP去实现。事实上，这个也是即时通讯巨头[QQ所采用的方式](https://www.zhihu.com/question/20292749)。

早期的时候，QQ还是主要使用TCP协议，而后来QQ包含了文本、语音、图片、视频等等消息类型，传统的文本信息显然不是重头戏了，因此实际中QQ使用的协议包含了UDP、TCP、HTTP这三种。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613094102396.png" width="800px"/>
</div>
## 03 TCP 如何保证传输可靠性?

对于可靠性，TCP 通过以下方式进行保证：

1. 应用数据被分割成 TCP 认为最适合发送的数据块。 
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 
4. TCP 的接收端会丢弃重复的数据。 
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的**滑动窗口协议**。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 

## 04 什么是 TCP 滑动窗口？

滑动窗口协议，是传输层进行流量控制的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。将窗口字段设置为 0，则发送方不能发送数据。

TCP 的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。

## 05 TCP 三次握手和四次挥手

### 三次握手

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613100407721.jpg" width="600px"/>
</div>

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，其同步位SYN=1，选择一个初始的序号 seq = x(随机)。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，确认值ACK=1，确认号为ack=x+1，同时也选择一个初始的序号seq=y(随机)。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为ack = y+1，序号为seq = x+1。
- B 收到 A 的确认后，连接建立。

> ACK 在连接建立之后都为 1。

简化一下三次握手的流程：

* 第一次握手：客户端—> 发送带有 SYN标志的数据包—> 服务端
* 第二次握手：服务端—> 发送带有 SYN/ACK 标志的数据包—> 客户端
* 第三次握手：客户端—> 发送带有 ACK 标志的数据包—> 服务端

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：客户端什么都不能确认；服务端确认了对方发送正常，自己接收正常；

第二次握手：客户端确认自己发送、接收正常，对方发送、接收正常；服务端确认对方发送正常，自己接收正常；

第三次握手：Client 确认了自己发送、接收正常，对方发送、接收正常；Server 确认了自己发送、接收正常，对方发送、接收正常。

所以三次握手就能确认双发收发功能都正常，缺一不可。

#### 第2次握手传回了ACK，为什么也传回了SYN？

接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”

>  SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

#### 为什么要三次握手？两次握手不行吗？

第三次握手是为了防止**SYN泛洪攻击**，**防止已失效的连接请求到达服务器**，让服务器错误打开连接。

* SYN泛洪攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而服务器返回ACK后，该攻击者就不对其进行再确认，那么这个TCP连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，就会重复发送ACK给攻击者。这样会浪费服务器的资源。如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。

对于SYN泛洪攻击的防范，优化主机系统设置是常用的手段。如降低SYN timeout时间，使得主机尽快释放半连接的占用；又比如采用SYN cookie设置，如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文。此外合理地采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击。

### 四次挥手

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613100116244.png" width="600px"/>
</div>

假设 A 为客户端，B 为服务器端。

- A 发送连接释放报文，FIN=1，用来关闭客户端到服务器的数据传送。
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，再发送连接释放报文，FIN=1。
- A 收到后发回 ACK 报文确认，并将确认序号设置为收到序号加1，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

> 和 SYN 一样，一个 FIN 不懈怠数据，只占用一个序号。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

#### 为什么要四次挥手？

#### 为何一定要等 2MSL ？

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

一定要等 2MSL 有两个理由：

- 确保最后一个确认报文能够到达。如果服务端没收到 客户端发送来的确认报文，那么就会重新发送连接释放请求报文（FIN+ACK），客户端等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了防止已经失效的请求报文段出现在本连接中，确保所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## 06 简述一下 ping 的原理？

ping 是基于 ICMP 协议工作的。**ICMP**全称**Internet Control Message Protocol**，就是**互联网控制报文协议**。这里面的关键词是“控制”，那具体是怎么控制的呢？ 网络包在异常负责的网络环境中传输时，会遇到各种问题，当遇到问题时，要传出消息，报告情况，这样才能调整传输策略。

ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。如下图：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613105210712.png" width="800px"/>
</div>

ICMP 报文有很多的类型，不同的类型有不同的代码。**最常用的类型是主动请求为 8，主动请求的应答为 0**。

常用的**ping 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议。**

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210613105502601.png" width="800px"/>
</div>

> 可参考[ICMP与ping：投石问路的侦察兵](https://time.geekbang.org/column/article/8445)一文。

## 07 什么是HTTP？

HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，它是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

主要特点如下：

- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

- 数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。

- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

  > 主要指的是不使用 Keep-Alive 机制的情况下。

- 无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

  > 无状态，所以更容易做服务的扩容，支撑更大的访问量。

- 支持 B/S 及 C/S 模式。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201117213251155.png" width="800px"/>
</div>

### HTTP有哪些状态码？

- 1×× : 请求处理中，请求已被接受，正在处理
- 2×× : 请求成功，请求被成功处理
  - 200 OK // 客户端请求成功
- 3×× : 重定向，要完成请求必须进行进一步处理
  - 301 Moved Permanently // 永久重定向,使用域名跳转
  - 302 Found // 临时重定向，未登陆的用户访问用户中心重定向到登录页面
- 4×× : 客户端错误，请求不合法
  - 400 Bad Request // 客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
  - 403 Forbidden // 服务器收到请求，但是拒绝提供服务
  - 404 Not Found // 请求资源不存在，eg：输入了错误的 URL
- 5×× : 服务器端错误，服务器不能处理合法请求
  - 500 Internal Server Error // 服务器发生不可预期的错误
  - 503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

### HTTP与HTTPS有什么区别？

**端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

**安全性和资源消耗：** HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上（**HTTP + 加密 + 认证 + 完整性保护 = HTTPS** ）。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

### HTTP 1.0和HTTP 1.1的主要区别是什么?

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **长连接** : **在HTTP/1.0中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1起，默认使用长连接** ,默认开启Connection： keep-alive。 **HTTP/1.1的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
1. **错误状态响应码** :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
1. **缓存处理** :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
1. **带宽优化及网络连接的使用** :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

### Cookie的作用是什么?和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### URI和URL的区别是什么?

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### HTTP是不保存状态的协议，如何保存用户状态?

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。

### HTTP长连接，短连接区别？

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。** 

## 08 IP 地址与 MAC 地址的区别

> 可查看[MAC地址和IP地址的区别与联系（计算机网络篇）](https://blog.csdn.net/yang_best/article/details/41643589)一文

我们可以归纳出IP地址和MAC地址相同点是它们都唯一，不同的特点主要有：

　　1. 对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。

　　2. 长度不同。IP地址为32位，MAC地址为48位。

　　3. 分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。

        　　4. 寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。

## 09 请求转发和重定向的区别

**转发（Forward）**：是服务器请求资源，服务器直接访问目标资源地址的URL，读取并发送目标URL返回的内容到浏览器，这个过程浏览器是不知道，浏览器的地址栏还是原来的地址。 转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的也是自己的容器内的request，故转发页面和转发到的页面可以共享request里面的数据。

**重定向（Redirect）**：是服务器根据处理逻辑，返回一个302状态码和新请求地址，告诉浏览器重新去请求这个URL，这时浏览器的地址栏就会变成新的URL。也就是收重定向是发生在客户端的跳转，**其实是两次请求**，所以这个新地址可以重定向到新的的URL，并且两次请求的request是不共享的。

形象的解释，你去拖人办事：

* 重定向：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后，你就从A退了出来，自己乘车去了B局。

* 转发：你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，自己到后面办公室联系了B的人，让他们办好后，送了过来。

总结下来，**转发是服务器行为，重定向是客户端行为**。区别主要在于：

- 请求转发只能将请求转发给同一个WEB应用中的组件，而重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL。
- 重定向可以看见目标页面的URL，转发只能看见第一次访问的页面URL，以后的工作都是有服务器来做的。
- 请求转发调用者和被调用者之间共享相同的request对象和response对象，重定向调用者和被调用者属于两个独立访问请求和响应过程。
- 重定向跳转后必须加上return，要不然页面虽然跳转了，但是还会执行跳转后面的语句，转发是执行了跳转页面，下面的代码就不会在执行了。

**重定向常见应用 —— 短连接跳转**

* 例如给用户发送短信的时候，发送一个链接，当用户点击链接的时候，能够打开app，同时跳转到app的某一个页面。

## 10 在浏览器中输入 URL 地址到显示主页的过程，整个过程会使用哪些协议

> 打开一个网页，整个过程会使用哪些协议？具体可以参考下面这篇文章：[从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000013522717)

图解（图片来源：《图解HTTP》）：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021061311405344.png" width="600px"/>
</div>

总体来说分为以下几个过程:

1. DNS解析（过访问的域名找出其 IP 地址，递归搜索）
2. 通过IP向服务器发起TCP连接（三次握手）
3. 浏览器向Web服务器发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面并显示
6. 关闭连接（4次挥手）
