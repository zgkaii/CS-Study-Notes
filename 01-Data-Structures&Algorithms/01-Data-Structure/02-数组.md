- [数组](#数组)
- [数组的缺点](#数组的缺点)
- [数组会被容器替代吗？](#数组会被容器替代吗)
- [为什么数组要从0而不是1开始编号？](#为什么数组要从0而不是1开始编号)
## 数组

**数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据**。

我们从下面几个关键词来理解数组：

* **线性表（Linear List）**：顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

  而与它相对立的概念是**非线性表**，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

* **连续的内存空间和相同类型的数据**：正是由于这两个限制，它才有“随机访问”的特性（根据下标随机访问数组元素）。拿一个长度为 10 的 int 类型的数组 int[] a = new int[10] 来举例，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。

<img src="https://img-blog.csdnimg.cn/20210420193138914.png" style="zoom:80%;" />

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```java
a[i]_address = base_address + i * data_type_size
```

其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。

如果对与一个 `m * n` 的数组，`a [ i ][ j ] (i < m,j < n)`，它的内存地址为：

```
a[i][j]_address = base_address + ( i * n + j) * data_type_size
```

这里要特别纠正一个“错误”。在面试的时候，大家常常会被问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。

实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，**数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**。

## 数组的缺点

数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。在最坏的情况下，插入和删除的时间复杂度都为O(n)。

比如说删除操作，要删除第 k 个位置的数据，为了内存的连续性，需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？

数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。

![](https://img-blog.csdnimg.cn/20210420193954176.png)

为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

其实这种的思想和JVM中标记清除垃圾回收算法的思想如出一辙。**这里也是是数据结构与算法的魅力所在，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的**。

## 数组会被容器替代吗？

针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？

这里以Java的ArrayList为例，ArrayList 最大的优势就是**可以将很多数组操作的细节封装起来**，比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是**支持动态扩容**。不过，需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好**在创建 ArrayList 的时候事先指定数据大小**。

比如我们要从数据库中取出 10000 条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。

```java
ArrayList<User> users = new ArrayList(10000);
for (int i = 0; i < 10000; ++i) {
  users.add(xxx);
}
```

当然，这并不意味着数组就一无是处，需要视情况而定：

* ArrayList 无法存储基本类型。比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
* 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，可以直接使用数组。
* 当要表示多维数组时，用数组更加直观。比如`Object[][]`，而用容器的话就是`ArrayList<ArrayList> array`。

## 为什么数组要从0而不是1开始编号？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

```java
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：

```java
a[k]_address = base_address + (k-1)*type_size
```

对比两个公式，不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。