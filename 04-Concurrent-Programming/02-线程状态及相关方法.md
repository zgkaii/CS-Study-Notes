<!-- MarkdownTOC -->
- [1 线程状态](#1-线程状态)
- [2 Thread类常用方法](#2-thread类常用方法)
  - [2.1 start()与run()](#21-start与run)
  - [2.2 sleep()与yield()](#22-sleep与yield)
    - [2.2.1 sleep()](#221-sleep)
    - [2.2.2 yield()](#222-yield)
  - [2.3 join()](#23-join)
  - [2.4 interrupt()](#24-interrupt)
    - [2.4.1 判断线程是否被中断](#241-判断线程是否被中断)
    - [2.4.2 如何中断线程](#242-如何中断线程)
- [3 Object类中常见方法](#3-object类中常见方法)
  - [3.1 wait() 与 notify()/notifyAll()](#31-wait-与-notifynotifyall)
  - [3.2 源码简析](#32-源码简析)
  - [3.3 等待/通知机制](#33-等待通知机制)
  - [3.4 生产者/消费者模式](#34-生产者消费者模式)
- [4 LockSupport类中常用方法](#4-locksupport类中常用方法)
  - [4.1 park与unpark](#41-park与unpark)
- [参考资料](#参考资料)

<!-- /MarkdownTOC -->

# 1 线程状态

Java线程在运行的生命周期中可能处于如下6种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态。

| 线程状态      | 说明                                                                                       |
| :------------ | ------------------------------------------------------------------------------------------ |
| NEW           | 初始状态，线程刚被创建，但是并未启动（还未调用start方法）。                                |
| RUNNABLE      | 运行状态，JAVA线程将操作系统中的就绪（READY）和运行（RUNNING）两种状态笼统地称为“运行中”。 |
| BLOCKED       | 阻塞状态，表示线程阻塞于锁。                                                               |
| WAITING       | 等待状态，表示该线程无限期等待另一个线程执行一个特别的动作。                               |
| TIMED_WAITING | 超时等待状态，不同于WAITING的是，它可以在指定时间自动返回。                                |
| TERMINATED    | 终止状态，表示当前状态已经执行完毕。                                                       |

线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20200929220833538.png" width="800px"/>
</div>

# 2 Thread类常用方法

## 2.1 start()与run()

`start()`启动一个新线程，在新的线程运行run方法中的代码。

```java
    public static void main(String[] args) {
        Thread thread = new Thread() {
            @Override
            public void run() {
                log.debug("running...");
            }
        };
        thread.setName("new thread");
        thread.start();
        log.debug("main thread");
    }

```

输出结果如下，可见`run()`方法里面内容的调用是异步的。

```java
14:06:43.754 [main] DEBUG com.kai.demo.basic.ThreadTest - main thread
14:06:43.754 [new thread] DEBUG com.kai.demo.basic.ThreadTest - running...
```

将上面代码的`thread.start()`改为 `thread.run()`，输出结果如下，可见 `run()`方法里面内容的调用是同步的。

```java
14:08:17.974 [main] DEBUG com.kai.demo.basic.ThreadTest - running...
14:08:17.979 [main] DEBUG com.kai.demo.basic.ThreadTest - main thread
```

------

**思考1：一个线程两次调用start()方法会出现什么情况？**

**解答**：Java线程是不允许一个线程两次调用`start()`方法的，第二次调用必然会抛出`IllegalThreadStateException`，这是一种运行时异常，多次调用start会被认为是编译错误。

在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。

------

**思考2：为什么start方法会调用run方法?为什么不能直接run()来实现创建线程？**

**解答**：start()用来启动一个线程，当调用start()方法时，系统才会开启一个线程，通过Thead类中start()方法（start()调用native start0()方法）来启动的线程处于就绪状态（可运行状态），此时并没有运行，一旦得到CPU时间片，就自动开始执行run()方法。此时不需要等待run()方法执行完也可以继续执行下面的代码，所以也由此看出run()方法并没有实现多线程。 

run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有多线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

## 2.2 sleep()与yield()

### 2.2.1 sleep()

调用`Thread.sleep(long millis)`会让当前线程从 RUNNING进入TIMED_WAITING状态（超时等待）。sleep()方法导致了程序暂停执行指定的时间，**让出CPU**给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，**线程不会释放对象锁**。

> Tips：sleep()中指定的时间是线程暂停运行的最短时间，不能保证该线程睡眠到时后就开始立刻执行。

```java
public class TimeWaitingTest extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            if ((i) % 5 == 0) {
                System.out.println("开启线程数为:" + i);
            }
            System.out.print(i);
            try {
                Thread.sleep(1000);
                System.out.print(" 线程睡眠1秒！\n");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        new TimeWaitingTest().start();
    }
}
```

运行结果：

```java
开启线程数为:0
0 线程睡眠1秒！
1 线程睡眠1秒！
2 线程睡眠1秒！
3 线程睡眠1秒！
4 线程睡眠1秒！
开启线程数为:5
5 线程睡眠1秒！
6 线程睡眠1秒！
7 线程睡眠1秒！
8 线程睡眠1秒！
9 线程睡眠1秒！
```

可见，线程睡眠到时间就会自动苏醒，并返回到Runnable（可运行）中的就绪状态。

> Tips：建议用 TimeUnit 的 `sleep()` 代替 Thread 的 `sleep()`来获得更好的可读性。

### 2.2.2 yield()

`Thread.yield()`，一定是当前线程调用此方法，当前线程放弃获取的 CPU 时间片，但不释放锁资源，由运行状态变为 就绪状态，让 OS 再次选择线程。

作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证 yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield() 不会导致阻塞。该方法与 sleep() 类似，只是不能由用户指定暂停多长时间。

调用`Thread.yield()`静态原生方法，也能暂停当前线程，其与`sleep()`有何异同呢？

- sleep(long)方法会**使线程转入超时等待(TIMED_WAITING)状态**，时间到了之后才会转入就绪状态。而yield()方法不能指定时间，不会将线程转入TIMED_WAITING状态，而是强制线程进入READY状态，从而让其它具有相同优先级的等待线程获取执行权。
- 使用sleep(long)方法**需要处理异常**`InterruptedException` ，而yield()不用处理异常。

sleep()与yield()的共同点就是：

- 两者**都不释放对象锁、释放CPU资源**。

## 2.3 join()

`t.join()/t.join(long millis)`，当前线程里调用其它线程对象 t 的 join 方法，**当前线程**进入`WAITING/TIMED_WAITING`状态， 但**当前线程不会释放已经持有的对象锁**，因为内部调用了 t.wait，所以会释放 t 这个对象上的同步锁。线程 t 执行完毕或 者 millis 时间到，当前线程进入就绪状态。其中，wait 操作对应的 notify 是由 jvm 底层的线程执行结束前触发的。

先来看**案例1**：

```java
public class JoinTest {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("[" + Thread.currentThread().getName() + "] running");
            }
        }, "child");
        
        thread.start();
        try {
            thread.join();
            if (thread.isAlive()) {
                System.out.println("[" + Thread.currentThread().getName() 
                                   + "] child thread has not finished");
            } else {
                System.out.println("[" + Thread.currentThread().getName() 
                                   + "] child thread has finished");
            }
            System.out.println("[" + Thread.currentThread().getName() 
                               + "] main thread has finished");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

执行结果：

```java
[child] running[main] child thread has finished
[main] main thread has finished
```

案例1中，main线程中调用了子线程对象thread的join()，main线程进入`WAITING`状态，而child线程中并没有调用`notify()`或者`notifyAll()`方法，main线程是如何被唤醒的呢？下面我们就来一探究竟。

查看源码可知，join()也是通过调用wait()方法实现的：

```java
    public final void join() throws InterruptedException {
        join(0);// 调用wait(0)方法，进入WAITING状态
    }

	public final synchronized void join(long millis) throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {// 判断线程是否存活
                wait(0);// 调用wait(0)方法，进入WAITING状态
            }
        } else {
            while (isAlive()) {// 判断线程是否存活
                long delay = millis - now;
                if (delay <= 0) {
                    break;// 跳出join()
                }
                wait(delay);// 调用wait(long)，进入TIMED_WAITING状态
                now = System.currentTimeMillis() - base;
            }
        }
    }
    public final synchronized void join(long millis, int nanos) throws InterruptedException {
		---Omit---
    }
```

查看`isAlive()`方法源码：

```java
	/**
     * Tests if this thread is alive. A thread is alive if it has
     * been started and has not yet died.
     * 测试线程是否存活（线程已经开始，还没有死亡的状态即为存活）。
     * @return  <code>true</code> if this thread is alive;
     *          <code>false</code> otherwise.
     */****
    public final native boolean isAlive();
```

可见，当main线程调用child线程的join方法时，其实就相当于调用child线程的wait方法，然后使main线程处于等待状态。通过debug，发现在child线程执行完后，系统会自然地调用Thread类中的`exit()`方法，查看源码：

```java
	 /**
     * This method is called by the system to give a Thread
     * a chance to clean up before it actually exits.
     * 此方法由系统调用，当该线程完全退出前给它一个机会去释放空间。
     */
    private void exit() {
        if (group != null) {                // 线程组在Thread初始化时创建，存有创建的子线程
            group.threadTerminated(this);   // 调用threadTerminated()方法
            group = null;
        }
        /* Aggressively null out all reference fields: see bug 4006245 */
        target = null;
        /* Speed the release of some of these resources */
        threadLocals = null;
        inheritableThreadLocals = null;
        inheritedAccessControlContext = null;
        blocker = null;
        uncaughtExceptionHandler = null;
    }
```

此时线程组中child子线程依然存在，因此会调用线程组的`threadTerminated()`方法。 查看`ThreadGroup.threadTerminated()`源码：

```java
     /**
     * Notifies the group that the thread {@code t} has terminated.
     * 通知线程组，t线程已经终止。
     */
    void threadTerminated(Thread t) {
        synchronized (this) {
            remove(t);										// 从线程组中删除此线程

            if (nthreads == 0) {							// 当线程组中线程数为0时
                notifyAll();								// 唤醒所有待定中的线程
            }
            if (daemon && (nthreads == 0) &&
                (nUnstartedThreads == 0) && (ngroups == 0))
            {
                destroy();
            }
        }
    }
```

可见，正是通过此`threadTerminated`方法，将child线程从线程组中删除，释放占用的资源（锁），**唤醒等待的线程**。也就是说，在child线程执行结束后，等待状态的线程才被唤醒，并打印“main thread has finished”。

最后调用`threadTerminated()`的解释其实是==存疑==的。照理来讲，由于主线程的存在，线程组中线程数不会为0，更不会调用`notifyAll()`。

[stackoverflow](https://stackoverflow.com/questions/9866193/who-and-when-notify-the-thread-wait-when-thread-join-is-called)上关于此问题的回答有：

```java
The notify() for this is handled by the Thread subsystem. When the run() method finishes, the notify() is called on the Thread object.
```

也就是说，join()调用wait()之后，notify()由本机线程系统内的代码唤醒，当run()方法完成时，就会在Thread对象上调用notify()。

以[OpenJDK 8](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/thread.cpp)为例，我们来查看`/jdk8/hotspot/file/tip/src/share/vm/runtime/thread.cpp`，看是否有唤醒join()的方法：

```cpp
void JavaThread::run() {
  ...  
  // We call another function to do the rest so we are sure that the stack addresses used
  // from there will be lower than the stack base just computed
  thread_main_inner();
}

void JavaThread::thread_main_inner() {
  assert(JavaThread::current() == this, "sanity check");
  assert(this->threadObj() != NULL, "just checking");

  // Execute thread entry point unless this thread has a pending exception
  // or has been stopped before starting.
  // Note: Due to JVM_StopThread we can have pending exceptions already!
  if (!this->has_pending_exception() &&
      !java_lang_Thread::is_stillborn(this->threadObj())) {
    HandleMark hm(this);
    this->entry_point()(this, this);
  }

  DTRACE_THREAD_PROBE(stop, this);

  this->exit(false);
  delete this;
}

void JavaThread::exit(bool destroy_vm, ExitType exit_type) {
  ...
  // Notify waiters on thread object. This has to be done after exit() is called
  // on the thread (if the thread is the last thread in a daemon ThreadGroup the
  // group should have the destroyed bit set before waiters are notified).
  ensure_join(this);
  ...
}

static void ensure_join(JavaThread* thread) {
  // We do not need to grap the Threads_lock, since we are operating on ourself.
  Handle threadObj(thread, thread->threadObj());
  assert(threadObj.not_null(), "java thread object must exist");
  ObjectLocker lock(threadObj, thread);
  // Ignore pending exception (ThreadDeath), since we are exiting anyway
  thread->clear_pending_exception();
  // Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.
  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);
    
  // Clear the native thread instance - this makes isAlive return false and allows the join()
  // to complete once we've done the notify_all below
  java_lang_Thread::set_thread(threadObj(), NULL);
  lock.notify_all(thread);
    
  // Ignore pending exception (ThreadDeath), since we are exiting anyway
  thread->clear_pending_exception();
}
```

可见，thread.cpp中是通过`lock.notify_all(thread)`唤醒join()线程的。

**也就是说，当main线程中调用child线程的join()方法（相当于wait(0)方法）时，main线程不会释放已持有的锁，只是释放CPU资源进入WAITING状态，child线程运行；当child线程执行结束后，由thread.cpp中的`notify_all()`唤醒main线程，main线程获取CPU资源后继续执行**。

捋清这层逻辑后，我们再来看**案例2**：

```java
public class JoinTest {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("[" + Thread.currentThread().getName() + "] begins");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("[" + Thread.currentThread().getName() + "] ends");
            }
        }, "child");
        
        thread.start();// 启动child线程
        try {
            thread.join(1000);
            if (thread.isAlive()) {
                System.out.println("[" + Thread.currentThread().getName() 
                                   + "] child thread has not finished");
            } else {
                System.out.println("[" + Thread.currentThread().getName() + "] child thread has finished");
            }
            System.out.println("Join Success");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

执行结果：

```java
[child] begins
[main] child thread has not finished
Join Success
[child] ends
```

案例2中，main线程中开启了一个child线程，child线程中启动成功调用`Thread.sleep(5000)`，child线程进入TIMED_WAITING状态；之后main线程再调用`thread.join(1000)`，也进入TIMED_WAITING状态。与案例1不同的是，child线程与main线程都处于TIMED_WAITING状态，而且child线程在TIMED_WAITING状态保持的时间更长。照理之前的分析，只有等child线程执行完后，由thread.cpp中的`lock.notify_all()`唤醒main线程。那么结果应该如下：

```java
[child] begins
[child] ends
[main] child thread has finished
Join Success
```

==为什么实际输出结果不是这样呢==？其实问题关键于在join()方法上。

再来看看join调用wait方法的源码：

```java
        if (millis == 0) {
            while (isAlive()) {// 判断线程是否存活
                wait(0);// 调用wait(0)方法，进入WAITING状态
            }
        } else {
            while (isAlive()) {// 判断线程是否存活
                long delay = millis - now;
                if (delay <= 0) {
                    break;// 跳出join()
                }
                wait(delay);// 调用wait(long),进入TIMED_WAITING状态
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

可见，只要`while()`中判断调用join方法的对象保持存活状态（True），就可能会**循环调用**`wait(0)/wait(long)`方法。

为什么要设计循环调用wait呢？

实际上，线程是可能没有接收通知、中断或超时的情况下被唤醒，这就是所谓的**假唤醒**。虽然这种情况在实践中很少发生，但应用程序必须通过测试线程被唤醒的条件来防止这种情况发生。也就是说，系统不一定在子线程结束后才调用`notifyAll()`。

案例1中进入`while (isAlive()){wait(0);}`循环。当主线程执行到`thread.wait(0)`之后，主线程并不会让出锁，代码不再继续往后运行，while()不再进行循环。主线程的程序计数器记录当前线程执行代码的行数，系统调用`notifyAll()`之后，主线程进入该对象的锁池，竞争该对象锁。拿到对象锁之后，继续从刚刚`wait(0)`之后的代码执行，即继续执行while循环，子线程是否存活。如果不满足条件，就会继续执行循环，直到下一次`notifyAll()`调用。

在案例2中，当进入while循环时，`delay>0`，调用的`wait(delay)`。主线程让出当前的thread对象的锁，代码不再继续往后运行，while()不再进行循环。与案例1不同的是，在系统调用`notifyAll()`之后，由于子线程仍处于TIMED_WAITING状态，子线程仍存活，会继续执行while循环。当第二次进入循环时，由于时间设定，`delay<0`，直接跳出循环，打印`child thread has not finished`。

## 2.4 interrupt()

线程的`thread.interrupt()`方法用于中断线程，他会设置该线程的中断状态位为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。

### 2.4.1 判断线程是否被中断

```java
    // 测试当前线程是否已经中断。掉用后线程的中断状态由该方法清除。也就是说，连续两次调用判断中断线程，则第二次调用将返回false。
	public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
	// 测试线程是否已经中断。线程的中断状态不受该方法的影响。也就是说，连续两次调用判断中断线程，则第二次仍返回true。
    public boolean isInterrupted() {
        return isInterrupted(false);
    }
```

### 2.4.2 如何中断线程

interrupt()的作用是即是中断本线程。查看源码：

```java
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }

	private native void interrupt0();
```

本线程中断自己是被允许的，其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。

* **中断非阻塞状态线程**

打断正常运行的线程, 线程并不会暂停。可以调用方法`Thread.currentThread().isInterrupted()`的值是来手动停止线程。

```java
public class InterruptTest {
    public static void main(String[] args) throws InterruptedException {
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                while (!Thread.currentThread().isInterrupted()) {
                    System.out.println("[" + Thread.currentThread().getName() + "] running");
                    long time = System.currentTimeMillis();
                    // 使用while循环模拟 sleep
                    while ((System.currentTimeMillis() - time < 1000)) {
                    }
                }
            }
        }, "child");

        t2.start();
        Thread.sleep(3000);
        System.out.println("[" + Thread.currentThread().getName() + "] child是否被打断？" + t2.isInterrupted());
        System.out.println("Asking thread to stop...");
        t2.interrupt();
        System.out.println("[" + Thread.currentThread().getName() + "] child是否被打断？" + t2.isInterrupted());
    }
}
```

执行结果：

```java
[child] running
[child] running
[child] running
[child] running
[main] child是否被打断？false
Asking thread to stop...
[main] child是否被打断？true
```

* **中断阻塞状态线程**

`wait()/wait(long)/wait(long, int)，join()/join(long)/join(long, int)，sleep(long)/sleep(long, int)`方法都会让线程进入阻塞状态。若线程在阻塞状态时调用了interrupt()方法打断，那么它的“**中断状态”会被清除**，并且会收到一个`InterruptedException`异常。

以下面代码为例，线程通过sleep(long)进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”；同时，会产生一个`InterruptedException`的异常。

```java
public class InterruptTest {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("[" + Thread.currentThread().getName() + "] start");
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
					System.out.println("InterruptedException --- [" + Thread.currentThread().getName() + "] Interrupted");
                }
            }
        }, "child");

        t1.start();
        Thread.sleep(100);
        System.out.println("[" + Thread.currentThread().getName() + "] child是否被打断？" + t1.isInterrupted());
        t1.interrupt();
        System.out.println("[" + Thread.currentThread().getName() + "] child是否被打断？" + t1.isInterrupted());
        Thread.sleep(100);
        System.out.println("[" + Thread.currentThread().getName() + "] child是否被打断？" + t1.isInterrupted());
    }
}
```

执行结果：

```java
[child] start
[main] child是否被打断？false
[main] child是否被打断？true
InterruptedException --- [child] Interrupted
[main] child是否被打断？false
```

在看了上面几个案例后，极容易产生这样一种误解——认为调用interrupt方法会中断线程。==这种想法是错误的==。

其实，**Java的中断是一种协作机制**。调用线程对象的interrupt方法并不一定就中断了正在运行的线程，它只是要求线程自己在合适的时机中断自己。每个线程都有一个boolean的中断状态（这个状态不在Thread的属性上），interrupt方法仅仅只是将该状态置为true。比如对正常运行的线程调用interrupt()并不能终止它，**只是改变了interrupt标示符**。

一般说来，如果一个方法声明抛出InterruptedException，表示该方法是可中断的，比如wait/sleep/join。也就是说可中断方法会对interrupt调用做出响应（例如sleep响应interrupt的操作包括清除中断状态，抛出InterruptedException），异常都是由可中断方法自己抛出来的，并不是直接由interrupt方法直接引起的。

**正是如此，Object.wait()/Thread.sleep()/Thread.join()方法，才会不断的轮询监听 interrupted 标志位，发现其为true后，会停止阻塞并抛出 InterruptedException异常**。

也就是说，`Thread.interrupt()`方法不会真正地中断一个正在运行的线程。它主要用于设置线程的中断标示位，在线程受到阻塞的地方（如Thread.sleep()、Thread.join()、Object.wait()检查到线程为“中断状态”后）抛出一个InterruptedException异常，并且“中断状态”也将被清除，这样线程就得以退出阻塞的状态。如果线程没有被阻塞，这时调用 interrupt() 将不起作用，直到执行到 wait/sleep/join 时，才马上会抛出InterruptedException。

# 3 Object类中常见方法

## 3.1 wait() 与 notify()/notifyAll()

当前线程中调用`Object.wait()`方法时，当前线程就会进入等待状态，**会释放CPU资源和同步锁**（类锁和对象锁）进入等待队列。直到其他线程调用此对象的`notify()`方法或 `notifyAll()`方法唤醒或者 `wait(long timeout) timeout `时间到自动唤醒，线程恢复到 wait 时的状态。

**wait是Object类中的方法**，方法内部很简单，使用native方法实现：

```java
	// 进入WAITING状态
	public final void wait() throws InterruptedException {
        wait(0);
    }
	// 进入TIMED_WAITING状态
	public final native void wait(long timeout) throws InterruptedException;

    // 进入TIMED_WAITING状态
    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }
        if (nanos > 0) {
            timeout++;
        }
        wait(timeout);
    }    
```

wait()方法只能在**同步方法**中调用。如果当前线程不是锁的持有者，该方法抛出一个`IllegalMonitorStateException`异常。

如果当前线程在等待之前或在等待时被任何线程中断，则会抛出 `InterruptedException `异常。

使用案例：

```java
public class WaitingTest {
    public static Object obj = new Object();

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    synchronized (obj) {
                        try {
                            System.out.println(Thread.currentThread().getName() 
                                               + "=== 调用wait方法，进入WAITING状态，释放锁对象");
                            obj.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() 
                                           + "=== 从WAITING状态醒来，获取到锁对象，继续执行");
                    }
                }
            }
        }, "线程A").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) { //每隔3秒 唤醒一次
                    try {
                        System.out.println(Thread.currentThread().getName() 
                                           + "‐‐‐ 等待3秒钟");
                        Thread.sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (obj) {
                        System.out.println(Thread.currentThread().getName() 
                                           + "‐‐‐ 获取到锁对象, 调用notify方法，释放锁对象");
                        obj.notify();
                    }
                }
            }
        }, "线程B").start();
    }
}
```

执行结果：

```java
线程A=== 调用wait方法，进入WAITING状态，释放锁对象
线程B‐‐‐ 等待3秒钟
线程B‐‐‐ 获取到锁对象, 调用notify方法，释放锁对象
线程B‐‐‐ 等待3秒钟
线程A=== 从WAITING状态醒来，获取到锁对象，继续执行
... ... 
```

通过上述案例我们会发现，线程A在调用了某个对象的 `Object.wait `方法后，需要等待线程B调用此对象的
`Object.notify()`方法将其唤醒。

## 3.2 源码简析

wait( )，notify( )，notifyAll( )都是Object基础类中的方法，所以在任何 Java 对象上都可以使用。

```java
public class Object {
    // 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法。
    public final void wait() throws InterruptedException {
        wait(0);
    }

    // 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或者已经过了指定的时间。
    public final native void wait(long timeout) throws InterruptedException;

    //  唤醒正在此对象监视器上等待的单个线程。
    public final native void notify();

    //  唤醒等待此对象监视器的所有线程。
    public final native void notifyAll();
}
```

[打开objectMonitor.cpp](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9deea71d83dd/src/share/vm/runtime/objectMonitor.cpp)，查看wait方法：

```c++
 	...
   // create a node to be put into the queue
   // Critically, after we reset() the event but prior to park(), we must check
   // for a pending interrupt.
   ObjectWaiter node(Self);		  		 // 将当前线程封装成ObjectWatier
   node.TState = ObjectWaiter::TS_WAIT ; // 状态改为等待状态
   Self->_ParkEvent->reset() ;
   OrderAccess::fence();          // ST into Event; membar ; LD interrupted-flag

   // Enter the waiting queue, which is a circular doubly linked list in this case
   // but it could be a priority queue or any data structure.
   // _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only
   // by the the owner of the monitor *except* in the case where park()
   // returns because of a timeout of interrupt.  Contention is exceptionally rare
   // so we use a simple spin-lock instead of a heavier-weight blocking lock.

   Thread::SpinAcquire (&_WaitSetLock, "WaitSet - add") ;// 自旋操作
   AddWaiter (&node) ;
   Thread::SpinRelease (&_WaitSetLock) ;				 // 添加到_WaitSet节点中
	...
```

查看AddWaiter()方法：

```c++
inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) {
  assert(node != NULL, "should not dequeue NULL node");
  assert(node->_prev == NULL, "node already in list");
  assert(node->_next == NULL, "node already in list");
  // put node at end of queue (circular doubly linked list)
  if (_WaitSet == NULL) {
    _WaitSet = node;
    node->_prev = node;
    node->_next = node;
  } else {
    ObjectWaiter* head = _WaitSet ; // 通过双向链表的方式，将ObjectWaiter对象添加到_WaitSet列表中
    ObjectWaiter* tail = head->_prev;
    assert(tail->_next == head, "invariant check");
    tail->_next = node;
    head->_prev = node;
    node->_next = head;
    node->_prev = tail;
  }
}
```

查看notify方法源码：

```c++
void ObjectMonitor::notify(TRAPS) {
  CHECK_OWNER();
  if (_WaitSet == NULL) {
     TEVENT (Empty-Notify) ;// _WaitSet=NULL表明没有等待状态的线程，直接返回。
     return ;
  }
  DTRACE_MONITOR_PROBE(notify, this, object(), THREAD);

  int Policy = Knob_MoveNotifyee ;

  Thread::SpinAcquire (&_WaitSetLock, "WaitSet - notify") ;
  ObjectWaiter * iterator = DequeueWaiter() ;// 获取一个ObjectWaiter对象
  if (iterator != NULL) {
      ...
     ObjectWaiter * List = _EntryList ;
     if (List != NULL) {
        assert (List->_prev == NULL, "invariant") ;
        assert (List->TState == ObjectWaiter::TS_ENTER, "invariant") ;
        assert (List != iterator, "invariant") ;
     }
	 // 根据不同状态采取不同策略，将从_WaitSet列表中移出来的ObjectWaiter对象加入到_EntryList列表中。
     if (Policy == 0) {       // prepend to EntryList
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
             List->_prev = iterator ;
             iterator->_next = List ;
             iterator->_prev = NULL ;
             _EntryList = iterator ;
        }
     } else
     if (Policy == 1) {...} else     // append to EntryList
	 if (Policy == 2) {...} else     // prepend to cxq
	 if (Policy == 3) {				 // append to cxq
         ...     
     } else {
        ParkEvent * ev = iterator->_event ;
        iterator->TState = ObjectWaiter::TS_RUN ;
        OrderAccess::fence() ;		 // 被唤醒的线程又变成run状态。
        ev->unpark() ;
     }
}
```

查看notifyAll方法源码：

```c++
void ObjectMonitor::notifyAll(TRAPS) {
  CHECK_OWNER();
  ObjectWaiter* iterator;
  if (_WaitSet == NULL) {
      TEVENT (Empty-NotifyAll) ;// _WaitSet=NULL表明没有等待状态的线程，直接返回。
      return ;
  }
  DTRACE_MONITOR_PROBE(notifyAll, this, object(), THREAD);

  int Policy = Knob_MoveNotifyee ;
  int Tally = 0 ;
  Thread::SpinAcquire (&_WaitSetLock, "WaitSet - notifyall") ;

  for (;;) {
     iterator = DequeueWaiter () ;// 循环获取所以ObjectWaiter对象
	   ...
     ObjectWaiter * List = _EntryList ;
     if (List != NULL) {
        assert (List->_prev == NULL, "invariant") ;
        assert (List->TState == ObjectWaiter::TS_ENTER, "invariant") ;
        assert (List != iterator, "invariant") ;
     }
	 // 根据不同状态采取不同策略，将从_WaitSet列表中移出来的ObjectWaiter对象加入到_EntryList列表中。	
     if (Policy == 0) {       // prepend to EntryList
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
             List->_prev = iterator ;
             iterator->_next = List ;
             iterator->_prev = NULL ;
             _EntryList = iterator ;
        }
     } else
     if (Policy == 1) {      // append to EntryList
		...
     } else
     if (Policy == 2) {      // prepend to cxq
		...
     } else
     if (Policy == 3) {      // append to cxq
		...
     } else {
        ParkEvent * ev = iterator->_event ;
        iterator->TState = ObjectWaiter::TS_RUN ;// 被唤醒的线程又变成run状态。
        OrderAccess::fence() ;
        ev->unpark() ;
     }

      ...
```

可见，wait()与notify()/notifyAll()的实现都跟Monitor有很大关联。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201026000053726.png" width="500px"/>
</div>

* 当多线程访问一段同步代码块时，这些都线程会被被封装成一个个`ObjectWatier`对象，并被放入 `_EntryList`列表中，也就是被放到 Entry Set（入口区） 中等待获取锁。
* 如果该线程获取到了锁（acquire），线程就会成为当前锁的 Owner。
* 获取到锁的线程可也以通过调用 wait 方法将锁释放（release），然后该线程对象会被放入`_WaitSet`列表中，进入Wait Set （等待区）进行等待（阻塞BLOCKED）。
* 当获取到锁的对象调用`notify/notifyAll`方法唤醒等待区被阻塞的线程时，线程重新竞争锁。如果竞争锁成功，那么线程就进入RUNNABLE状态；如果竞争锁失败，这些线程会重新进入到Entry Set区再重新去竞争锁。

wait方法的使用对应上图的第3步，也就是说，**调用`wait()`、`notify()`/`notifyAll()`方法的对象必须已经获取到锁**。

如何确保调用对象获取到锁呢？使用`sychronized`关键字呗！**所以说这些方法调用也必须发生在`sychronized`修饰的同步代码块内**。

## 3.3 等待/通知机制

**（1）什么是等待/通知机制**

等待/通知机制是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争（race）**，比如去竞争锁。但这并不是故事的全部，线程间也有协作机制。就好比我们在公司中与同事关系，可能存在在晋升时的竞争，但更多时候是一起合作以完成某些任务。

**wait/notify** 就是线程间的一种协作机制。

当一个线程调用wait()/wait(long)方法后，进入WAITING状态或者TIMED_WAITING状态（阻塞），并释放锁与CPU资源。只有其他获取到锁的线程执行完他们的指定代码过后，再通过notify()方法将其唤醒。 如果需要，也可以使用` notifyAll()`来唤醒所有的阻塞线程。

**（2）等待/通知使用方法**

等待/通知机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：

1. **wait**：线程不再活动，不再参与调度，**释放**它对锁的拥有权。它还要等着别的线程执行一个**特别的动作**，也即是“**通知（notify）**”在这个对象上等待的线程从WAITING状态中释放出来，重新进入到调度队列（ready queue）中。
2. **notify**：唤醒一个等待当前对象的锁的线程。唤醒在此对象监视器上等待的单个线程。
3. **notifyAll**：唤醒在此对象监视器上等待的所有线程。

>**注意**：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要**再次尝试去获取锁**（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。
>
>总结如下：
>
>- 如果能获取锁，线程就从 WAITING/TIMED_WAITING 状态转换为RUNNABLE 状态；
>- 否则，从 Wait Set 区出来，又进入 Entry Set区，线程就从 WAITING 状态又变成 BLOCKED 状态。

**（3）调用wait和notify方法需要注意的细节**

* wait方法与notify方法**必须要由同一个锁对象调用**。因为对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
* wait方法与notify方法是属于Object类的方法的。因为锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
* wait方法与notify方法**必须要在同步代码块或者是同步函数中使用**。因为必须要通过锁对象调用这2个方法。

下面就通过一个案例来进一步了解等待/通知机制：

```java
public class WaitAndNotify {
    static boolean flag = true;
    static Object lock = new Object();

    public static void main(String[] args) throws Exception {
        Thread waitThread = new Thread(new Wait(), "WaitThread");
        waitThread.start();
        TimeUnit.SECONDS.sleep(1);
        Thread notifyThread = new Thread(new Notify(), "NotifyThread");
        notifyThread.start();
    }

    static class Wait implements Runnable {
        @Override
        public void run() {
            // 加锁，拥有lock的Monitor
            synchronized (lock) {
                // 当条件不满足时，继续wait，同时释放了lock的锁
                while (flag) {
                    try {
                        System.out.println(Thread.currentThread().getName() 
                                           + " flag is true. wait @ " +
                                new SimpleDateFormat("HH:mm:ss").format(new Date()));
                        lock.wait();
                    } catch (InterruptedException e) {

                    }
                }
                // 当条件满足时，完成工作
                System.out.println(Thread.currentThread().getName() 
                                   + " flag is false. running @ " +
                        new SimpleDateFormat("HH:mm:ss").format(new Date()));
            }
        }
    }

    static class Notify implements Runnable {
        @Override
        public void run() {
            // 加锁，拥有lock的Monitor
            synchronized (lock) {
                // 获得lock的锁，然后进行通知
                System.out.println(Thread.currentThread().getName() 
                                   + " hold lock. notify @ " +
                        new SimpleDateFormat("HH:mm:ss").format(new Date()));
                lock.notifyAll();
                flag = false;
                SleepUtils.second(5);
            }
            // 再次加锁
            synchronized (lock) {
                System.out.println(Thread.currentThread().getName() 
                                   + " hold lock. again. sleep @ " +
                        new SimpleDateFormat("HH:mm:ss").format(new Date()));
                SleepUtils.second(5);
            }
        }
    }
}

class SleepUtils {
    public static final void second(long seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {

        }
    }
}
```

输出结果可能如下：

```java
WaitThread flag is true. wait @ 00:38:53
NotifyThread hold lock. notify @ 00:38:54
NotifyThread hold lock. again. sleep @ 00:38:59
WaitThread flag is false. running @ 00:39:04
```

也可能如下：

```java
WaitThread flag is true. wait @ 00:38:53
NotifyThread hold lock. notify @ 00:38:54
WaitThread flag is false. running @ 00:39:04
NotifyThread hold lock. again. sleep @ 00:38:59
```

之所以出现这类情况，在于调用notify()或notifyAll()方法调用后，waitThread是否成功获取到锁。竞争成功，则进入RUNNABLE状态；如果竞争失败，waitThread会重新进入到Entry Set区再重新去竞争锁。也就是说，**从wait()方法返回的前提是获得了调用对象的锁**。

从上述细节中可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。

下图描述了上述示例的过程：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021061801524476.png" width="650px"/>
</div>

## 3.4 生产者/消费者模式

从上面案例中，可以提炼出等待/通知的经典范式——生产者/消费者模式（**在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。**在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者）。

该范式主要分为两部分，分别针对生产者（通知方）和消费者（等待方）。

**消费者**遵循如下原则：

（1）获取对象的锁。

（2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。

（3）条件满足则执行对应的逻辑。

对应的伪代码如下。

```java
 synchronized (对象) {
     while (条件) {
         对象.wait();
     }
     对应的处理逻辑
 }
```

**生产者**遵循如下原则：

（1）获得对象的锁。

（2）改变条件。

（3）通知所有等待在对象上的线程。对应的伪代码如下。

对应的伪代码如下。

```java
 synchronized (对象) {
	改变的条件
    对象.notifyAll();//或者 对象.notify()
 }
```

**代码实例**——这里用到了 2 个队列：

* 同步队列：对应线程状态中的`RUNNABLE`，线程处于准备就绪，等着可以抢占资源。
* 等待队列：对应的线程状态中的 `WAITING`，也就是等待状态。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20200930135734439.png" width="400px"/>
</div>

首先建了一个简单的 `Product` 类，用来表示生产和消费的产品。

```java
public class Product {
    private String name;

    public Product(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

创建生产者类：

```java
public class Producer implements Runnable {
    private Queue<Product> queue;
    private int maxCapacity;

    public Producer(Queue<Product> queue, int maxCapacity) {
        this.queue = queue;
        this.maxCapacity = maxCapacity;
    }

    @Override
    public void run() {
        synchronized (queue) {
            while (queue.size() == maxCapacity) {
                try {
                    System.out.println("生产者" 
                                       + Thread.currentThread().getName() 
                                       + "Queue 已满，WAITING");
                    wait();
                    System.out.println("生产者" + Thread.currentThread().getName() 
                                       + "退出等待");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (queue.size() == 0) { //队列里的产品从无到有，需要通知在等待的消费者
                queue.notifyAll();
            }
            Integer i = new Random().nextInt(50);
            queue.offer(new Product("产品" + i.toString()));
            System.out.println("生产者" + Thread.currentThread().getName() 
                               + "生产了产品" + i.toString());
        }
    }
}
```

创建消费者类：

```java
public class Consumer implements Runnable {

    private Queue<Product> queue;
    private int maxCapacity;

    public Consumer(Queue queue, int maxCapacity) {
        this.queue = queue;
        this.maxCapacity = maxCapacity;
    }

    @Override
    public void run() {
        synchronized (queue) {
            while (queue.isEmpty()) {
                try {
                    System.out.println("消费者" 
                                       + Thread.currentThread().getName() 
                                       + "Queue已空，WAITING");
                    wait();
                    System.out.println("消费者" + Thread.currentThread().getName() 
                                       + "退出等待");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (queue.size() == maxCapacity) {
                queue.notifyAll();
            }

            Product product = queue.poll();
            System.out.println("消费者" + Thread.currentThread().getName() 
                               + "消费了" + product.getName());
        }
    }
}
```

开启多线程：

```java
public class TreadTest {
    public static void main(String[] args) {
        Queue<Product> queue = new ArrayDeque<>();
        for (int i = 0; i < 10; i++) {
            new Thread(new Producer((Queue<Product>) queue, 10)).start();
            new Thread(new Consumer((Queue) queue, 10)).start();
        }
    }
}
```

测试结果：

```shell
生产者Thread-0生产了产品35
消费者Thread-1消费了产品35
生产者Thread-2生产了产品43
消费者Thread-3消费了产品43
消费者Thread-5Queue已空，WAITING
生产者Thread-6生产了产品17
生产者Thread-8生产了产品39
消费者Thread-7消费了产品17
生产者Thread-10生产了产品17
生产者Thread-12生产了产品3
消费者Thread-13消费了产品39
生产者Thread-14生产了产品10
消费者Thread-17消费了产品17
生产者Thread-16生产了产品8
消费者Thread-19消费了产品3
生产者Thread-4生产了产品29
消费者Thread-9消费了产品10
消费者Thread-11消费了产品8
消费者Thread-15消费了产品29
生产者Thread-18生产了产品33
```

# 4 LockSupport类中常用方法

## 4.1 park与unpark

`LockSupport`类是Java6(JSR166-JUC)引入的一个类，用来**创建锁和其他同步工具类的基本线程阻塞原语**。LockSupport 类似于 Thread 类的静态方法，专门处理（执行这个代码的）本线程的。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210609100241585.png" width="700px"/>
</div>
使用LockSupport类中的park()和unpark()方法也可以实现线程的阻塞与唤醒。Park有停车的意思，假设线程为车辆，那么park方法代表着停车，而unpark方法则是指车辆启动离开。

```java
    public static void park() {
        UNSAFE.park(false, 0L);

    public static void park(Object blocker) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(false, 0L);
        setBlocker(t, null);
    }

    public static void unpark(Thread thread) {
        if (thread != null)
            UNSAFE.unpark(thread);
    }
```

归根到底还是调用了UNSAFE类中的函数：

```java
    public native void unpark(Object var1);

    public native void park(boolean var1, long var2);
```

与 wait/notify 相比，park/unpark 方法更贴近操作系统层面的阻塞与唤醒线程，**并不需要获取对象的监视器**。

park/unpark 原理可参考[LockSupport中的park与unpark原理](https://blog.csdn.net/weixin_39687783/article/details/85058686)一文。

需要明白的是，每个java线程都有一个Parker对象，主要三部分组成 _counter、 _cond和 _mutex。Parker类是这样定义的：

```C++
class Parker : public os::PlatformParker {
private:
  //表示许可
  volatile int _counter ;
  ...
public:
  Parker() : PlatformParker() {
    //初始化_counter
    _counter       = 0 ; 
...
public:
  void park(bool isAbsolute, jlong time);
  void unpark();
  ...
}
class PlatformParker : public CHeapObj<mtInternal> {
  protected:
    pthread_mutex_t _mutex [1] ;
    pthread_cond_t  _cond  [1] ;
    ...
}
```

Parker类里的_counter字段，就是用来记录所谓的“**许可**”的。**当调用park时，这个变量置为了0；当调用unpark时，这个变量置为1**。

park和unpark的灵活之处在于，**unpark函数可以先于park调用**。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。

**先调用park再调用upark时**：

1.先调用park

（1）当前线程调用 Unsafe.park() 方法，检查_counter情况（为0），获得 _mutex 互斥锁。

（2）mutex对象有个等待队列 _cond，线程进入等待队列中阻塞。

（4）设置 _counter = 0。

2.再调用upark

（1）调用 Unsafe.unpark方法，设置 _counter 为 1

（2）唤醒 _cond 条件变量中的 阻塞线程，线程恢复运行。

（3）设置 _counter 为 0

**先调用upark再调用park时**：

（1）调用 Unsafe.unpark方法，设置 _counter 为 1。

（2）当前线程调用 Unsafe.park() 方法。

（3）检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行。

（4）设置 _counter 为 0。

特别注意的是，**LockSupport是不可重入**的，如果一个线程连续2次调用LockSupport.park()，那么该线程一定会一直阻塞下去。

```java
    public static void main(String[] args) throws Exception {
        Thread thread = Thread.currentThread();

        LockSupport.unpark(thread);
        System.out.println("线程处于运行状态");
        LockSupport.park();
        System.out.println("线程处于阻塞状态");
        LockSupport.park();
        System.out.println("线程处于阻塞状态");
        LockSupport.unpark(thread);
        System.out.println("线程处于运行状态？？？");
    }
```

运行结果如下：

```java
线程处于运行状态
线程处于阻塞状态
```

可见，在第二次调用park后，线程无法再获取许可出现了死锁。

------

**思考**：为什么 unpark 需要加一个线程作为参数？

**解答**：因为一个park的线程，无法自己唤醒自己，所以需要其他线程来唤醒。

# 参考资料

* 《JAVA并发编程的艺术》
* [Java精通并发-透过openjdk源码分析wait与notify方法的本地实现](https://www.cnblogs.com/webor2006/p/11443392.html)
* [LockSupport中的park与unpark原理](https://blog.csdn.net/weixin_39687783/article/details/85058686)

* [Java Thread的join() 之刨根问底](https://juejin.im/post/6844903624842149895)
