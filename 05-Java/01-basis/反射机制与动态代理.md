<!-- MarkdownTOC -->
- [反射机制](#反射机制)
  - [什么是反射](#什么是反射)
  - [如何使用反射](#如何使用反射)
    - [获取类的Class对象](#获取类的class对象)
    - [构造类的实例化对象](#构造类的实例化对象)
    - [获取类中所有信息](#获取类中所有信息)
  - [反射的应用场景](#反射的应用场景)
    - [Spring 的 IOC 容器](#spring-的-ioc-容器)
    - [反射 + 抽象工厂模式](#反射--抽象工厂模式)
    - [JDBC 加载数据库驱动类](#jdbc-加载数据库驱动类)
- [动态代理](#动态代理)
  - [静态代理](#静态代理)
  - [JDK动态代理](#jdk动态代理)
    - [InvocationHandler 接口](#invocationhandler-接口)
    - [Proxy 类](#proxy-类)
    - [动态代理实例](#动态代理实例)
  - [CGLIB 动态代理](#cglib-动态代理)
- [总结](#总结)
- [参考资料](#参考资料)


<!-- /MarkdownTOC -->

# 反射机制

## 什么是反射

**编译期**指把源码编译成计算机可以执行的文件的过程（在 Java 中也就是Java 代码编译成 Class 文件的过程）；而**运行期**是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。

Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，**反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力，它能够让程序在运行时获取自身的一些信息。**在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

为什么会有反射呢？这里举一个例子，假如我们用Hash Map存储键值对：

* 如果在不使用反射时，构造对象使用 new 方式实现，这种方式在**编译期**就可以把对象的类型确定下来。那么代码为：

  ```java
  Map<Integer, Integer> map = new LinkedHashMap<>();
  ```

* 如果需求发生变更，需要构造另一个Map对象，则需要修改源码，非常不优雅。所以我们通过使用`开关`，在程序运行时判断需要构造哪一个对象，在运行时可以**变更开关**来实例化不同的数据结构。例如：

  ```java
  public Map<Integer, Integer> getMap(String param) {
      Map<Integer, Integer> map = null;
      if (param.equals("HashMap")) {
          map = new HashMap<>();
      } else if (param.equals("LinkedHashMap")) {
          map = new LinkedHashMap<>();
      } else if (param.equals("WeakHashMap")) {
          map = new WeakHashMap<>();
      }
      return map;
  }
  ```

* 如果还有其它扩展的类有可能被使用，就会创建出**非常多的分支**，且在编码时不知道有什么其他的类被使用到，假如日后`Map`接口下多了一个集合类是`xxxHashMap`，还得创建很多分支，太麻烦了。因此引出了反射：可以在`运行时`才确定使用哪一个数据类，在切换类时，无需重新修改源码、编译程序。

  ```java
  public Map<Integer, Integer> getMap(String className) {
      Class clazz = Class.forName(className);
      Consructor con = clazz.getConstructor();
      return (Map<Integer, Integer>) con.newInstance();
  }
  ```

从上面例子中可以看出：

* 反射的思想：**在程序运行过程中确定和解析数据类的类型**。
* 反射的作用：对于在`编译期`无法确定使用哪个数据类的场景，通过`反射`可以在程序运行时**构造出不同的数据类实例**。

## 如何使用反射

Java反射主要有四部分组成：

* `Class`：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的**所有信息**。
* `Filed`：描述一个类的**属性**，内部包含了该属性的所有信息，例如**数据类型，属性名，访问修饰符**······
* `Constructor`：描述一个类的**构造方法**，内部包含了构造方法的所有信息，例如**参数类型，参数名字，访问修饰符**······
* `Method`：描述一个类的**所有方法**（包括抽象方法），内部包含了该方法的所有信息，与`Constructor`类似，不同之处是 Method 拥有**返回值类型**信息，因为构造方法是没有返回值的。

```java
public class Student {
    public String name;
    public int age;
    /**
     * 生日只有自己知道
     */
    public Date birthday;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void getInfo() {
        System.out.println("Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}');
    }
}
```

反射中的用法有非常非常多，常见的功能有以下这几个：

- 在运行时获取一个类的 **Class 对象**；
- 在运行时构造一个类的 **实例化对象**；
- 在运行时获取一个类的所有信息：**变量、方法、构造器、注解**。

### 获取类的Class对象

在 Java 中，每一个类都会有专属于自己的 Class 对象，当我们编写完`.java`文件后，使用`javac`编译后，就会产生一个字节码文件`.class`，在字节码文件中包含类的所有信息，如`属性`，`构造方法`，`方法`······当字节码文件被装载进虚拟机执行时，会在内存中生成 Class 对象，它包含了该类内部的所有信息，在程序运行时可以获取这些信息。

获取Class对象有三种方法：

* `类名.class`：只能在编译前已经声明了该类类型才能获取Class对象。

```java
Class clazz = Student.class;
```

- `实例.getClass()`：通过实例化对象获取该实例的 Class 对象。

```java
Student student = new Student();
Class clazz = student.getClass();
```

- `Class.forName(className)`：通过类的**全限定名**获取该类的 Class 对象。

```java
Class clazz = Class.forName("org.zgkaii.reflect.Student");
```

用上面三种方式测试，通过三种方式测试获取到的各个 `Class` 对象都是相同的：

```java
        Class<?> class01 = Class.forName("org.zgkaii.reflect.Student");
        Class class02 = Student.class;

        Student student = new Student();
        Class<? extends Student> class03 = student.getClass();
        
        assert class01 == class02;
        assert class01 == class03;
        assert class02 == class03;
```

> 内存中只有一个 Class 对象的原因要牵扯到 `JVM 类加载机制`的`双亲委派模型`，它保证了程序运行时，`加载类`时每个类在内存中仅会产生一个`Class对象`。

### 构造类的实例化对象

通过反射构造一个类的实例方式有`2`种：

- Class 对象调用`newInstance()`方法

```java
        Class<?> class04 = Class.forName("org.zgkaii.reflect.Student");
        Student student01 = class04.newInstance();
        student01.getInfo(); // Student{name='null', age=0}
```

即使 Student 已经显式定义了构造方法，通过 `newInstance()`  创建的实例中，所有属性值都是对应类型的`初始值`，因为 `newInstance()` 构造实例会**调用默认无参构造器**。

- Constructor 构造器调用`newInstance()`方法

```java
        Class<?> class05 = Class.forName("org.zgkaii.reflect.Student");
        Constructor<?> constructor = class05.getConstructor(String.class, int.class);
        constructor.setAccessible(true);
        Student student02 = (Student) constructor.newInstance("李四", 22);
        student02.getInfo(); // Student{name='李四', age=22}
```

通过`getConstructor(Object... paramTypes)` 方法指定获取**指定参数类型**的 Constructor， Constructor 调用 `newInstance(Object... paramValues) `时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。

通过`Class`对象调用 `newInstance()` 会走**默认无参构造方法**，如果想通过**显式构造方法**构造实例，需要提前从Class中调用`getConstructor()`方法获取对应的构造器，通过构造器去实例化对象。

### 获取类中所有信息

（1）获取类中变量（Field）

* `Field[] getFields()`：获取类中所有被`public`修饰的所有变量。
* `Field getField(String name)`：根据**变量名**获取类中的一个变量，该**变量必须被public修饰。**
* `Field[] getDeclaredFields()`：获取类中所有的变量，但**无法获取继承下来的变量。**
* `Field getDeclaredField(String name)`：根据姓名获取类中的某个变量，**无法获取继承下来的变量。**

（2）获取类中方法（Method）

* `Method[] getMethods()`：获取类中被`public`修饰的所有方法。
* `Method getMethod(String name, Class...<?> paramTypes)`：根据**名字和参数类型**获取对应方法，该方法必须被`public`修饰。
* `Method[] getDeclaredMethods()`：获取`所有`方法，但**无法获取继承下来的方法**。
* `Method getDeclaredMethod(String name, Class...<?> paramTypes)`：根据**名字和参数类型**获取对应方法，**无法获取继承下来的方法**。

（3）获取类中构造函数（Constructor）

* `Constuctor[] getConstructors()`：获取类中所有被public修饰的构造器。
* `Constructor getConstructor(Class...<?> paramTypes)`：根据`参数类型`获取类中某个构造器，该构造器必须被`public`修饰。
* `Constructor[] getDeclaredConstructors()`：获取类中所有构造器。
* `Constructor getDeclaredConstructor(class...<?> paramTypes)`：根据`参数类型`获取对应的构造器。

> 有`Declared`修饰的方法：可以获取该类内部包含的**所有**变量、方法和构造器，但是**无法获取继承下来的信息**。
>
> 无`Declared`修饰的方法：可以获取该类中`public`修饰的变量、方法和构造器，可**获取继承下来的信息**。

（4）获取注解

- `Annotation[] getAnnotations()`：获取该对象上的**所有注解**。
- `Annotation getAnnotation(Class annotaionClass)`：传入`注解类型`，获取该对象上的特定一个注解。
- `Annotation[] getDeclaredAnnotations()`：获取该对象上的显式标注的所有注解，无法获取`继承`下来的注解。
- `Annotation getDeclaredAnnotation(Class annotationClass)`：根据`注解类型`，获取该对象上的特定一个注解，无法获取`继承`下来的注解。

只有注解的`@Retension`标注为`RUNTIME`时，才能够通过反射获取到该注解，`@Retension` 有`3`种保存策略：

- `SOURCE`：只在**源文件(.java)**中保存，即该注解只会保留在源文件中，**编译时编译器会忽略该注解**，例如 @Override 注解。
- `CLASS`：保存在**字节码文件(.class)中，注解会随着编译跟随字节码文件中，但是\**运行时**不会对该注解进行解析。
- `RUNTIME`：一直保存到**运行时**，**用得最多的一种保存策略**，在运行时可以获取到该注解的所有信息。

## 反射的应用场景

反射的主要应用场景有：

- **开发通用框架** - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
- **动态代理** - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。
- **注解** - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。
- **可扩展性功能** - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。

这里介绍`3`个实例应用案例：

- Spring 实例化对象：当程序启动时，Spring 会读取配置文件`applicationContext.xml`并解析出里面所有的标签实例化到`IOC`容器中。
- 反射 + 工厂模式：通过`反射`消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，`反射`可以使得程序更加健壮。
- JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的`驱动类`时用到反射加载驱动类。

### Spring 的 IOC 容器

在 Spring 中，经常会编写一个上下文配置文件`applicationContext.xml`，里面就是关于`bean`的配置，程序启动时会读取该 xml 文件，解析出所有的 `<bean>`标签，并实例化对象放入`IOC`容器中。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="student" class="org.zgkaii.reflect.Student">
        <constructor-arg type="java.lang.String" value="张三"/>
        <constructor-arg type="int" value="11"/>
    </bean>
</beans>
复制代码
```

在定义好上面的文件后，通过`ClassPathXmlApplicationContext`加载该配置文件，程序启动时，Spring 会将该配置文件中的所有`bean`都实例化，放入 IOC 容器中，IOC 容器本质上就是一个工厂，通过该工厂传入 <bean> 标签的`id`属性获取到对应的实例。

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext ac =
                new ClassPathXmlApplicationContext("applicationContext.xml");
        Student sd = (Student) ac.getBean("student");
        sd.getInfo(); // Student{name='张三', age=11}
    }
}
```

Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：

- **获取Class对象的构造器**
- 通过构造器**调用 newInstance()** 实例化对象

当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的**便捷且稳定**。

### 反射 + 抽象工厂模式

传统的工厂模式，如果需要生产新的子类，**需要修改工厂类，在工厂类中增加新的分支**；

```java
public class MapFactory {
    public Map<Object, object> produceMap(String name) {
        if ("HashMap".equals(name)) {
            return new HashMap<>();
        } else if ("TreeMap".equals(name)) {
            return new TreeMap<>();
        } // ···
    }
}
```

利用反射和工厂模式相结合，在产生新的子类时，**工厂类不用修改任何东西**，可以专注于子类的实现，**当子类确定下来时，工厂也就可以生产该子类了。**

反射 + 抽象工厂的**核心思想**是：

- **在运行时通过参数传入不同子类的全限定名获取到不同的 Class 对象，调用 newInstance() 方法返回不同的子类**。细心的读者会发现提到了子类这个概念，所以反射 + 抽象工厂模式，一般会用于有继承或者接口实现关系。

例如，在运行时才确定使用哪一种 `Map` 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。

```java
public class MapFactory {
    /**
     * @param className 类的全限定名
     */
    public Map<Object, Object> produceMap(String className) {
        Class clazz = Class.forName(className);
        Map<Object, Object> map = clazz.newInstance();
        return map;
    }
}
```

`className` 可以指定为`java.util.HashMap`，或者`java.util.TreeMap` 等等，根据业务场景来定。

### JDBC 加载数据库驱动类

在导入第三方库时，JVM不会主动去加载外部导入的类，而是**等到真正使用时，才去加载需要的类**，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给 JVM 加载该类。

```java
public class DBConnectionUtil {
    /** 指定数据库的驱动类 */
    private static final String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver";
    
    public static Connection getConnection() {
        Connection conn = null;
        // 加载驱动类
        Class.forName(DRIVER_CLASS_NAME);
        // 获取数据库连接对象
        conn = DriverManager.getConnection("jdbc:mysql://···", "root", "root");
        return conn;
    }
}
复制代码
```

在我们开发 SpringBoot 项目时，常见的`application.yml`中的数据库配置例如：

```yml
spring:
    datasource:
    	driver-class-name: com.mysql.cj.jdbc.Driver
    	username: root
    	password: xxxx
    	url: jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf-8& ... ...
```

因为**MySQL**版本不同引起的**驱动类不同**，这里的 **driver-class-name**使用了`com.mysql.cj.jdbc.Driver`。这里体现使用反射的好处：不需要修改源码，**仅加载配置文件就可以完成驱动类的替换**。

# 动态代理

动态代理在 Java 中有着广泛的应用，比如 **AOP 的实现原理、RPC远程调用、Java 注解对象获取、日志框架、全局性异常处理、事务处理等**。

代理模式（Proxy Design Pattern）的核心思想是，在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。这样做的好处是可以在**目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能**。

## 静态代理

一般而言，静态代理其实就是指设计模式中的代理模式。代理模式为其他对象提供一种代理以控制对这个对象的访问。

例如我们构建一个用户接口，定义一个保存用户的模版方法。

```java
public interface UserDao {
    void save();
}
```

构建一个用户实现类，这个用户实现类是真正进行用户操作的方法

```java
public class UserDaoImpl implements UserDao {
    
    @Override
    public void save() {
        System.out.println("------保存用户------");
    }
}
```

构建一个用户代理类，用户代理类也有一个保存用户的方法，不过这个方法属于代理方法，它不会执行真正的保存用户，而是内部持有一个真正的用户对象，进行用户保存。

```java
public class UserProxy {

    private UserDao userDao;

    public UserProxy(UserDao userDao) {
        this.userDao = userDao;
    }

    public void proxy() {
        System.out.println("------代理开始------");
        userDao.save();
        System.out.println("------代理结束------");
    }
}
```

下面是测试方法。

```java
public class ProxyTest {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        UserProxy userProxy = new UserProxy(userDao);
        userProxy.proxy();
    }
}
```

**代理模式具有无侵入性的优点**，以后我们增加什么新功能的话，我们可以直接增加一个代理类，让代理类来调用用户操作，这样我们就实现了不通过改源码的方式增加了新的功能。

静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和` UserDaoImpl`的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，会导致系统结构比较臃肿和松散。

## JDK动态代理

**动态代理（Dynamic Proxy）是一种方便运行时动态构建代理、动态处理代理方法调用的机制**。也就是说，我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

动态代理利用了[JDK API](http://tool.oschina.net/uploads/apidocs/jdk-zh/)，动态地在内存中构建代理对象，从而实现对目标对象的代理功能，动态代理又被称为JDK代理或接口代理。

Java 动态代理基于经典代理模式，引入了一个 `InvocationHandler`，`InvocationHandler `负责统一管理所有的方法调用。

动态代理步骤：

* 获取 `UserDaoImpl`上的所有接口列表；
* 确定要生成的代理类的类名，默认为：`com.sun.proxy.$ProxyXXXX`；
* 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；
* 将对应的字节码转换为对应的 class 对象；
* 创建 `InvocationHandler` 实例 handler，用来处理 `Proxy` 所有方法调用；
* Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。

可以看出，JDK动态代理的实现是基于实现接口的方式，使得Proxy和 `UserDaoImpl `具有相同的功能。

在 Java 的动态代理机制中，有两个重要的类（接口），一个是 `InvocationHandler` 接口、另一个则是 `Proxy` 类，这一个类和一个接口是实现我们动态代理所必须用到的。

### InvocationHandler 接口

`InvocationHandler` 接口定义：

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

每一个动态代理类都必须要实现 `InvocationHandler` 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 `InvocationHandler` 这个接口的 `invoke` 方法来进行调用。

我们来看看 `InvocationHandler` 这个接口的唯一一个方法 invoke 方法：

```java
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
```

参数说明：

- **proxy** - 代理的真实对象。
- **method** - 所要调用真实对象的某个方法的 `Method` 对象
- **args** - 所要调用真实对象某个方法时接受的参数

### Proxy 类

`Proxy` 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 `newProxyInstance` 这个方法：

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException
```

这个方法的作用就是得到一个动态的代理对象。

参数说明：

- **loader** - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。
- **interfaces** - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
- **h** - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上

### 动态代理实例

例如我们构建一个用户接口，定义一个保存用户的模版方法。

```java
public interface UserDao {
    void save();
}
```

构建一个用户实现类，这个用户实现类是真正进行用户操作的方法

```java
public class UserDaoImpl implements UserDao {
    
    @Override
    public void save() {
        System.out.println("------保存用户------");
    }
}
```

我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：

```java
public class UserHandler implements InvocationHandler {
    /**
     * 这个就是我们要代理的真实对象
     */
    private UserDao userDao;

    public UserHandler(UserDao userDao) {
        this.userDao = userDao;
    }

    /**
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        saveStart();

        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        Object obj = method.invoke(userDao, args);

        saveEnd();
        return obj;
    }

    private void saveStart() {
        System.out.println("------插入开始------");
    }

    private void saveEnd() {
        System.out.println("------插入结束------");
    }
}
```

编写测试类：

```java
public class DynamicProxyTest {
    public static void main(String[] args) {
        // 要代理的真实对象
        UserDao userDao = new UserDaoImpl();
        // 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法
        UserHandler handler = new UserHandler(userDao);

        ClassLoader classLoader = handler.getClass().getClassLoader();
        Class<?>[] interfaces = userDao.getClass().getInterfaces();

        /*
         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
         * 第一个参数classLoader，这里使用handler这个类的ClassLoader对象来加载我们的代理对象
         * 第二个参数interfaces，为代理对象提供的接口是真实对象所实行的接口，表示代理的是该真实对象
         * 第三个参数handler，这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
         */
        UserDao proxy = (UserDao) Proxy.newProxyInstance(classLoader, interfaces, handler);

        System.out.println(proxy.getClass().getName());
        proxy.save();
    }
}
```

看看控制台的输出：

```java
com.sun.proxy.$Proxy0
------插入开始------
------保存用户------
------插入结束------
```

通过 `Proxy.newProxyInstance` 创建的代理对象是在 JVM 运行时动态生成的一个对象，它并不是我们的 `InvocationHandler` 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，Proxy 为中，最后一个数字表示对象的标号。

## CGLIB 动态代理

上面我们提到 JDK 动态代理是基于接口的代理，而 CGLIB 动态代理**是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法** ，也就是说 CGLIB 动态代理采用类继承 -> 方法重写的方式进行的。

下面我们通过一个示例来演示一下 CGLIB 动态代理的使用

首先导入 CGLIB 相关 jar 包，我们使用的是 MAVEN 的方式

```xml
       <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.1</version>
        </dependency>
```

然后我们新创建一个 UserService 类，为了和上面的 UserDao 和 UserDaoImpl 进行区分。

```java
public class UserService {
    public void saveUser(){
        System.out.println("---- 保存用户 ----");
    }
}
```

之后我们创建一个自定义方法拦截器，这个自定义方法拦截器实现了拦截器类

```java
public class AutoMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, 
                            MethodProxy methodProxy) throws Throwable {
        System.out.println("before-------切面加入逻辑");
        Object object = methodProxy.invokeSuper(o, objects);
        System.out.println("after-------切面加入逻辑");
        return object;
    }
}
```

这里解释一下这几个参数都是什么含义：

- `Object o`: `o`是 CGLIB 动态生成代理类实例。
- `Method method`: Method 为实体类所调用的被代理的方法引用。
- `Object[] objects`: 这个就是方法的参数列表。
- `MethodProxy methodProxy` : 这个就是生成的代理类对方法的引用。

对于 `methodProxy` 参数调用的方法，在其内部有两种选择：`invoke()` 和 `invokeSuper()` ，二者的区别不在本文展开说明，感兴趣的读者可以参考本篇文章：[Cglib源码分析 invoke和invokeSuper的差别](https://blog.csdn.net/makecontral/article/details/79593732?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-4&spm=1001.2101.3001.4242)

然后我们创建一个测试类进行测试：

```java
public class CglibTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback(new AutoMethodInterceptor());

        UserService userService = (UserService) enhancer.create();

        userService.saveUser();
        System.out.println(userService);
    }
}
```

测试类主要涉及 `Enhancer` 的使用，Enhancer 是一个非常重要的类，它允许为`非接口类型`创建一个 Java 代理，Enhancer 动态的创建给定类的子类并且拦截代理类的所有的方法，和 JDK 动态代理不一样的是不管是接口还是类它都能正常工作。测试类运行结果：

```java
before-------切面加入逻辑
---- 保存用户 ----
after-------切面加入逻辑
before-------切面加入逻辑
before-------切面加入逻辑
after-------切面加入逻辑
after-------切面加入逻辑
org.zgkaii.proxy.cglib.UserService$$EnhancerByCGLIB$$b044764d@69663380
```

JDK 动态代理与 CGLIB 动态代理都是将真实对象`隐藏`在代理对象的后面，以达到 `代理` 的效果。与 JDK 动态代理所不同的是 CGLIB 动态代理使用 Enhancer 来创建代理对象，而 JDK 动态代理使用的是 `Proxy.newProxyInstance `来创建代理对象；还有一点是 CGLIB 可以代理大部分类，而 JDK 动态代理只能代理实现了接口的类。

# 总结

**（1）反射机制**

反射机制是Java语言提供的一种基础功能，赋予了程序一种自省的能力，能够让程序在运行状态时获取到自身的所有信息。通过反射，对于任意一个类，我们都能够知道这个类的所有属性和方法；对于任意一个对象，我们都能够调用它的所有方法和属性。

反射的主要作用是：对于在编译期无法确定使用那个数据类的场景，通过反射可以在程序运行时构造出不同的数据类实例。

反射机制的应用十分广泛，主要应用场景有开发通用框架、动态代理 、注解及其他可扩展性功能中。

**（2）动态代理**

代理模式的核心思想是，在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，扩展目标对象的功能。

静态代理相对简单，只要代理对象对目标对象进行包装，就可以实现增强功能，具有无侵入性的优点。同时，静态代理在编译时产生class字节码文件，可以直接使用，效率高。但是静态代理只能为一个目标对象服务，如果目标对象过多，就会产生过多的代理类，这样容易造成系统臃肿和松散。

动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制。很多场景都是利用反射机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）、日志框架、全局性异常处理、事务处理等。

实现动态代理的方式很多，比如利用了反射机制的 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、CGLIB（基于 ASM）、`Javassist` 等。

* JDK 动态代理只需要目标对象实现业务接口，而代理类只实现 `InvocationHandler`接口，在程序运行时通过`反射机制`使用使用`Proxy.newProxyInstance `动态生成代理类`com.sun.proxy.$Proxy0`，可以减少代理类的数量，使用灵活。
* CGLIB 与 JDK 动态代理都是将真实对象隐藏在代理对象的后面。但 CGLIB 代理无需实现接口，通过`Enhancer` 生产类字节码实现代理生产代理类`org.zgkaii.proxy.cglib.UserService$$EnhancerByCGLIB$$b044764d@69663380`，比反射稍快，不存在性能问题。但是CGLIB会继承目标对象，需要重写方法，所以目标对象不能为final类。

# 参考资料

* [学会反射后，我被录取了](https://juejin.cn/post/6864324335654404104)

* [Java反射机制](https://juejin.cn/post/6844903663966617607)

- [深入理解 Java 反射和动态代理](https://juejin.cn/post/6844903807755747342)
- [动态代理竟然如此简单！](https://juejin.cn/post/6911549491158089742)
- [Spring AOP原理 JDK动态代理和CGLIB动态代理](https://juejin.cn/post/6844903762025250824)