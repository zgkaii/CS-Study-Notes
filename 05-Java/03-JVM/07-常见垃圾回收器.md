
<!-- MarkdownTOC -->
- [1. GC分类与性能指标](#1-gc分类与性能指标)
  - [1.1 垃圾收集器分类](#11-垃圾收集器分类)
  - [1.2 性能指标](#12-性能指标)
- [2. 不同的垃圾回收器概述](#2-不同的垃圾回收器概述)
  - [2.1 七种经典的垃圾收集器](#21-七种经典的垃圾收集器)
  - [2.2 垃圾收集器的组合关系](#22-垃圾收集器的组合关系)
- [3. Serial回收器：串行回收](#3-serial回收器串行回收)
- [4. ParNew回收器：并行回收](#4-parnew回收器并行回收)
- [5. Parallel回收器：吞吐量优先](#5-parallel回收器吞吐量优先)
- [6. CMS回收器：低延迟](#6-cms回收器低延迟)
  - [6.1 概述](#61-概述)
  - [6.2 特点分析](#62-特点分析)
  - [6.3 参数设置](#63-参数设置)
  - [6.4 小结](#64-小结)
- [7. G1回收器：区域化分代式](#7-g1回收器区域化分代式)
  - [7.1 概述](#71-概述)
  - [7.2 参数设置](#72-参数设置)
  - [7.3 分区Region：化整为零](#73-分区region化整为零)
  - [7.4 G1垃圾回收器的回收过程](#74-g1垃圾回收器的回收过程)
    - [7.4.1 年轻代模式转移暂停](#741-年轻代模式转移暂停)
    - [7.4.2 并发标记](#742-并发标记)
    - [7.4.3 转移暂停: 混合模式](#743-转移暂停-混合模式)
  - [7.5 Remembered Set（记忆集）](#75-remembered-set记忆集)
- [8. 垃圾回收器的新发展](#8-垃圾回收器的新发展)
  - [8.1 ZGC](#81-zgc)
    - [8.1.1 特性](#811-特性)
    - [8.1.2 ZGC原理](#812-zgc原理)
    - [8.1.3 参数设置](#813-参数设置)
  - [8.2 Shennandoah GC](#82-shennandoah-gc)
    - [8.2.1 Shennandoah 原理](#821-shennandoah-原理)
    - [8.2.2 参数设置](#822-参数设置)
- [9. 垃圾回收器总结](#9-垃圾回收器总结)

<!-- /MarkdownTOC -->

# 1. GC分类与性能指标

## 1.1 垃圾收集器分类

按**线程数**分（垃圾回收线程数），可以分为**串行垃圾回收器和并行垃圾回收器**。

 <div align="center"> <img src="..\images\jvm\20201015092110124.png" width="400px"></div>

串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。

- 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，**串行回收默认被应用在客户端的Client模式下的JVM中**。
- 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。

和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。

按照**工作模式**分，可以分为**并发式垃圾回收器和独占式垃圾回收器**。

- 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。
- 独占式垃圾回收器（Stop The World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

按**碎片处理方式**分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。

- 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用：指针碰撞
- 非压缩式的垃圾回收器不进行这步操作。再分配对象空间使用：空闲列表

还可以按工作的**内存区间**分，又分为年轻代垃圾回收器和老年代垃圾回收器。

## 1.2 性能指标

- **吞吐量**：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
- **暂停时间**：执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- **内存占用**：Java堆区所占的内存大小。
- 快速：一个对象从诞生到被回收所经历的时间。

**吞吐量、暂停时间、内存占用** 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。

这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。

简单来说，主要抓住两点：**吞吐量与暂停时间**。

**吞吐量（QPS）**就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即`吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）`。

>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。

吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4s

 <div align="center"> <img src="..\images\jvm\2020101509211052.png" width="600px"></div>

**“暂停时间”**是指一个时间段内应用程序线程暂停，让GC线程执行的状态。

例如，GC期间1ee毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5s

 <div align="center"> <img src="..\images\jvm\2020101509211063.png" width="600px"></div>

**吞吐量vs暂停时间**

高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。

低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。

不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。

因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。

相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。

在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。

现在标准：**在最大吞吐量优先的情况下，降低暂停时间**。

# 2. 不同的垃圾回收器概述

GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别。

**垃圾回收器发展史**

有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。

- 1999年随JDK1.3.1一起来的是串行方式的`serialGc`，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本。
- 2002年2月26日，`Parallel GC`和`Concurrent Mark Sweep GC`跟随JDK1.4.2一起发布。
- `Parallel GC`在JDK6之后成为HotSpot默认GC。
- 2012年，在JDK1.7u4版本中，G1可用。
- 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。
- 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。
- 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 "No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。
- 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。
- 2019年9月，JDK13发布。增强YGC，自动返回未用堆内存给操作系统。
- 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用。

## 2.1 七种经典的垃圾收集器

- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1

**7款经典收集器与垃圾分代之间的关系**

 <div align="center"> <img src="..\images\jvm\20201015092110205.png" width="600px"></div>

新生代收集器：Serial、ParNew、Parallel Scavenge

老年代收集器：Serial Old、Parallel Old、CMS

整堆收集器：G1

## 2.2 垃圾收集器的组合关系

 <div align="center"> <img src="..\images\jvm\20201015092111694.png" width="600px"></div>

> 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1。

- 其中Serial Old是作为CMS出现"Concurrent Mode Failure"失败的后备预案。
- （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将`Serial+CMS`、`ParNew+Serial Old`这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。
- （绿色虚线）JDK14中：弃用`Parallel Scavenge/Serialold GC`组合（JEP366）。
- （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）。

为什么要有很多收集器，一个不够吗？

因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。

虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们**选择的是对具体应用最合适的收集器**。

**如何查看默认垃圾收集器**：

* `-XX:+PrintCommandLineFlags`：查看命令行相关参数（包含使用的垃圾收集器）

* 使用命令行指令：`jinfo -flag  相关垃圾回收器参数  进程ID`

# 3. Serial回收器：串行回收

Serial收集器（`Serial/Serial Old`组合）是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。

串行GC对年轻代使用 **mark-copy（标记-复制）**算法，对老年代使用 **mark-sweep-compact（标记清除-整理）** 算法。

两者都是单线程的垃圾收集器，不能进行并行处理，所以**都会触发全线暂停（STW）**，停止所有的应用线程。

因此这种GC算法不能充分利用多核CPU。不管有多少CPU内核，JVM 在垃圾收集时都**只能使用单个核心**。

 <div align="center"> <img src="..\images\jvm\Serial.png" width="700px"></div>

这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它**只会使用一个CPU或一条收集线程去完成垃圾收集工作**，更重要的是在它进行垃圾收集时，**必须暂停其他所有的工作线程**，直到它收集结束（Stop The World）

优势：**简单而高效**（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。

在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。

要启用此款收集器，只需要指定一个JVM启动参数即可，同时对年轻代和老年代生效：

```shell
-XX:+UseSerialGC
```

# 4. ParNew回收器：并行回收

如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。

- Par是Parallel的缩写，New代表只能处理的是新生代。

ParNew 收集器除了采用**并行回收**的方式执行内存回收外，两款垃圾收集器（`ParNew/Serial Old` 组合）之间几乎没有任何区别。ParNew收集器在年轻代中同样在年轻代使用**标记-复制（mark-copy）**算法 ，在老年代使用 **标记-清除整理（mark-sweep-compact）**算法 。

年轻代和老年代的垃圾回收都会触发STW事件，暂停所有的应用线程来执行垃圾收集。两者在执行标记和 复制/整理 阶段时都使用多个线程，因此得名“（Parallel）”。通过并行执行，使得GC时间大幅减少。

并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量。ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。

 <div align="center"> <img src="..\images\jvm\ParNew.png" width="700px"></div>

- 对于新生代，回收次数频繁，使用并行方式高效。
- 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）
- 除Serial外，目前只有`ParNew GC`能与CMS收集器配合工作。

通过命令行参数`-XX:ParallelGCThreads=XXX`来指定 GC 线程数， 其默认值为CPU核心数。 可以通过下面的任意一组命令行参数来指定并行GC：

```shell
-XX:+UseParNewGC
```

# 5. Parallel回收器：吞吐量优先

HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了**复制算法、并行回收和"Stop-The-World"机制**。

那么Parallel 收集器的出现是否多此一举？

- 和ParNew收集器不同，Parallel Scavenge收集器的目标则是**达到一个可控制的吞吐量（Throughput）**，它也被称为吞吐量优先的垃圾收集器。
- 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。

高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在**后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，**那些执行批量处理、订单处理、工资支付、科学计算的应用程序**。

Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。

Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和"Stop-The-World"机制。

 <div align="center"> <img src="..\images\jvm\Parallel.png" width="700px"></div>

在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。**在Java8中，默认是此垃圾收集器**。

**参数配置**

`-XX:+UseParallelGC` ：手动指定年轻代使用Parallel并行收集器执行内存回收任务。

`-XX:+UseParallelOldGC` ：手动指定老年代都是使用并行回收收集器。

- 分别适用于新生代和老年代。默认jdk8是开启的。
- 上面两个参数，默认开启一个，另一个也会被开启。（**互相激活**）

`-XX:ParallelGCThreads`：设置年轻代并行收集器的线程数。

* 一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。

* 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量；当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]

`XX:MaxGCPauseMillis` ：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。（**慎用**）

* 为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。

`-XX:GCTimeRatio`：垃圾收集时间占总时间的比例（ = 1/（N+1））。用于衡量吞吐量的大小，取值范围（0，100），默认值99，也就是垃圾回收时间不超过1。

* 与前一个`-XX:MaxGCPauseMillis`参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。

`-XX:+UseAdaptivesizepplicy `：设置Parallel scavenge收集器具有自适应调节策略。

* 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。

* 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。

# 6. CMS回收器：低延迟

## 6.1 概述

CMS GC的官方名称为 **“Mostly Concurrent Mark and Sweep Garbage Collector”（最大并发-标记-清 除-垃圾收集器）**。其对年轻代采用并行STW方式的 **mark-copy (标记-复制)**算法 ，对老年代主要使用并发 **mark-sweep (标记-清除)**算法 ，**它第一次实现了让垃圾收集线程与用户线程同时工作**。

CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。

* 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。 
* 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。

目前**很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短**，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。

在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。

 <div align="center"> <img src="..\images\jvm\CMS.png" width="750px"></div>

CMS整个过程比之前的收集器要复杂，整个过程分为6个主要阶段：

- **初始标记**（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为**STW**机制而出现短暂的暂停，这个阶段的主要任务仅仅只是**标记出GC Roots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。

 <div align="center"> <img src="..\images\jvm\CMSGC1.png" width="400px"></div>

- **并发标记**（Concurrent-Mark）阶段：在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从 前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。

 <div align="center"> <img src="..\images\jvm\CMSGC2.png" width="400px"></div>

- **并发预处理**（Concurrent-Preclean）阶段：此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的卡片标记（Card Marking）。

 <div align="center"> <img src="..\images\jvm\CMSGC3.png" width="400px"></div>

- **最终标记**（Final-Remark）阶段：最终标记阶段是此次 GC 事件中的**第二次（也是最后一次）STW 停顿**。本阶段的目标是完成老年代中所有存活对象的标记。因为 之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程 序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。

 <div align="center"> <img src="..\images\jvm\CMSGC4.png" width="400px"></div>

- **并发清除**（Concurrent-Sweep）阶段：此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此 阶段删除不再使用的对象，并回收他们占用的内存空间。

 <div align="center"> <img src="..\images\jvm\CMSGC5.png" width="400px"></div>

- **并发重置**（Concurrent Reset）阶段：此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备。

## 6.2 特点分析

尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-The-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-The-World”，只是尽可能地缩短暂停时间。

**由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。**

另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

CMS收集器的垃圾收集算法采用的是**标记清除算法**，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。

**CMS为什么不使用标记整理算法？**

答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用。

**优点**

- 并发收集
- 低延迟

**缺点**

- **会产生内存碎片**，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。

- **CMS收集器对CPU资源非常敏感**。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
- **CMS收集器无法处理浮动垃圾**。可能出现“Concurrent Mode Failure"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

## 6.3 参数设置

- `-XX:+UseConcMarkSweepGC`手动指定使用CMS收集器执行内存回收任务。

开启该参数后会自动将`-XX:+UseParNewGC`打开。即：ParNew（Young区用）+CMS（Old区用）+Serial Old的组合。

- `-XX:CMSInitiatingOccupanyFraction` 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。

JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。**JDK6及以上版本默认值为92%**。

如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以**有效降低Full GC的执行次数**。

- `-XX:+UseCMSCompactAtFullCollection`用于指定在执行完Full GC。

GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。

- `-XX:CMSFullGCsBeforecompaction` 设置在执行多少次Full GC后对内存空间进行压缩整理。

- `-XX:ParallelcMSThreads` 设置CMS的线程数量。

CMS默认启动的线程数是（ParallelGCThreads + 3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。

## 6.4 小结

目前来说，常用的GC组合有：

（1）`Serial+Serial Old` 实现单线程的低延迟 垃圾回收机制； 

（2）`ParNew+CMS`，实现多线程的低延迟垃 圾回收机制； 

（3）`Parallel Scavenge+Parallel Old`，实现多线程的高吞吐量垃圾回收机制。

**JDK后续版本中CMS的变化**

JDK9新特性：CMS被标记为Deprecate了（JEP291）>如果对JDK9及以上版本的HotSpot虚拟机使用参数

* `-XX:+UseConcMarkSweepGC`来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。

JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用

* `XX:+UseConcMarkSweepGC`的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM。

# 7. G1回收器：区域化分代式

## 7.1 概述

> G1的全称是 **Garbage-First** ，意为垃圾优先，哪一块的垃圾最多就优先清理它。 G1 GC最主要的设计目标是：将STW停顿的时间和分布，变成可预期且可配置的。

**既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？**

原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。

与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。

**官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望**。

**为什么名字叫 Garbage First(G1)呢？**

因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。

G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**。

由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。

G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被orac1e官方称为“**全功能的垃圾收集器**”。

与此同时，CMS已经在JDK9中被标记为废弃（Deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用`-XX:+UseG1GC`来启用。

与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：

**并行与并发**

- 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。
- 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。

**分代收集**

- 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
- 划分为多个（通常是2048个）可以存放对象的 小块堆区域 (smaller heap regions) 。在逻辑上，所有的Eden区和Survivor区合起来就是年轻代，所有的Old区拼在一起那就是老年代。
- 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；

 <div align="center"> <img src="..\images\jvm\G1.png" width="500px"></div>

* 这样划分之后，使得 G1不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内 存块，称为此次GC的回收集(collection set)。每次GC暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块，见下图带对号的部分：

 <div align="center"> <img src="..\images\jvm\回收集.png" width="500px"></div>

**空间整合**

- CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理。
- G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。**Region之间是复制算法**，但整体上实际可看作是**标记-压缩（Mark-Compact）算法**，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

**可预测的停顿时间模型（即：软实时soft real-time）**
这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

- 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
- G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
- 相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

**缺点**

相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。

从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。

## 7.2 参数设置

* **`-XX:+UseG1GC`** ：启用G1 GC，JDK7和JDK8要求必须显示申请启动G1 GC； 
* `-XX:G1NewSizePercent` ：初始年轻代占整个Java Heap的大小，默认值为5%； 
* `-XX:G1MaxNewSizePercent `：最大年轻代占整个Java Heap的大小，默认值为60%； 
* `-XX:G1HeapRegionSize` ：设置每个Region的大小，单位MB，需要为1，2，4，8，16，32中的某 个值，默认是堆内存的1/2000。如果这个值设置比较大，那么大对象就可以进入Region了。 
* `-XX:ConcGCThreads` ：与Java应用一起执行的GC线程数量，默认是Java线程的1/4，减少这个参 数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程 不足，也会导致并行回收机制耗时加长。
* **` -XX:+InitiatingHeapOccupancyPercent `**（简称IHOP）：G1内部并行回收循环启动的阈值， 默认为Java Heap的45%。这个可以理解为老年代使用大于等于45%的时候，JVM会启动垃圾回收。这 个值非常重要，它决定了在什么时间启动老年代的并行回收。 
* `-XX:G1HeapWastePercent `：G1停止回收的最小内存大小，默认是堆大小的5%。GC会收集所有 的Region中的对象，但是如果下降到了5%，就会停下来不再收集了。就是说，不必每次回收就把所有 的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间。
* `-XX:G1MixedGCCountTarget `：设置并行循环之后需要有多少个混合GC启动，默认值是8个。老 年代Regions的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许G1 延长老年代的收集时间。 
* `-XX:+G1PrintRegionLivenessInfo` ：这个参数需要和 `- XX:+UnlockDiagnosticVMOptions` 配合启动，打印JVM的调试信息，每个Region里的对象存活 信息。
*  `-XX:G1ReservePercent` ：G1为了保留一些空间用于年代之间的提升，默认值是堆空间的10%。 因为大量执行回收的地方在年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、 比较多的大对象存活，这里需要保留一些内存。
*  `-XX:+G1SummarizeRSetStats `：这也是一个VM的调试信息。如果启用，会在VM退出的时候打印 出RSets的详细总结信息。如果启用 -XX:G1SummaryRSetStatsPeriod 参数，就会阶段性地打印 RSets信息。
*  `-XX:+G1TraceConcRefinement `：这个也是一个VM的调试信息，如果启用，并行回收阶段的日志 就会被详细打印出来。
*  `-XX:+GCTimeRatio `：大家知道，GC的有些阶段是需要Stop-the-World，即停止应用线程的。这个 参数就是计算花在Java应用线程上和花在GC线程上的时间比率，默认是9，跟新生代内存的分配比例 一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1的计算公式是100/ （1+GCTimeRatio）。这样如果参数设置为9，则最多10%的时间会花在GC工作上面。Parallel GC的 默认值是99，表示1%的时间被用在GC上面，这是因为Parallel GC贯穿整个GC，而G1则根据Region 来进行划分，不需要全局性扫描整个内存堆。 
* `-XX:+UseStringDeduplication` ：手动开启Java String对象的去重工作，这个是JDK8u20版本 之后新增的参数，主要用于相同String避免重复申请内存，节约Region的使用。 
* **`-XX:MaxGCPauseMills`** ：预期G1每次执行GC操作的暂停时间，单位是毫秒，默认值是200毫秒， G1会尽量保证控制在这个范围内。

## 7.3 分区Region：化整为零

使用G1收集器时，它将整个Java堆划分成**约2048**个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过`-XX:G1HeapRegionSize` 设定。**所有的Region大小相同，且在JVM生命周期内不会被改变**。

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。

 <div align="center"> <img src="..\images\jvm\20201015092110555.png" width="600px"></div>

一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。

G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。

**设置H的原因：**对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。**如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储**。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。

## 7.4 G1垃圾回收器的回收过程

G1 GC的垃圾回收过程主要包括如下三个环节：

- **年轻代模式转移暂停（Evacuation Pause）**
- **并发标记（Concurrent Marking）**
- **转移暂停: 混合模式（Evacuation Pause (mixed)）**

### 7.4.1 年轻代模式转移暂停

通过前面的分析可以看到，G1 GC会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以 此来比较稳定地控制暂停时间。在应用程序刚启动时，G1还没有采集到什么足够的信息，这时候就处于初 始的 `fully-young` 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝 到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。 拷贝的过程称为转移(Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。

### 7.4.2 并发标记

同时我们也可以看到，G1 GC的很多概念建立在CMS的基础上，所以下面的内容需要对CMS有一定的理解。

 G1并发标记的过程与CMS基本上是一样的。G1的并发标记通过`Snapshot-At-The-Beginning(起始快照) `的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。 

这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。

 有两种情况是可以完全并发执行的： 

一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾； 

二、在STW转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。 当堆内存的总体使用比例达到一定数值，就会触发并发标记。

这个默认比例是 **45%** ，但也可以通过JVM参数 `InitiatingHeapOccupancyPercent `来设置。和CMS一样，G1的并发标记也是由多个阶段组成， 其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。

**阶段 1: Initial Mark(初始标记)** 

此阶段标记所有从GC根对象直接可达的对象。在CMS中需要一次STW暂停，但G1里面通常是在转移暂停的 同时处理这些事情，所以它的开销是很小的。 

**阶段 2: Root Region Scan(Root区扫描)**

此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。

因为在并发标记的过程中迁移对象会造成很多麻烦，所以此阶段必须在下一次转移暂停之前完成。如果必须 启动转移暂停，则会先要求根区域扫描中止，等它完成才能继续扫描。在当前版本的实现中，根区域是存活 的小堆块：包括下一次转移暂停中肯定会被清理的那部分年轻代小堆块。 

**阶段 3: Concurrent Mark(并发标记)**

此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。 为了确保标记开始时的快照准确性，所有应用线程并发对对象图执行引用更新，G1 要求放弃前面阶段为了 标记目的而引用的过时引用。 

**阶段 4: Remark(再次标记)**

和CMS类似，这是一次STW停顿(因为不是并发的阶段)，以完成标记过程。

G1收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标 记开始时未被标记的存活对象。 

**阶段 5: Cleanup(清理)**

这一阶段也执行某些额外的清理，如引用处理或者类卸载(class unloading)。 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以 提升GC的效率。此阶段也为下一次标记执行必需的所有整理工作(house-keeping activities)：维护并发标记 的内部状态。 

所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部 分的存活率计算。此阶段也需要一个短暂的STW暂停，才能不受应用线程的影响并完成作业。

### 7.4.3 转移暂停: 混合模式

并发标记完成之后，G1将执行一次**混合收集（mixed collection）**，就是不只清理年轻代，还将一部分老年代区域也加入到回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响 混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因 此，在并发标记与混合转移暂停之间，很可能会存在多次`young`模式的转移暂停。 具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。 其中包括指定的软实时性 能指标，存活性，以及在并发标记期间收集的GC效率等数据，外加一些可配置的JVM选项。混合收集的过 程，很大程度上和前面的`fully-young gc`是一样的。

## 7.5 Remembered Set（记忆集）

一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？

在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样会降低MinorGC的效率。

**解决方法：**

无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描；

**每个Region都有一个对应的Remembered Set**；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过`CardTable`把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。

如下图所示，每个小堆块都有一个 Remembered Set ，列出了从外部指向本块的所有引用。这些引用将 被视为附加的 GC 根。注意，在并发标记过程中，老年代中被确定为垃圾的对象会被忽略，即使有外部引用 指向他们：因为在这种情况下引用者也是垃圾【如垃圾对象之间的引用或者循环引用】。

 <div align="center"> <img src="..\images\jvm\G1-RSet.png" width="500px"></div>

接下来的行为，和其他垃圾收集器一样，多个GC线程并行地找出哪些是存活对象，确定哪些是垃圾：

 <div align="center"> <img src="..\images\jvm\G1-RSet1.png" width="500px"></div>

最后，存活对象被转移到存活区(survivor regions)，在必要时会创建新的小堆块。现在，空的小堆块被释 放，可用于存放新的对象了。

 <div align="center"> <img src="..\images\jvm\G1-RSet2.png" width="500px"></div>

**小结**

特别需要注意的是，某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的。 

* 并发模式失败：G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。

  解决办法：增加堆大小，或者调整周期（例如增加线程数`-XX:ConcGCThreads `等）。 

* 晋升失败：没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC(to-space exhausted/to-space overflow）。

  * 解决办法： a) 增加 `–XX:G1ReservePercent `选项的值（并相应增加总的堆大小）增加预留内存量。 
  * b) 通过减少 `–XX:InitiatingHeapOccupancyPercent` 提前启动标记周期。 
  * c) 也可以通过增加 `–XX:ConcGCThreads` 选项的值来增加并行标记线程的数目。 


* 巨型对象分配失败：当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间。 
  * 解决办法：增加内存或者增大 `-XX：G1HeapRegionSize`

# 8. 垃圾回收器的新发展

## 8.1 ZGC

JDK11从JDK9和JDK10版本中继承了很多优秀的特性，比如JDK9引入的模块化功能和jhsdb调试工具等 等。 如果要在JDK11中选择一个最令人激动的特性，那就非ZGC莫属了。 ZGC 即 Z Garbage Collector（Z 垃圾收集器，Z有Zero的意思，主要作者是Oracle的Per Liden），这是一 款低停顿、高并发，基于小堆块（region）、不分代的增量压缩式垃圾收集器，平均GC耗时不到2毫秒，最 坏情况下的暂停时间也不超过10毫秒。	

> 注意:ZGC垃圾收集器从JDK11开始支持，但截止目前(2020年02月), 仅支持 x64平台的Linux操作系统。 在Linux x64下的JDK11以上版本中可以使用ZGC垃圾收集器。

在 Linux 系统中, JDK11安装完成后，可以通过如下参数启用ZGC:

```java
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g
```

### 8.1.1 特性

ZGC最主要的特点包括: 

* GC 最大停顿时间不超过 10ms 
* 堆内存支持范围广，小至几百 MB 的堆空间，大至4TB 的超大堆内存（JDK13升至16TB） 
* 与 G1 相比，应用吞吐量下降不超过15% 
* 当前只支持 Linux/x64 位平台，预期JDK14后支持MacOS和Windows系统

官方介绍说停顿时间在 10ms 以下，其实这个数据是非常保守的值。 根据基准测试（见参考材料里的PDF链接），在128G 的大堆下，最大停顿时间只有 1.68ms，远远低于10ms；和 G1 算法比起来相比，改进非常明显。

 <div align="center"> <img src="..\images\jvm\ZGC.png" width="700px"></div>

### 8.1.2 ZGC原理

ZCG的GC周期如图所示:

 <div align="center"> <img src="..\images\jvm\ZGC周期.png" width="700px"></div>

每个GC周期分为6个小阶段: 

1. 暂停-标记开始阶段:第一次暂停，标记根对象集合指向的对象； 
2. 并发标记/重映射阶段:遍历对象图结构，标记对象；
3. 暂停-标记结束阶段:第二次暂停，同步点，弱根对象清理；
4.  并发准备重定位阶段:引用处理、弱对象清理等；
5. 暂停-重定位开始阶段:第三次暂停，根对象指向重定向集合；
6. 并发重定位阶段:重定向集合中的对象重定向。 

这6个阶段在绝大部分时间都是并发执行的，因此对应用运行的GC停顿影响很小。 ZGC采用了并发的设计方式，这个实现是非常有技术含量的: 

* 需要把一个对象拷贝到另一个地址，这时另外一个线程可能会读取或者修改原来的这个老对象； 
* 即使拷贝成功，在堆中依然会有很多引用指向老的地址，那么就需要将这些引用更新为新地址。 

为了解决这些问题，ZGC引入了两项关键技术:“ **着色指针** ”和“ **读屏障** ”。

**着色指针**

ZGC使用着色指针来标记所处的 GC阶段。 着色指针是从64位的指针中，挪用了几位出来标识表示 `Marked0 、 Marked1 、 Remapped 、 Finalizable `。 所以不支持32位系统，也不支持指针压缩技术， 堆内存的上限是4TB。 从这些标记上就可以知道对象目前的状态，判断是不是可以执行清理压缩之类的操作。

 <div align="center"> <img src="..\images\jvm\着色指针.png" width="600px"></div>

**读屏障**

对于GC线程与用户线程并发执行时，业务线程修改对象的操作可能带来的不一致问题，ZGC使用的是读屏 障, 这点与其他GC使用写屏障不同。 

有读屏障在，就可以留待之后的其他阶段，根据指针颜色快速的处理。 并且不是所有的读操作都需要屏 障，例如下面只有第一种语句（加载指针时）需要读屏障，后面三种都不需要，又或者是操作原生类型的时 候也不需要。

可以把 读屏障 理解为一段代码，或者是一个指令, 后面挂着对应的处理函数。

例如下面代码：

```java
Object a = obj.x;
Object b = obj.x;
```

两行load操作对应的代码都插入了读屏障，但ZGC在第一个读屏障触发之后，不但将a的值更新为最新的， 通过 self healing 机制使得 obj.x 的指针也会被修正，第二个读屏障再触发时就直接进入FastPath，基本 上没有什么性能损耗了； 而Shenandoah 则不会修正obj.x的值，所以第二个读屏障又要进行一次 SlowPath。

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。

着色指针和读屏障，相当于在内存管理和应用程序代码之间加了一个中间层，通过这个中间层就可以实现更 多的功能。但是也可以看到算法本身有一定的开销，也带来了很多复杂性。

### 8.1.3 参数设置

一些常用的参数介绍: 

* `-XX:ZCollectionInterval` ：固定时间间隔进行gc，默认值为0。 
* `-XX:ZAllocationSpikeTolerance` ：内存分配速率预估的一个修正因子，默认值为2，一般不需 要更改。 
* `-XX:ZProactive` ：是否启用主动回收策略，默认值为true，建议开启。 
* `-XX:ZUncommit` ：将不再使用的内存还给OS，JDK13以后可以使用； JVM会让内存不会降到 Xms 以下，所以如果Xmx和Xms配置一样这个参数就会失效。
* ` -XX:+UseLargePages -XX:ZPath` ：使用大内存页。 Large Pages在Linux称为Huge Pages，配置 zgc使用Huge Pages可以获得更好的性能（吞吐量、延迟、启动时间）。 配置Huge Pages时，一般配 合ZPath使用。
* `-XX:UseNUMA` :启用NUMA支持【挂载很多CPU，每个CPU指定一部分内存条的系统】。 ZGC默认 开启NUMA支持，意味着在分配堆内存时，会尽量使用NUMA-local的内存。开启和关闭可以使用 `- XX:+UseNUMA` 或者 `-XX:-UseNUMA` 。 
* `-XX:ZFragmentationLimit`：根据当前region已大于ZFragmentationLimit，超过则回收，默认为25。 
* `-XX:ZStatisticsInterval `：设置打印ZStat统计数据(cpu、内存等log)的间隔。 
* `-XX:ConcGCThreads=<number>` ，这个参数对于并发执行的GC 策略都很重要，需要根据CPU核心数考虑，配置太多导致线程切换消耗太大，配置太少导致回收垃圾速度跟 不上系统使用的速度。

## 8.2 Shennandoah GC

Java 12 正式发布于2019年3月19日， 这个版本引入了一款新的垃圾收集器:Shenandoah。**Shenandoah 是一款超低延迟垃圾收集器(Ultra-Low-Pause-Time Garbage Collector)**，其设计目标是管理大型的多核服务器上,超大型的堆内存。GC线程与应用线程并发执行、使得 虚拟机的停顿时间非常短暂。

### 8.2.1 Shennandoah 原理

Shenandoah GC的原理，跟ZGC非常类似。

 <div align="center"> <img src="..\images\jvm\Shennandoah.png" width="800px"></div>

部分日志如下：

```java
GC(3) Pause Init Mark 0.771ms
GC(3) Concurrent marking 76480M->77212M(102400M) 633.213ms
GC(3) Pause Final Mark 1.821ms
GC(3) Concurrent cleanup 77224M->66592M(102400M) 3.112ms
GC(3) Concurrent evacuation 66592M->75640M(102400M) 405.312ms
GC(3) Pause Init Update Refs 0.084ms
GC(3) Concurrent update references 75700M->76424M(102400M) 354.341ms
GC(3) Pause Final Update Refs 0.409ms
GC(3) Concurrent cleanup 76244M->56620M(102400M) 12.242ms
```

对应工作周期如下: 

1. 初始标记阶段（Init Mark）:为堆和应用程序准备并发标记，然后扫描根对象集。这是GC周期的第一次 暂停，持续时间取决于根对象集的大小。因为根对象集很小，所以速度很快，暂停非常短。
2. 并发标记阶段（Concurrent Mark）:并发标记遍历堆，并跟踪可到达的对象。该阶段与应用程序同时运 行，其持续时间取决于存活对象的数量以及堆中对象图的结构。由于应用程序可以在此阶段自由分配新 数据，因此在并发标记期间堆占用率会上升。 
3. 最终标记阶段（Final Mark）:通过排空所有等待中的标记/更新队列，并重新扫描根对象集来完成并发 标记。这是GC周期中的第二次暂停，这里最主要的时间消耗在排空队列并扫描根对象集合。
4. 并发清理阶段（Concurrent Cleanup）:并发清除会回收即时的垃圾区域，即在并发标记之后检测到的 没有活动对象的区域。
5.  并发转移阶段（Concurrent Evacuation）:并发转移将对象从各个不同区域复制到指定区域。这是与其 他OpenJDK GC的主要区别。此阶段与应用程序还是可以同时运行，持续时间取决于要复制的集合大 小，不会导致程序暂停。
6. 初始引用更新阶段（Init Update Refs）:本阶段确保所有GC和应用程序线程均已完成转移，然后为下一 阶段GC做准备。这是周期中的第三次暂停，是所有暂停中最短的一次。
7. 并发引用更新阶段（Concurrent Update References）:遍历堆，并发更新引用，并将引用更新为在并 发转移期间移动的对象。 这是与其他OpenJDK GC的主要区别。 它的持续时间取决于堆中对象的数 量，而不在乎对象图结构，因为它会线性扫描堆。此阶段与应用程序同时运行。
8. 最终引用更新阶段（Final Update Refs）:通过再次更新现有的根对象集合来完成更新引用阶段。这是 GC周期中的最后一个暂停，其持续时间取决于根对象集的大小。
9. 并发清理阶段（Concurrent cleanup）:回收现阶段没有引用的区域。

使用 Shenandoah 时需要全面了解系统运行情况，综合分析系统响应时间。下图是官方给出的各种 GC 工 作负载对比：

 <div align="center"> <img src="..\images\jvm\Shennandoah2.png" width="800px"></div>

### 8.2.2 参数设置

推荐几个配置或调试 Shenandoah 的 JVM 参数: 

* `-XX:+AlwaysPreTouch` :使用所有可用的内存分页，减少系统运行停顿，为避免运行时性能损失。 
* `让 -Xmx 等于 -Xms `:设置初始堆大小与最大值一致，可以减轻堆内存扩容带来的压力，与 AlwaysPreTouch 参数配合使用，在启动时申请所有内存，避免在使用中出现系统停顿。
* ` -XX:+UseTransparentHugePages `:能够大大提高大堆的性能。

#  9. 垃圾回收器总结

截止JDK1.8，一共有7款不同的垃圾收集器：

| 垃圾收集器             | 分类 | 作用位置       | 算法                    | 特点         | 使用场景                               |
| ---------------------- | ---- | -------------- | ----------------------- | ------------ | -------------------------------------- |
| Serial                 | 串行 | 新生代         | 标记-复制               | 响应速度优先 | 单CPU环境下的client模式                |
| Serial Old             | 串行 | 老年代         | 标记-压缩               | 响应速度优先 | 单CPU环境下的client模式（CMS后备方案） |
| ParNew                 | 并行 | 新生代         | 标记-复制               | 响应速度优先 | 多CPU环境Server模式下与CMS配合使用     |
| Parallel <br/>Scavenge | 并行 | 新生代         | 标记-复制               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| Parallel Old           | 并行 | 老年代         | 标记-压缩               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| CMS                    | 并发 | 老年代         | 标记-清除               | 响应速度优先 | 互联网站或B/S业务                      |
| G1                     | 并发 | 新生代、老年代 | 标记-压缩<br/>标记-复制 | 响应速度优先 | 面向服务端应用，将来替换CMS            |

JDK11与JDK12起，分别开始支持ZGC与`Shennandoah GC`：

* ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几毫秒级别的延 迟，线性可扩展；
* Shenandoah: G1的改进版本，跟ZGC类似。

可以看出GC算法和实现的演进路线：

* `串行 -> 并行`: 重复利用多核CPU的优势，大幅降低GC暂停时间，提升吞吐量。
* `并行 -> 并发`: 不只开多个GC线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线 程一起并发执行，减少了单次GC暂停持续的时间，这能有效降低业务系统的延迟。
* `CMS -> G1`: G1可以说是在CMS基础上进行迭代和优化开发出来的。修正了CMS一些存在的问题，而 且在GC思想上有了重大进步，也就是划分为多个小堆块进行增量回收，这样就更进一步地降低了单次 GC暂停的时间。 可以发现，随着硬件性能的提升，业界对延迟的需求也越来越迫切。
* `G1 -> ZGC`: ZGC号称无停顿垃圾收集器，这又是一次极大的改进。ZGC和G1有一些相似的地方，但是 底层的算法和思想又有了全新的突破。 ZGC把一部分GC工作，通过读屏障触发陷阱处理程序的方式， 让业务线程也可以帮忙进行GC。这样业务线程会有一点点工作量，但是不用等，延迟也被极大地降下 来了。

**GC选择**

选择正确的 GC，唯一可行的方式就是去尝试，一般性的指导原则： 

* 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
* 如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；
* 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。 

对于内存大小的考量： 

* 一般 4G 以上，算是比较大，用 G1 的性价比较高。 
* 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。

最后需要明确一个观点：

- 没有最好的收集器，更没有万能的收集器。
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。

**JDK默认垃圾回收器**

 <div align="center"> <img src="..\images\jvm\20201015092111694.png" width="600px"></div>

> 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1。

问题：JDK8 的默认 GC 是什么？ JDK9，JDK10，JDK11…等等默认的 GC 是什么？

解答：虽然推出了这么多不同的垃圾回收器，但是每个JDK版本默认GC变化不多：

- 在JDK 7，默认是`Parallel Scavenge + Serial Old`。
- 在JDK 8 及JDK 7u4之后的版本，默认是`Parallel Scavenge + Parallel Old`。
- 在JDK 9 到JDK 16，默认是`G1`。