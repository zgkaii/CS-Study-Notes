# 反射机制

## 什么是反射

**编译期**指把源码编译成计算机可以执行的文件的过程，在 Java 中也就是把 Java 代码编成 class 文件的过程；而**运行期**是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。

Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，**反射机制指的是程序在运行时能够获取自身的信息。**在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

为什么会有反射呢？这里举一个例子，假如我们用Hash Map存储键值对：

* 如果在不使用反射时，构造对象使用 new 方式实现，这种方式在**编译期**就可以把对象的类型确定下来。那么代码为：

  ```java
  Map<Integer, Integer> map = new LinkedHashMap<>();
  ```

* 如果需求发生变更，需要构造另一个对象，则需要修改源码，非常不优雅，所以我们通过使用`开关`，在程序运行时判断需要构造哪一个对象，在运行时可以**变更开关**来实例化不同的数据结构。例如：

  ```java
  public Map<Integer, Integer> getMap(String param) {
      Map<Integer, Integer> map = null;
      if (param.equals("HashMap")) {
          map = new HashMap<>();
      } else if (param.equals("LinkedHashMap")) {
          map = new LinkedHashMap<>();
      } else if (param.equals("WeakHashMap")) {
          map = new WeakHashMap<>();
      }
      return map;
  }
  ```

* 如果还有其它扩展的类有可能被使用，就会创建出**非常多的分支**，且在编码时不知道有什么其他的类被使用到，假如日后`Map`接口下多了一个集合类是`xxxHashMap`，还得创建很多分支，太麻烦了。因此引出了反射：可以在`运行时`才确定使用哪一个数据类，在切换类时，无需重新修改源码、编译程序。

  ```java
  public Map<Integer, Integer> getMap(String className) {
      Class clazz = Class.forName(className);
      Consructor con = clazz.getConstructor();
      return (Map<Integer, Integer>) con.newInstance();
  }
  ```

从上面例子中可以看出：

* 反射的思想：**在程序运过程中确定和解析数据类的类型**；
* 反射的作用：对于在`编译期`无法确定使用哪个数据类的场景，通过`反射`可以在程序运行时**构造出不同的数据类实例**。

## 如何使用反射

Java反射主要有四部分组成：

* `Class`：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的**所有信息**。
* `Filed`：描述一个类的**属性**，内部包含了该属性的所有信息，例如**数据类型，属性名，访问修饰符**······
* `Constructor`：描述一个类的**构造方法**，内部包含了构造方法的所有信息，例如**参数类型，参数名字，访问修饰符**······
* `Method`：描述一个类的**所有方法**（包括抽象方法），内部包含了该方法的所有信息，与`Constructor`类似，不同之处是 Method 拥有**返回值类型**信息，因为构造方法是没有返回值的。

```java
public class Student {
    public String name;
    public int age;
    /**
     * 生日只有自己知道
     */
    public Date birthday;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void getInfo() {
        System.out.println("Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}');
    }
}
```

反射中的用法有非常非常多，常见的功能有以下这几个：

- 在运行时获取一个类的 **Class 对象**
- 在运行时构造一个类的 **实例化对象**
- 在运行时获取一个类的所有信息：**变量、方法、构造器、注解**

### 获取类的Class对象

在 Java 中，每一个类都会有专属于自己的 Class 对象，当我们编写完`.java`文件后，使用`javac`编译后，就会产生一个字节码文件`.class`，在字节码文件中包含类的所有信息，如`属性`，`构造方法`，`方法`······当字节码文件被装载进虚拟机执行时，会在内存中生成 Class 对象，它包含了该类内部的所有信息，在程序运行时可以获取这些信息。

获取Class对象有三种方法：

* `类名.class`：只能在编译前已经声明了该类类型才能获取Class对象。

```java
Class clazz = Student.class;
```

- `实例.getClass()`：通过实例化对象获取该实例的 Class 对象。

```java
Student student = new Student();
Class clazz = student.getClass();
```

- `Class.forName(className)`：通过类的**全限定名**获取该类的 Class 对象。

```java
Class clazz = Class.forName("org.zgkaii.reflect.Student");
```

用上面三种方式测试，通过三种方式测试获取到的各个 `Class` 对象都是相同的：

```java
        Class<?> class01 = Class.forName("org.zgkaii.reflect.Student");
        Class class02 = Student.class;

        Student student = new Student();
        Class<? extends Student> class03 = student.getClass();
        
        assert class01 == class02;
        assert class01 == class03;
        assert class02 == class03;
```

> 内存中只有一个 Class 对象的原因要牵扯到 `JVM 类加载机制`的`双亲委派模型`，它保证了程序运行时，`加载类`时每个类在内存中仅会产生一个`Class对象`。

### 构造类的实例化对象

通过反射构造一个类的实例方式有`2`种：

- Class 对象调用`newInstance()`方法

```java
        Class<?> class04 = Class.forName("org.zgkaii.reflect.Student");
        Student student01 = class04.newInstance();
        student01.getInfo(); // Student{name='null', age=0}
```

即使 Student 已经显式定义了构造方法，通过 newInstance()  创建的实例中，所有属性值都是对应类型的`初始值`，因为 newInstance() 构造实例会**调用默认无参构造器**。

- Constructor 构造器调用`newInstance()`方法

```java
        Class<?> class05 = Class.forName("org.zgkaii.reflect.Student");
        Constructor<?> constructor = class05.getConstructor(String.class, int.class);
        constructor.setAccessible(true);
        Student student02 = (Student) constructor.newInstance("李四", 22);
        student02.getInfo(); // Student{name='李四', age=22}
```

通过`getConstructor(Object... paramTypes)` 方法指定获取**指定参数类型**的 Constructor， Constructor 调用 `newInstance(Object... paramValues) `时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。

通过`Class`对象调用 `newInstance()` 会走**默认无参构造方法**，如果想通过**显式构造方法**构造实例，需要提前从Class中调用`getConstructor()`方法获取对应的构造器，通过构造器去实例化对象。

### 获取类中所有信息

（1）获取类中变量（Field）

* `Field[] getFields()`：获取类中所有被`public`修饰的所有变量。
* `Field getField(String name)`：根据**变量名**获取类中的一个变量，该**变量必须被public修饰。**
* `Field[] getDeclaredFields()`：获取类中所有的变量，但**无法获取继承下来的变量。**
* `Field getDeclaredField(String name)`：根据姓名获取类中的某个变量，**无法获取继承下来的变量。**

（2）获取类中方法（Method）

* `Method[] getMethods()`：获取类中被`public`修饰的所有方法。
* `Method getMethod(String name, Class...<?> paramTypes)`：根据**名字和参数类型**获取对应方法，该方法必须被`public`修饰。
* `Method[] getDeclaredMethods()`：获取`所有`方法，但**无法获取继承下来的方法**。
* `Method getDeclaredMethod(String name, Class...<?> paramTypes)`：根据**名字和参数类型**获取对应方法，**无法获取继承下来的方法**。

（3）获取类中构造函数（Constructor）

* `Constuctor[] getConstructors()`：获取类中所有被public修饰的构造器。
* `Constructor getConstructor(Class...<?> paramTypes)`：根据`参数类型`获取类中某个构造器，该构造器必须被`public`修饰。
* `Constructor[] getDeclaredConstructors()`：获取类中所有构造器。
* `Constructor getDeclaredConstructor(class...<?> paramTypes)`：根据`参数类型`获取对应的构造器。

> 有`Declared`修饰的方法：可以获取该类内部包含的**所有**变量、方法和构造器，但是**无法获取继承下来的信息**。
>
> 无`Declared`修饰的方法：可以获取该类中`public`修饰的变量、方法和构造器，可**获取继承下来的信息**。

（4）获取注解

- `Annotation[] getAnnotations()`：获取该对象上的**所有注解**。
- `Annotation getAnnotation(Class annotaionClass)`：传入`注解类型`，获取该对象上的特定一个注解。
- `Annotation[] getDeclaredAnnotations()`：获取该对象上的显式标注的所有注解，无法获取`继承`下来的注解。
- `Annotation getDeclaredAnnotation(Class annotationClass)`：根据`注解类型`，获取该对象上的特定一个注解，无法获取`继承`下来的注解。

只有注解的`@Retension`标注为`RUNTIME`时，才能够通过反射获取到该注解，`@Retension` 有`3`种保存策略：

- `SOURCE`：只在**源文件(.java)**中保存，即该注解只会保留在源文件中，**编译时编译器会忽略该注解**，例如 @Override 注解。
- `CLASS`：保存在**字节码文件(.class)\**中，注解会随着编译跟随字节码文件中，但是\**运行时**不会对该注解进行解析。
- `RUNTIME`：一直保存到**运行时**，**用得最多的一种保存策略**，在运行时可以获取到该注解的所有信息。

## 反射的应用场景

反射的主要应用场景有：

- **开发通用框架** - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
- **动态代理** - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。
- **注解** - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。
- **可扩展性功能** - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。

这里介绍`3`个实例应用案例：

- Spring 实例化对象：当程序启动时，Spring 会读取配置文件`applicationContext.xml`并解析出里面所有的  标签实例化到`IOC`容器中。
- 反射 + 工厂模式：通过`反射`消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，`反射`可以使得程序更加健壮。
- JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的`驱动类`时用到反射加载驱动类。

### Spring 的 IOC 容器

在 Spring 中，经常会编写一个上下文配置文件`applicationContext.xml`，里面就是关于`bean`的配置，程序启动时会读取该 xml 文件，解析出所有的 `<bean>`标签，并实例化对象放入`IOC`容器中。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="student" class="org.zgkaii.reflect.Student">
        <constructor-arg type="java.lang.String" value="张三"/>
        <constructor-arg type="int" value="11"/>
    </bean>
</beans>
复制代码
```

在定义好上面的文件后，通过`ClassPathXmlApplicationContext`加载该配置文件，程序启动时，Spring 会将该配置文件中的所有`bean`都实例化，放入 IOC 容器中，IOC 容器本质上就是一个工厂，通过该工厂传入 <bean> 标签的`id`属性获取到对应的实例。

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext ac =
                new ClassPathXmlApplicationContext("applicationContext.xml");
        Student sd = (Student) ac.getBean("student");
        sd.getInfo(); // Student{name='张三', age=11}
    }
}
```

Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：

- **获取Class对象的构造器**
- 通过构造器**调用 newInstance()** 实例化对象

当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的**便捷且稳定**。

### 反射 + 抽象工厂模式

传统的工厂模式，如果需要生产新的子类，**需要修改工厂类，在工厂类中增加新的分支**；

```java
public class MapFactory {
    public Map<Object, object> produceMap(String name) {
        if ("HashMap".equals(name)) {
            return new HashMap<>();
        } else if ("TreeMap".equals(name)) {
            return new TreeMap<>();
        } // ···
    }
}
复制代码
```

利用反射和工厂模式相结合，在产生新的子类时，**工厂类不用修改任何东西**，可以专注于子类的实现，**当子类确定下来时，工厂也就可以生产该子类了。**

反射 + 抽象工厂的**核心思想**是：

- **在运行时通过参数传入不同子类的全限定名获取到不同的 Class 对象，调用 newInstance() 方法返回不同的子类。\**细心的读者会发现提到了\**子类**这个概念，所以反射 + 抽象工厂模式，一般会用于有**继承**或者**接口实现**关系。

例如，在运行时才确定使用哪一种 `Map` 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。

```java
public class MapFactory {
    /**
     * @param className 类的全限定名
     */
    public Map<Object, Object> produceMap(String className) {
        Class clazz = Class.forName(className);
        Map<Object, Object> map = clazz.newInstance();
        return map;
    }
}
```

`className` 可以指定为`java.util.HashMap`，或者`java.util.TreeMap` 等等，根据业务场景来定。

### JDBC 加载数据库驱动类

在导入第三方库时，JVM不会主动去加载外部导入的类，而是**等到真正使用时，才去加载需要的类**，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给 JVM 加载该类。

```java
public class DBConnectionUtil {
    /** 指定数据库的驱动类 */
    private static final String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver";
    
    public static Connection getConnection() {
        Connection conn = null;
        // 加载驱动类
        Class.forName(DRIVER_CLASS_NAME);
        // 获取数据库连接对象
        conn = DriverManager.getConnection("jdbc:mysql://···", "root", "root");
        return conn;
    }
}
复制代码
```

在我们开发 SpringBoot 项目时，常见的`application.yml`中的数据库配置例如：

```yml
spring:
    datasource:
    	driver-class-name: com.mysql.cj.jdbc.Driver
    	username: root
    	password: xxxx
    	url: jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf-8& ... ...
```

因为**MySQL**版本不同引起的**驱动类不同**，这里的 **driver-class-name**使用了`com.mysql.cj.jdbc.Driver`。这里体现使用反射的好处：不需要修改源码，**仅加载配置文件就可以完成驱动类的替换**。

## 优势与缺陷

* 优点：增加程序的灵活性，例如上面数据库的数据源配置。
* 缺陷：破坏类的封装性与性能损耗（微小）及内部曝光 。

## 参考

* [学会反射后，我被录取了](https://juejin.cn/post/6864324335654404104)

* [Java反射机制](https://juejin.cn/post/6844903663966617607)

- [Java 基础之—反射（非常重要）](https://blog.csdn.net/sinat_38259539/article/details/71799078)
- [深入理解 Java 反射和动态代理](https://juejin.cn/post/6844903807755747342)