动态代理在 Java 中有着广泛的应用，比如 **AOP 的实现原理、RPC远程调用、Java 注解对象获取、日志框架、全局性异常处理、事务处理等**。

代理模式（Proxy Design Pattern）的核心思想是，在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。这样做的好处是可以在**目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能**。

# 静态代理

一般而言，静态代理其实就是指设计模式中的代理模式。代理模式为其他对象提供一种代理以控制对这个对象的访问。

例如我们构建一个用户接口，定义一个保存用户的模版方法。

```java
public interface UserDao {
    void save();
}
```

构建一个用户实现类，这个用户实现类是真正进行用户操作的方法

```java
public class UserDaoImpl implements UserDao {
    
    @Override
    public void save() {
        System.out.println("------保存用户------");
    }
}
```

构建一个用户代理类，用户代理类也有一个保存用户的方法，不过这个方法属于代理方法，它不会执行真正的保存用户，而是内部持有一个真正的用户对象，进行用户保存。

```java
public class UserProxy {

    private UserDao userDao;

    public UserProxy(UserDao userDao) {
        this.userDao = userDao;
    }

    public void proxy() {
        System.out.println("------代理开始------");
        userDao.save();
        System.out.println("------代理结束------");
    }
}
```

下面是测试方法。

```java
public class ProxyTest {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        UserProxy userProxy = new UserProxy(userDao);
        userProxy.proxy();
    }
}
```

**代理模式具有无侵入性的优点**，以后我们增加什么新功能的话，我们可以直接增加一个代理类，让代理类来调用用户操作，这样我们就实现了不通过改源码的方式增加了新的功能。

静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和` UserDaoImpl`的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，会导致系统结构比较臃肿和松散。

# 动态代理

## JDK动态代理

所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

动态代理利用了[JDK API](http://tool.oschina.net/uploads/apidocs/jdk-zh/)，动态地在内存中构建代理对象，从而实现对目标对象的代理功能，动态代理又被称为JDK代理或接口代理。

Java 动态代理基于经典代理模式，引入了一个 `InvocationHandler`，`InvocationHandler `负责统一管理所有的方法调用。

动态代理步骤：

* 获取 `UserDaoImpl`上的所有接口列表；
* 确定要生成的代理类的类名，默认为：`com.sun.proxy.$ProxyXXXX`；
* 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；
* 将对应的字节码转换为对应的 class 对象；
* 创建 `InvocationHandler` 实例 handler，用来处理 `Proxy` 所有方法调用；
* Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。

可以看出，JDK动态代理的实现是基于实现接口的方式，使得Proxy和 `UserDaoImpl `具有相同的功能。

在 Java 的动态代理机制中，有两个重要的类（接口），一个是 `InvocationHandler` 接口、另一个则是 `Proxy` 类，这一个类和一个接口是实现我们动态代理所必须用到的。

### InvocationHandler 接口

`InvocationHandler` 接口定义：

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

每一个动态代理类都必须要实现 `InvocationHandler` 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 `InvocationHandler` 这个接口的 `invoke` 方法来进行调用。

我们来看看 `InvocationHandler` 这个接口的唯一一个方法 invoke 方法：

```java
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
```

参数说明：

- **proxy** - 代理的真实对象。
- **method** - 所要调用真实对象的某个方法的 `Method` 对象
- **args** - 所要调用真实对象某个方法时接受的参数

### Proxy 类

`Proxy` 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 `newProxyInstance` 这个方法：

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException
```

这个方法的作用就是得到一个动态的代理对象。

参数说明：

- **loader** - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。
- **interfaces** - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
- **h** - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上

### 动态代理实例

例如我们构建一个用户接口，定义一个保存用户的模版方法。

```java
public interface UserDao {
    void save();
}
```

构建一个用户实现类，这个用户实现类是真正进行用户操作的方法

```java
public class UserDaoImpl implements UserDao {
    
    @Override
    public void save() {
        System.out.println("------保存用户------");
    }
}
```

我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：

```java
public class UserHandler implements InvocationHandler {
    /**
     * 这个就是我们要代理的真实对象
     */
    private UserDao userDao;

    public UserHandler(UserDao userDao) {
        this.userDao = userDao;
    }

    /**
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        saveStart();

        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        Object obj = method.invoke(userDao, args);

        saveEnd();
        return obj;
    }

    private void saveStart() {
        System.out.println("------插入开始------");
    }

    private void saveEnd() {
        System.out.println("------插入结束------");
    }
}
```

编写测试类：

```java
public class DynamicProxyTest {
    public static void main(String[] args) {
        // 要代理的真实对象
        UserDao userDao = new UserDaoImpl();
        // 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法
        UserHandler handler = new UserHandler(userDao);

        ClassLoader classLoader = handler.getClass().getClassLoader();
        Class<?>[] interfaces = userDao.getClass().getInterfaces();

        /*
         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
         * 第一个参数classLoader，这里使用handler这个类的ClassLoader对象来加载我们的代理对象
         * 第二个参数interfaces，为代理对象提供的接口是真实对象所实行的接口，表示代理的是该真实对象
         * 第三个参数handler，这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
         */
        UserDao proxy = (UserDao) Proxy.newProxyInstance(classLoader, interfaces, handler);

        System.out.println(proxy.getClass().getName());
        proxy.save();
    }
}
```

看看控制台的输出：

```java
com.sun.proxy.$Proxy0
------插入开始------
------保存用户------
------插入结束------
```

通过 `Proxy.newProxyInstance` 创建的代理对象是在 JVM 运行时动态生成的一个对象，它并不是我们的 `InvocationHandler` 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，Proxy 为中，最后一个数字表示对象的标号。

## CGLIB 动态代理

上面我们提到 JDK 动态代理是基于接口的代理，而 CGLIB 动态代理**是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法** ，也就是说 CGLIB 动态代理采用类继承 -> 方法重写的方式进行的。

下面我们通过一个示例来演示一下 CGLIB 动态代理的使用

首先导入 CGLIB 相关 jar 包，我们使用的是 MAVEN 的方式

```xml
       <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.1</version>
        </dependency>
```

然后我们新创建一个 UserService 类，为了和上面的 UserDao 和 UserDaoImpl 进行区分。

```java
public class UserService {
    public void saveUser(){
        System.out.println("---- 保存用户 ----");
    }
}
```

之后我们创建一个自定义方法拦截器，这个自定义方法拦截器实现了拦截器类

```java
public class AutoMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, 
                            MethodProxy methodProxy) throws Throwable {
        System.out.println("before-------切面加入逻辑");
        Object object = methodProxy.invokeSuper(o, objects);
        System.out.println("after-------切面加入逻辑");
        return object;
    }
}
```

这里解释一下这几个参数都是什么含义：

- `Object o`: `o`是 CGLIB 动态生成代理类实例。
- `Method method`: Method 为实体类所调用的被代理的方法引用。
- `Object[] objects`: 这个就是方法的参数列表。
- `MethodProxy methodProxy` : 这个就是生成的代理类对方法的引用。

对于 `methodProxy` 参数调用的方法，在其内部有两种选择：`invoke()` 和 `invokeSuper()` ，二者的区别不在本文展开说明，感兴趣的读者可以参考本篇文章：[Cglib源码分析 invoke和invokeSuper的差别](https://blog.csdn.net/makecontral/article/details/79593732?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-4&spm=1001.2101.3001.4242)

然后我们创建一个测试类进行测试：

```java
public class CglibTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback(new AutoMethodInterceptor());

        UserService userService = (UserService) enhancer.create();

        userService.saveUser();
        System.out.println(userService);
    }
}
```

测试类主要涉及 `Enhancer` 的使用，Enhancer 是一个非常重要的类，它允许为`非接口类型`创建一个 Java 代理，Enhancer 动态的创建给定类的子类并且拦截代理类的所有的方法，和 JDK 动态代理不一样的是不管是接口还是类它都能正常工作。测试类运行结果：

```java
before-------切面加入逻辑
---- 保存用户 ----
after-------切面加入逻辑
before-------切面加入逻辑
before-------切面加入逻辑
after-------切面加入逻辑
after-------切面加入逻辑
org.zgkaii.proxy.cglib.UserService$$EnhancerByCGLIB$$b044764d@69663380
```

JDK 动态代理与 CGLIB 动态代理都是将真实对象`隐藏`在代理对象的后面，以达到 `代理` 的效果。与 JDK 动态代理所不同的是 CGLIB 动态代理使用 Enhancer 来创建代理对象，而 JDK 动态代理使用的是 `Proxy.newProxyInstance `来创建代理对象；还有一点是 CGLIB 可以代理大部分类，而 JDK 动态代理只能代理实现了接口的类。

# 总结

静态代理比较简单，只要代理对象对目标对象进行包装，就可以实现增强功能，具有无侵入性的优点。同时，静态代理在编译时产生class字节码文件，可以直接使用，效率高。但是静态代理只能为一个目标对象服务，如果目标对象过多，就会产生过多的代理类，这样容易造成系统臃肿和松散。

JDK动态代理只需要目标对象实现业务接口，而代理类只实现 `InvocationHandler`接口，在程序运行时通过`反射机制`使用使用`Proxy.newProxyInstance `动态生成代理类`com.sun.proxy.$Proxy0`，可以减少代理类的数量，使用灵活。

CGLIB与JDK动态代理都是将真实对象隐藏在代理对象的后面。但CGLIB代理无需实现接口，通过Enhancer 生产类字节码实现代理生产代理类`org.zgkaii.proxy.cglib.UserService$$EnhancerByCGLIB$$b044764d@69663380`，比反射稍快，不存在性能问题。但是CGLIB会继承目标对象，需要重写方法，所以目标对象不能为final类。

# 参考

* [动态代理竟然如此简单！](https://juejin.cn/post/6911549491158089742)
* [深入理解 Java 反射和动态代理](https://juejin.cn/post/6844903807755747342)
* [spring aop原理 JDK动态代理和CGLIB动态代理](https://juejin.cn/post/6844903762025250824)