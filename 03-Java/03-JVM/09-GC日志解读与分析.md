**启动参数**

```shell
-XX:+PrintGCDetails 打印GC日志详情
-Xloggc:gc.demo.log 指定日志文件
-Xloggc:/log/gc.demo.log 指定GC日志文件存放的绝对路径
-XX:+PrintGCDateStamps 打印GC事件发生的日期时间
-Xms512m -Xmx512m 指定堆内存大小
-XX:+PrintGCApplicationStoppedTime 输出每次GC的持续时间和程序暂停时间
-XX:+PrintReferenceGC 输出GC清理了多少引用类型
-XX:+UseSerialGC	使用串行垃圾收集器
-XX:+UseParallelGC	使用并行垃圾收集器
-XX:+UseParallelGC -XX:+UseParallelOldGC 使用并行垃圾收集器
-XX:+UseConcMarkSweepGC	  使用CMS垃圾收集器,默认老年代使用SerialGC。
-XX:+UseConcMarkSweepGC -XX:+UseParNewGC 使用CMS垃圾收集
-XX:+UseG1GC			  使用G1垃圾回收器
```

 <div align="center"> <img src="..\..\images\jvm\Young GC.png" width="1000px"></div>

 <div align="center"> <img src="..\..\images\jvm\Full GC.png" width="1000px"></div>

日志分析网站：

* [https://gceasy.io/](https://gceasy.io/)

示例代码：

```java
/**
 * @Description: 演示GC日志生成与解读
 */
public class GCLogAnalysis {
    private static Random random = new Random();
    public static void main(String[] args) {

        // 当前毫秒时间戳
        long startMillis = System.currentTimeMillis();
        // 持续运行毫秒数; 可根据需要进行修改
        long timeoutMillis = TimeUnit.SECONDS.toMillis(1);
        // 结束时间戳
        long endMillis = startMillis + timeoutMillis;
        LongAdder counter = new LongAdder();
        System.out.println("正在执行...");
        // 缓存一部分对象; 进入老年代
        int cacheSize = 2000;
        Object[] cachedGarbage = new Object[cacheSize];
        // 在此时间范围内,持续循环
        while (System.currentTimeMillis() < endMillis) {
            // 生成垃圾对象
            Object garbage = generateGarbage(100 * 1024);
            counter.increment();
            int randomIndex = random.nextInt(2 * cacheSize);
            if (randomIndex < cacheSize) {
                cachedGarbage[randomIndex] = garbage;
            }
        }
        System.out.println("执行结束!共生成对象次数:" + counter.longValue());
    }

    // 生成对象
    private static Object generateGarbage(int max) {
        int randomSize = random.nextInt(max);
        int type = randomSize % 4;
        Object result = null;
        switch (type) {
            case 0:
                result = new int[randomSize];
                break;
            case 1:
                result = new byte[randomSize];
                break;
            case 2:
                result = new double[randomSize];
                break;
            default:
                StringBuilder builder = new StringBuilder();
                String randomString = "randomString-Anything";
                while (builder.length() < randomSize) {
                    builder.append(randomString);
                    builder.append(max);
                    builder.append(randomSize);
                }
                result = builder.toString();
                break;
        }
        return result;
    }
}
```

# 一、 Serial GC日志解读

JVM启动参数：

```shell
-XX:+UseSerialGC -Xms512m -Xmx512m -Xloggc:log/gc.serial.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps
```

生成日志文件`gc.serial.log`：

```shell
Java HotSpot(TM) 64-Bit Server VM (25.151-b12) ...
Memory: 4k page, physical 8252548k(1226120k free), swap 20314764k(6826184k free)
CommandLine flags: 
	-XX:InitialHeapSize=536870912 -XX:MaxHeapSize=536870912 -XX:+PrintGC 
	-XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers 
	-XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseSerialGC 
2021-03-25T16:55:40.866+0800: 0.497: [GC (Allocation Failure) 2021-03-25T16:55:40.866+0800: 0.498: 
	[DefNew: 139776K->17472K(157248K), 0.0353058 secs] 139776K->42224K(506816K), 0.0365058 secs] 
	[Times: user=0.02 sys=0.02, real=0.03 secs] 
... ...
2021-03-25T16:55:41.646+0800: 1.280: [GC (Allocation Failure) 2021-03-25T16:55:41.646+0800: 1.280: 
	[DefNew: 157243K->157243K(157248K), 0.0000175 secs]2021-03-25T16:55:41.646+0800: 1.280: 
	[Tenured: 324188K->321155K(349568K), 0.0474384 secs] 481431K->321155K(506816K), 
	[Metaspace: 4037K->4037K(1056768K)], 0.0475657 secs] [Times: user=0.03 sys=0.00, real=0.04 secs] 
Heap
 def new generation   total 157248K, used 90347K [0x00000000e0000000, 0x00000000eaaa0000, 0x00000000eaaa0000)
  eden space 139776K,  64% used [0x00000000e0000000, 0x00000000e583ac60, 0x00000000e8880000)
  from space 17472K,   0% used [0x00000000e8880000, 0x00000000e8880000, 0x00000000e9990000)
  to   space 17472K,   0% used [0x00000000e9990000, 0x00000000e9990000, 0x00000000eaaa0000)
 tenured generation   total 349568K, used 321155K [0x00000000eaaa0000, 0x0000000100000000, 0x0000000100000000)
   the space 349568K,  91% used [0x00000000eaaa0000, 0x00000000fe440ed0, 0x00000000fe441000, 0x0000000100000000)
 Metaspace       used 4044K, capacity 4572K, committed 4864K, reserved 1056768K
  class space    used 449K, capacity 460K, committed 512K, reserved 1048576K
```

日志解读我们主要关注GC暂停时间，以及GC之后的内存使用量与内存使用率。

* 第1行是JVM版本信息，第2行是内存分页、物理内存大小相关信息，第3行至第一个时间戳之间都是命令行参数。
* `2021-03-25T15:52:43.351+0800: 0.967`：GC事件开始时间。`0800`当前时区标识，这里是东八区。`0.967`是GC事件相对于JVM 启动时间的间隔，单位是秒。
* `GC`—表明是`Minor GC`，`Allocation Failure`表明触发GC原因。
* `DefNew`表明垃圾收集器名称。这个名字表示：年轻代使用的单线程、标记-复制、STW 垃圾 收集器。`139776K->17472K(157248K)`表示垃圾收集之前和之后的年轻代使用量。`(157248K)`表明年轻代总空间大小，从而得知年轻代使用率为：11%。
* `139776K->42224K(506816K)`表示垃圾收集之前和之后整个堆内存的使用情况。`(506816K)`表示堆内存可用总空间大小，从而得知GC之后堆内存使用率为9%。
* ` 0.0365058 secs`是GC事件持续时间，以秒为单位。
* `[Times: user=0.02 sys=0.02, real=0.03 secs]`此次GC的持续时间。`user`表示消耗CPU时间，`sys` 部分表示系统调用和系统等待事件 消耗的时间，`real`则表示应用程序暂停的时间。因为串行垃圾收集器(Serial Garbage Collector)只 用单个线程，所以`real = user + system` ，0.03秒也就是30毫秒。

GC前后对比，年轻代的使用量为 `139776K->17472` ，减少了 `122304K` 。 但堆内存的总使用量 `139776K->42224K` 只下降了 `97552K` 。 可以算出，从年轻代提升到老年代的对象占用了`122304K - 99661K = 24752K` 的内存空间。当然， 另一组数字也能推算出GC之后老年代的使用量`42224K - 17472K  = 24752K`。

第二段Full GC日志：

* ` Tenured `– 用于清理老年代空间的垃圾收集器名称。`Tenured` 表明使用的是单线程的STW垃圾收集器，使用的算法为`标记-清除-整理(mark-sweep-compact ) `。`324188K->321155K(349568K)`表示GC前后老年代的使用量，以及老年代的空间大小。` 0.0474384 secs`表示清理老年代花费时间。

* `481431K->321155K(506816K)`– 在GC前后整个堆内存部分的使用情况，以及可用的堆空间大 小。
* `4037K->4037K(1056768K)`Metaspace 空间的变化情况。可以看出，此次 GC过程中 Metaspace 也没有什么变化。
*  GC持续时间`real `为50毫秒，比起前面年轻代的GC来说增加了一倍左右。这是因为**GC时间，与GC后存活对象的总数量关系最大** 。

最后可以算出，老年代使用率为91%。和年轻代GC 相比，比较明显的差别是此次GC事件清理了老年代和Metaspace。

# 二、Parallel GC 日志解读

JVM启动参数：

```shell
-XX:+UseParallelGC -Xms512m -Xmx512m -Xloggc:log/gc.parallel.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps
```

生成日志文件`gc.parallel.log`：

# 三、CMS的GC日志解读

JVM启动参数：

```shell
-XX:+UseConcMarkSweepGC -Xms512m -Xmx512m -Xloggc:log/gc.cms.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps
```

生成日志文件`gc.cms.log`：

# 三、G1的GC日志解读

JVM启动参数：

```shell
-XX:+UseG1GC -Xms512m -Xmx512m -Xloggc:log/gc.g1.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps
```

生成日志文件`gc.g1.log`：


