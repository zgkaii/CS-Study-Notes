# 一、JVM基础知识

## 1.1 JDK、JRE与JVM

**JDK(Java Development Kit)**是用于开发Java应用程序的软件工具集合，主要包括了Java运行时环境（JRE）和一些Java开发工具（例如解释器`java.exe`，编译器`javac.exe`，打包工具`jar.exe`，文档生成器`javadoc.exe`等等）。

**JRE(Java RunTime Environment)**提供Java应用程序执行时所需的环境，由Java虚拟机（JVM）、核心类（libraries）及支持文件组成。

**JVM(Java Virtual Environment)**即所谓的Java虚拟机，它用于解释由`.java`文件编译生成的`.class`字节码文件，并将其映射到本地的CPU的指令集或OS系统调用中。虽然不同的操作系统使用不同的JVM映射规则，但JVM解释/编译字节码文件的规则一致，这使得Java语言具有了跨平台的特性。除此之外，JVM平台的不同语言还共享JVM所带来的垃圾回收器（GC）与即时编译器（JIT）。

<div align="center"> <img src="..\..\images\jvm\runanywhere.png" width="600px"></div>

三者之间关系：

```html
JDK > JRE > JVM
JDK = JRE + tools => JRE = JVM + libraries
```

## 1.2 字节码

## 1.3 .class文件执行流程

Java虚拟机与Java语言并没有必然的联系，它只与特定的**二进制文件格式**——`.class文件`格式所关联，class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

<div align="center"> <img src="..\..\images\jvm\class执行.png" width="600px"></div>

# 二、类加载器

## 2.1 类加载生命周期

一个类在JVM里的生命周期有7个阶段，分别是加载（Loading）、校验（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）、卸载（Unloading）。 其中前五部分（加载，验证，准备，解析，初始化）统称为类加载。

<div align="center"> <img src="..\..\images\jvm\类的生命周期.png" width="600px"></div>

**加载**：通过全限定名获取此类的二进制字节流，直白地说，就是找到`.class`文件；然后将字节流所代表的静态存储结构转化为方法区中的运行时数据结构；在堆内存中生成一个代表此类的`java.lang.Class`对象作为数据访问接口。

**链接**：

* **校验**：保证加载的`.class`文件中字节流包含信息符合虚拟机要求，确保正确性。验证主要分为`文件格式 -> 元数据 -> 字节码 -> 符号引用`四类。例如验证是否以**魔数0xCAFEBABE**开头（文件格式验证）。
* **准备**：将静态（static）变量初始化为标准默认值（`NUll && 0值 && false`），并在方法区为其分配内存空间。（进行内存分配的仅包括类变量，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，`final`修饰的静态变量除外）。
* **解析**：将常量池的符号引用转换为直接引用，其中直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用，例如类的符号引用为`CONSTANT_Class_info`。

**初始化**：执行类构造器`<cinit>()`方法，程序员可通过程序编码制定主观计划去**真正**初始化类变量和其他资源。

* 编译器收集`<clinit>()`动作按照源文件顺序执行。所以说，静态语句块中只能访问到定义在静态语句块之外的变量，静态语句块中访问静态语句块中的变量会提示“非法向前引用”。
* 父类的`<cinit>()`方法优先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

## 2.2 类加载器

上面所描述的，通过一个类的全限定类名获取二进制字节流的类加载过程，由类加载器（ClassLoader）完成。最常见的类加载器主要有3类：**启动类加载器**（BootstrapClassLoader）、**扩展类加载器**（ExtClassLoader） 和**应用程序类加载器**（AppClassLoader）。

<div align="center"> <img src="..\..\images\jvm\JVM 类加载器.png" width="800px"></div>

其中，启动类加载器又名引导类加载器，用C/C++语言实现，主要用于加载Java核心类库，如`rt.jar`。

扩展类加载器派生于`ClassLoader`类，主要加载`/lib/ext`扩展目录的jar包。

应用程序类加载器又名系统类加载器，派生于`ClassLoader`类，负责加载用户环境变量`CLASSPATH`或系统属性`java.class.path`指定路径下的类库，该类加载是程序中默认的类加载器。

用户自定义类加载器常用于实现隔离加载类、修改类加载的方式、扩展加载源与防止源码泄漏。实现自定义加载器步骤如下：

* 继承抽象类`java.lang.ClassLoader`类。
* JDK 1.2之前，重写`loadClass()`方法；JDK 1.2 之后，建议将类加载逻辑重写在`findclass()`方法中。
* 没有过于复杂的需求，可直接继承`URIClassLoader`类，这样可避免去编写`findclass()`方法及其获取字节码流的方式，

## 2.3 双亲委派机制

如果一个类加载器收到了类加载请求，它并不会先去加载，而是把请求委派给父类加载器去执行；如果父类加载器还存在其父类加载器，则进一步向上委派，依次递归，请求最终将到达顶层的启动类加载器；如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制（如果几个类加载器都没有加载到指定名称的类，那么再会抛出`ClassNotFountException`异常）。

<div align="center"> <img src="..\..\images\jvm\双亲委托.png" width="600px"></div>

双亲委派的好处在于避免类的重复加载，同时保证核心源代码安全，防止核心API被随意修改。

例如，自定义一个`java.lang.String`类。由于双亲委派，JVM在加载自定义String类的时候会率先使用启动类加载器加载，而启动类加载器在加载的过程中会先加载Java核心类库`rt.jar`中的`java\lang\String.class`，那么就根本无法加载到main方法。

```java
public class String {
    static {
        System.out.println("这是自定义的String类的静态代码块！");
    }
	
    // 无法加载，错误
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

# 三、运行时数据区

JVM在执行Java程序的过程中会把它所管理的内存主要划分5个不同的数据区域：**本地方法栈、程序计数器、虚拟机栈、堆、方法区**。这些区域有各自的用途和创建与销毁的时间。有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

 <div align="center"> <img src="..\..\images\jvm\运行时数据区.png" width="800px"></div>

==注意==，《Java 虚拟机规范》中指明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择区进行垃圾收集或者进行压缩。” 但对于 HotSpotJVM 而言，方法区还有一个别名叫做**Non-Heap(非堆）**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

如上图所描述一样，在JDK 1.7 之前，方法区在**逻辑上**属于**非堆**，是一块独立的内存区域，但其实际物理内存其实是在堆区的（存放于永久代）；直到JDK 1.8后，方法区的实现才被移动至直接内存中的元空间（MetaSpace）中，逻辑内存与实际物理内存都与堆区分开。

一般来讲，黄色部分为线程隔离的数据区域，其他部分为线程共享的区域。

|    区域    | 是否线程共享 | 是否存在内存溢出 | 是否存在GC |
| :--------: | :----------: | :--------------: | :--------: |
| 本地方法栈 |      否      |        是        |     否     |
| 程序计数器 |      否      |        否        |     否     |
|  虚拟机栈  |      否      |        是        |     否     |
|    堆区    |      是      |        是        |     是     |
|   方法区   |      是      |        是        |     是     |

> 内存溢出与内存泄漏：
>
> 内存泄漏（Memory Leak）是指本来无用的对象却继续占用内存，没有在恰当的时机释放占用的内存的情况。
>
> 内存溢出（Out Of Memory，简称OOM）是指可使用的内存不足的情况。
>
> 一般来讲，内存泄漏是资源管理问题或程序BUG，而内存溢出则是内存空间不足和内存泄漏的最终结果。

## 3.1 程序计数器

程序计数器（Program Counter Register）是对物理PC寄存器的一种模拟，主要用于存储当前线程需要执行的字节码指令地址。在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致。

例如下面的字节码文件，字节码左边的行号标识，它其实就是**指令地址**。

```java
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
```

> 注意：程序计算器是运行速度最快的存储区域，也是唯一一块不会出现OOM的内存区域。

## 3.2 虚拟机栈

常常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。在Java中，“栈”通常就是指这里讲的虚拟机栈。

Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **`OutOfMemoryError`：** 若Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError 错误。

**扩展：方法/函数如何调用？**

栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器**。JVM直接对Java栈的操作只有两个：

- 每一次方法执行，都伴随着对应的栈帧压栈（进栈/入栈）。
- 每一个方法执行结束，都会有一个对应栈帧被弹出。

## 3.3 本地方法栈

本地方法栈（Native Method Stack）用于管理本地方法的调用。其中，本地方法（NatIve Method）就是调用非Java代码的接口，例如`java.lang.Thread`中的`private native void start0()`方法。

Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。因此虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

## 3.4 堆

对Java应用程序而言，Java堆（Java Heap）是虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。

> 注意：由于逃逸分析，栈上分配和标量替换等技术的发展，导致并不是所有对象实例一定要在堆中分配内存。

Java堆是垃圾收集器管理的主要区域，又称GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。新生代分细致一点有：Eden 空间、From Survivor、To Survivor 空间等。这样对堆进行分代划分是为了更好地回收内存，或者更快地分配内存。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

JDK 1.7及之前堆内存逻辑上分为三部分：新生代+老年代+**永久代**

| 新生代                                    | 老年代                  | 永久代          |
| ----------------------------------------- | ----------------------- | --------------- |
| Young Generation Space                    | Tenure generation space | Permanent Space |
| Young/New（又被划分为Eden区和Survivor区） | Old/Tenure              | Perm            |

Java 8及之后堆内存逻辑上分为三部分：新生代+养老区+**元空间**

| 新生代                                    | 老年代                  | 元空间     |
| ----------------------------------------- | ----------------------- | ---------- |
| Young Generation Space                    | Tenure generation space | Meta Space |
| Young/New（又被划分为Eden区和Survivor区） | Old/Tenure              | Meta       |

> 疑问，元空间逻辑上属于堆吗？？

## 3.5 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。上面我们已经提到过，方法区还有一个别名叫做**Non-Heap(非堆）**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

但实际上，JDK 1.7 之前，方法区正是在堆内存的永久代中实现的，但这样导致Java更容易遇到内存溢出问题。JDK 1.7时，就已经把原本（JDK 1.6）放在永久代的字符串常量池、静态变量等移出到堆；而到了 JDK 1.8，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间（Metaspace）来代替，把JDK 1.7中永久代还剩余的内容（主要是类型信息）移到元空间中。

根据Java虚拟机规范，如果方法区无法满足新的内存分配需求时，也将抛出OutOfMemoryError异常。

>  方法区和永久代的关系
>
> > 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，不同的 JVM 上方法区的实现是可以不同的。  **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

# 四、Java对象

> 对象实例化详解 结合字节码...
>
> 待编写... ...

# 五、垃圾回收器

## 5.1 垃圾回收算法

GC是英文词汇`Garbage Collection` 的缩写， 中文一般直译为 “ 垃圾收集 ”。垃圾回收器回收垃圾一般分为两阶段：（1）**Marking (标记)**，标记“存活”的对象；**Sweeping (清除)**， 清除"死亡"的垃圾对象，释放内存。

### （1）标记阶段

**引用计数算法**：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。

* 优点：实现简单，垃圾对象便于标识；判定效率高，无延迟。
* 缺点：计数器增加存储开销；更新计数增加时间开销；**无法处理循环引用**问题。

**可达性分析算法**：又称根搜索算法、追踪性垃圾收集（Tracing Garbage Collection），其以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。如果目标对象没有任何引用链（Reference Chain，即搜索所走过的路径）相连，则是不可达的，意味着该对象己经死亡，可以标记为垃圾对象。

 <div align="center"> <img src="..\..\images\jvm\可达性.png" width="600px"></div>

* 优点：实现简单和执行高效；能有效处理循环引用的问题。

### （2）清除阶段

**(1) 标记-清除算法**

标记-清除算法(Mark-Sweep)思想很简单，就是直接清除掉垃圾对象（注意，标记的是可达的对象，不是垃圾对象）。

这种算法需要使用空闲表(**free-list**)，来记录所有的空闲区域，以及每个区域的大小。维护空闲表增加了对象分配时的开销。

* 如果内存规整，采用指针碰撞的方式进行内存分配；内存不规整，虚拟机需要维护一个列表，空闲列表分配。
* 清理出来的空闲内存大多是不连续的，产生内存碎片，仍然无法存放大对象。
* GC时需要暂停整个应用程序线程（STW）。

 <div align="center"> <img src="..\..\images\jvm\标记清除算法.png" width="800px"></div>

**(2) 标记复制算法**

**标记-复制算法(Mark and Copy)**核心思想是，将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。

* 优点：实现简单，运行高效；保证了空间的连续性。
* 缺点：是将可用内存缩小为了原来的一半，空间浪费未免太多；对象存活率较高时就要进行较多的复制操作，效率会大大降低。

 <div align="center"> <img src="..\..\images\jvm\标记复制算法.png" width="700px"></div>

**(3) 标记-整理算法**

标记-整理算法又称标记-压缩或标记-清除-压缩（Mark-Sweep-Compact）算法，其核心思想是让所有存活的对象都向内存空间一端移动（压缩到一端），然后直接清理掉边界以外的内存。

* 优点：消除了标记-清除算法当中，内存区域分散的缺点；消除了复制算法当中，内存减半的高额代价。
* 缺点：GC时需要暂停整个应用程序线程（STW）；如果被移动对象被其他对象引用，则还需要调整引用的地址。

 <div align="center"> <img src="..\..\images\jvm\标记整理算法.png" width="700px"></div>

**三者之间比较**

| 比较         | 标记-清除          | 标记-整理        | 标记-复制                             |
| ------------ | ------------------ | ---------------- | ------------------------------------- |
| **速率**     | 中等               | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是               | 是                                    |

> 没有最好的算法，只有最合适的算法。

**扩展 其他算法**：

分代收集算法（Generational Collecting）：对不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。目前几乎所有的GC都采用分代收集(Generational Collecting)算法执行垃圾回收的。

增量收集算法（Incremental Collecting）：让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

* 优点：对线程间冲突的妥善处理。
* 缺点：造成系统吞吐量的下降。

## 5.2 概念解释

**串行（Serial）**

* 在同一时间段内，只允许有一个CPU（单线程）用于执行垃圾回收操作，GC期间需暂停所有应用程序线程（STW）。

**并行（Parallel）**

* 在同一时间段内，可以运用多个CPU（多线程）同时执行垃圾回收，因此提升了应用的吞吐量，不过仍存在STW。

**并发（Concurrent）**

* 在同一时间段内，用户线程与垃圾收集线程同时执行（可并行，可交替执行），从而减小了STW时间。

**安全点（Safe Point）**

* 程序只有在特定的位置才能停顿下来开始GC，这些位置被称为安全点。安全点太少可能导致GC等待的时间太长，太多可能导致运行时的性能问题。

**STW**

* `Stop The World`，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。**停顿产生时整个应用程序线程都会被暂停，没有任何响应**，有点像卡死的感觉，这个停顿称为STW。

## 5.3 常见GC

JDK 1.8之前，主要有7款不同的垃圾回收器。

* 新生代收集器：Serial、ParNew、Parallel Scavenge

* 老年代收集器：Serial Old、Parallel Old、CMS

* 整堆收集器：G1

 <div align="center"> <img src="..\..\images\jvm\20201015092111694.png" width="600px"></div>

目前来说，常用的GC组合有：

（1）`Serial+Serial Old` 实现单线程的低延迟垃圾回收机制； 

（2）`ParNew+CMS`，实现多线程的低延迟垃圾回收机制； 

（3）`Parallel Scavenge+Parallel Old`，实现多线程的高吞吐量垃圾回收机制。

### （1）Serial GC：串行回收

Serial GC（`Serial/Serial Old`组合）是最基本、历史最悠久的垃圾收集器，其对年轻代使用标记-复制算法，对老年代使用标记-整理算法，年轻代和老年代的垃圾回收都会触发STW。适用于可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms）的场景。

 <div align="center"> <img src="..\..\images\jvm\Serial.png" width="650px"></div>

启动参数：`-XX:+UseSerialGC`

### （2）ParNew GC：并行回收

ParNew GC（`ParNew/Serial Old` 组合）对年轻代使用标记-复制算法 ，在老年代使用标记-整理算法 ，是Serial GC的多线程版本，年轻代和老年代的垃圾回收都会触发STW。对于新生代，回收次数频繁，使用并行方式高效；对于老年代，回收次数少，使用串行方式节省资源。

 <div align="center"> <img src="..\..\images\jvm\ParNew.png" width="650px"></div>

启动参数：`-XX:+UseParNewGC`，还可通过命令行参数`-XX:ParallelGCThreads=N`来指定 GC 线程数，其默认值为CPU核心数。

### （3）Parallel GC：吞吐量优先

Parallel GC（`Parallel Scavenge/Parallel Old`组合）对年轻代使用标记-复制算法 ，在老年代使用标记-整理算法，同样具备并行回收功能，年轻代和老年代的垃圾回收都会触发STW。

* 和ParNew GC不同，Parallel GC采用自适应调节策略，目的则是**达到一个可控制的吞吐量（Throughput）**，它也被称为吞吐量优先的垃圾收集器。
* **在Java8中，默认是此垃圾收集器**。

 <div align="center"> <img src="..\..\images\jvm\Parallel.png" width="650px"></div>

启动参数：`-XX:+UseParallelGC -XX:+UseParallelOldGC`。

### （4）CMS：低延迟

CMS GC的官方名称为 **“Mostly Concurrent Mark and Sweep Garbage Collector”（最大并发-标记-清除-垃圾收集器）**。其对年轻代采用并行STW方式的标记-复制算法 ，对老年代主要使用并发**标记-清除**算法 ，**它第一次实现了让垃圾收集线程与用户线程同时工作**。

* 优点：并发收集、低延迟。
* 缺点：老年代内存碎片。

 <div align="center"> <img src="..\..\images\jvm\CMS.png" width="750px"></div>

启动参数：`-XX:+UseConcMarkSweepGC`。

CMS整个过程比之前的收集器要复杂，整个过程分为6个主要阶段：

- **初始标记**（Initial-Mark）阶段：程序中所有的工作线程都将会因为**STW**机制而出现短暂的暂停，这个阶段的主要任务仅仅只是**标记出GC Roots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。

- **并发标记**（Concurrent-Mark）阶段：在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。

- **并发预处理**（Concurrent-Preclean）阶段：此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的卡片标记（Card Marking）。

- **最终标记**（Final-Remark）阶段：最终标记阶段是此次 GC 事件中的**第二次（也是最后一次）STW 停顿**。本阶段的目标是完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程 序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。

- **并发清除**（Concurrent-Sweep）阶段：此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收他们占用的内存空间。

- **并发重置**（Concurrent Reset）阶段：此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备。

### （5）G1：垃圾优先

G1 的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。

使用G1收集器时，它将整个Java堆划分成**约2048**个大小相同的独立堆区域(smaller heap regions)，每个Region块，可能一会被定义成 Eden区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来 就是年轻代，所有的 Old 区拼在一起那就是老年代。

G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。

 <div align="center"> <img src="..\..\images\jvm\20201015092110555.png" width="600px"></div>

启动参数`-XX:+UseG1GC`。

G1 GC的垃圾回收过程主要包括如下三个环节：

**年轻代模式转移暂停（Evacuation Pause）**：当年轻代空间用满后，应用线程会被暂停（STW），年轻代内存块中的存活对象被拷贝到存活区（标记-复制算法）。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。 拷贝的过程称为转移(Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。

**并发标记（Concurrent Marking）**： G1并发标记的过程与CMS基本上是一样的。

* **阶段 1: Initial Mark(初始标记)** ：标记所有从GC根对象直接可达的对象。在CMS中需要一次STW暂停，但G1里面通常是在转移暂停的同时处理这些事情，所以它的开销是很小的。 

  **阶段 2: Root Region Scan(Root区扫描)**：此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。因为在并发标记的过程中迁移对象会造成很多麻烦，所以此阶段必须在下一次转移暂停之前完成。如果必须 启动转移暂停，则会先要求根区域扫描中止，等它完成才能继续扫描。在当前版本的实现中，根区域是存活 的小堆块：包括下一次转移暂停中肯定会被清理的那部分年轻代小堆块。 

  **阶段 3: Concurrent Mark(并发标记)**：此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。 为了确保标记开始时的快照准确性，所有应用线程并发对对象图执行引用更新，G1 要求放弃前面阶段为了 标记目的而引用的过时引用。 

  **阶段 4: Remark(再次标记)**：和CMS类似，这是一次STW停顿(因为不是并发的阶段)，以完成标记过程。G1收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标 记开始时未被标记的存活对象。 

  **阶段 5: Cleanup(清理)**：这一阶段也执行某些额外的清理，如引用处理或者类卸载(class unloading)。 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC的效率（标记-整理算法）。此阶段也为下一次标记执行必需的所有整理工作(house-keeping activities)：维护并发标记 的内部状态。 

  * 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的STW暂停，才能不受应用线程的影响并完成作业。

**转移暂停: 混合模式（Evacuation Pause (mixed)）**：并发标记完成之后，G1将执行一次**混合收集（mixed collection）**，就是不只清理年轻代，还将一部分老年代区域也加入到回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次`young`模式的转移暂停。 具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。 其中包括指定的软实时性 能指标，存活性，以及在并发标记期间收集的GC效率等数据，外加一些可配置的JVM选项。混合收集的过 程，很大程度上和前面的`fully-young gc`是一样的。

> G1懵懂... 

## 5.3 GC总结

| 垃圾收集器             | 分类 | 作用位置       | 算法                    | 特点         | 使用场景                               |
| ---------------------- | ---- | -------------- | ----------------------- | ------------ | -------------------------------------- |
| Serial                 | 串行 | 新生代         | 标记-复制               | 响应速度优先 | 单CPU环境下的client模式                |
| Serial Old             | 串行 | 老年代         | 标记-整理               | 响应速度优先 | 单CPU环境下的client模式（CMS后备方案） |
| ParNew                 | 并行 | 新生代         | 标记-复制               | 响应速度优先 | 多CPU环境Server模式下与CMS配合使用     |
| Parallel <br/>Scavenge | 并行 | 新生代         | 标记-复制               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| Parallel Old           | 并行 | 老年代         | 标记-整理               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| CMS                    | 并发 | 老年代         | 标记-清除               | 响应速度优先 | 互联网站或B/S业务                      |
| G1                     | 并发 | 新生代、老年代 | 标记-复制<br/>标记-压缩 | 响应速度优先 | 面向服务端应用，将来替换CMS            |

JDK11与JDK12起，分别开始支持ZGC与Shennandoah GC：

* ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几毫秒级别的延 迟，线性可扩展；
* Shenandoah: G1的改进版本，跟ZGC类似。

可以看出GC算法和实现的演进路线：

* `串行 -> 并行`: 重复利用多核CPU的优势，大幅降低GC暂停时间，提升吞吐量。
* `并行 -> 并发`: 不只开多个GC线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线 程一起并发执行，减少了单次GC暂停持续的时间，这能有效降低业务系统的延迟。
* `CMS -> G1`: G1可以说是在CMS基础上进行迭代和优化开发出来的。修正了CMS一些存在的问题，而 且在GC思想上有了重大进步，也就是划分为多个小堆块进行增量回收，这样就更进一步地降低了单次 GC暂停的时间。 可以发现，随着硬件性能的提升，业界对延迟的需求也越来越迫切。
* `G1 -> ZGC`: ZGC号称无停顿垃圾收集器，这又是一次极大的改进。ZGC和G1有一些相似的地方，但是 底层的算法和思想又有了全新的突破。 ZGC把一部分GC工作，通过读屏障触发陷阱处理程序的方式， 让业务线程也可以帮忙进行GC。这样业务线程会有一点点工作量，但是不用等，延迟也被极大地降下 来了。

**GC选择**

选择正确的 GC，唯一可行的方式就是去尝试，一般性的指导原则： 

* 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
* 如果系统考虑低延迟，每次 GC 时间尽量短，用 CMS GC；
* 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。 

对于内存大小的考量： 

* 一般 4G 以上，算是比较大，用 G1 的性价比较高。 
* 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。

最后需要明确一个观点：

- 没有最好的收集器，更没有万能的收集器。
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。

# 七、JVM启动参数

# 八、GC日志分析

# 九、JVM性能调优
