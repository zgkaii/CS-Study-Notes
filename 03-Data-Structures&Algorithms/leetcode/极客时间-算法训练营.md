## 00-数据结构与算法总览

* [数据结构脑图](http://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c)

* [算法脑图](http://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec)

## 01-训练环境设置、编码技巧和Code Style

- [Windows Microsoft New Terminal](http://github.com/microsoft/terminal)
- [VS Code Themes](http://vscodethemes.com/)
- [教你打造一款颜值逆天的 VS Code](http://juejin.im/entry/587e0f2f570c352201113e14)
- [炫酷的 VS Code 毛玻璃效果](http://juejin.im/post/5ce1365151882525ff28ed47)
- [自顶向下的编程方式](http://markhneedham.com/blog/2008/09/15/clean-code-book-review/)
- [自顶向下编程的 LeetCode 例题](http://leetcode-cn.com/problems/valid-palindrome/)

## 02-时间复杂度和空间复杂度分析

- [如何理解算法时间复杂度的表示法](http://www.zhihu.com/question/21387264)
- [Master theorem](http://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))
- [主定理](http://zh.wikipedia.org/wiki/主定理)

## 03-数组、链表、跳表的基本实现和特性

* [Java 源码分析（ArrayList）](http://developer.classpath.org/doc/java/util/ArrayList-source.html)

* [Linked List 的标准实现代码](http://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/)

* [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java)

* [Java 源码分析（LinkedList）](http://developer.classpath.org/doc/java/util/LinkedList-source.html)

* LRU Cache - Linked list：[ LRU 缓存机制](http://leetcode-cn.com/problems/lru-cache)

* Redis - Skip List：[跳跃表](http://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html)、[为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？](http://www.zhihu.com/question/20202931)

（升维思想+空间换时间）

### Array/LinkedList 实战

- https://leetcode-cn.com/problems/container-with-most-water/
- https://leetcode-cn.com/problems/move-zeroes/
- https://leetcode.com/problems/climbing-stairs/
- [https://leetcode-cn.com/problems/3sum/ ](https://leetcode-cn.com/problems/3sum/)(高频老题）

- https://leetcode.com/problems/reverse-linked-list/
- https://leetcode.com/problems/swap-nodes-in-pairs
- https://leetcode.com/problems/linked-list-cycle
- https://leetcode.com/problems/linked-list-cycle-ii
- https://leetcode.com/problems/reverse-nodes-in-k-group/

- https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/
- https://leetcode-cn.com/problems/rotate-array/
- https://leetcode-cn.com/problems/merge-two-sorted-lists/
- https://leetcode-cn.com/problems/merge-sorted-array/
- https://leetcode-cn.com/problems/two-sum/
- https://leetcode-cn.com/problems/move-zeroes/
- https://leetcode-cn.com/problems/plus-one/

## 04-栈和队列的实现与特性

- [Java 的 PriorityQueue 文档](http://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html)
- [Java 的 Stack 源码](http://developer.classpath.org/doc/java/util/Stack-source.html)
- [Java 的 Queue 源码](http://fuseyism.com/classpath/doc/java/util/Queue-source.html)
- [Python 的 heapq](http://docs.python.org/2/library/heapq.html)
- [高性能的 container 库](http://docs.python.org/2/library/collections.html)

- https://leetcode-cn.com/problems/valid-parentheses/
- https://leetcode-cn.com/problems/min-stack/

- https://leetcode-cn.com/problems/largest-rectangle-in-histogram
- https://leetcode-cn.com/problems/sliding-window-maximum

- https://leetcode.com/problems/design-circular-deque
- https://leetcode.com/problems/trapping-rain-water/

## 05-哈希表、映射、集合的实现与特性

- [Java Set 文档](http://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html)
- [Java Map 文档](http://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html)

- https://leetcode-cn.com/problems/valid-anagram/description/
- https://leetcode-cn.com/problems/group-anagrams/
- https://leetcode-cn.com/problems/two-sum/description/

- [养成收藏精选代码的习惯（示例）](http://shimo.im/docs/R6g9WJV89QkHrDhr)

## 06-树、二叉树、二叉搜索树

* [二叉搜索树 Demo](https://visualgo.net/zh/bst)

- https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
- https://leetcode-cn.com/problems/binary-tree-preorder-traversal/
- https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/
- [https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/description)
- https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/

## 07-泛型递归、树的递归

* [递归代码模板](http://shimo.im/docs/DjqqGCT3xqDYwPyY)
* [如何优雅地计算斐波那契数列](https://time.geekbang.org/dailylesson/detail/100028406)

- https://leetcode-cn.com/problems/climbing-stairs/
- https://leetcode-cn.com/problems/generate-parentheses/
- https://leetcode-cn.com/problems/invert-binary-tree/description/
- https://leetcode-cn.com/problems/validate-binary-search-tree
- https://leetcode-cn.com/problems/maximum-depth-of-binary-tree
- https://leetcode-cn.com/problems/minimum-depth-of-binary-tree
- https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

- https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
- https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
- https://leetcode-cn.com/problems/combinations/
- https://leetcode-cn.com/problems/permutations/
- https://leetcode-cn.com/problems/permutations-ii/

## 08-分治、回溯

- [分治代码模板](https://shimo.im/docs/3xvghYh3JJPKwdvt)
- [括号生成问题](https://leetcode-cn.com/problems/generate-parentheses/)

- [牛顿迭代法原理](http://www.matrix67.com/blog/archives/361)
- [牛顿迭代法代码](http://www.voidcn.com/article/p-eudisdmk-zm.html)

- https://leetcode-cn.com/problems/powx-n/
- https://leetcode-cn.com/problems/subsets/

- [https://leetcode-cn.com/problems/majority-element/description/ ](https://leetcode-cn.com/problems/majority-element/description/)（简单、但是高频）
- https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
- https://leetcode-cn.com/problems/n-queens/

## 09-深度优先搜索和广度优先搜索

* [DFS 代码模板（递归写法、非递归写法）](http://shimo.im/docs/ddgwCccJQKxkrcTq)
* [BFS 代码模板](http://shimo.im/docs/P8TqKHGKt3ytkYYd)

- https://leetcode-cn.com/problems/binary-tree-level-order-traversal/#/description
- https://leetcode-cn.com/problems/minimum-genetic-mutation/#/description
- https://leetcode-cn.com/problems/generate-parentheses/#/description
- https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description

- https://leetcode-cn.com/problems/word-ladder/description/
- https://leetcode-cn.com/problems/word-ladder-ii/description/
- https://leetcode-cn.com/problems/number-of-islands/
- https://leetcode-cn.com/problems/minesweeper/description/

## 10-贪心算法

- [coin change 题目](https://leetcode-cn.com/problems/coin-change/)
- [动态规划定义](https://zh.wikipedia.org/wiki/动态规划)

- https://leetcode-cn.com/problems/lemonade-change/description/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/
- https://leetcode-cn.com/problems/assign-cookies/description/
- https://leetcode-cn.com/problems/walking-robot-simulation/description/
- [https://leetcode-cn.com/problems/jump-game/ ](https://leetcode-cn.com/problems/jump-game/)、[ https://leetcode-cn.com/problems/jump-game-ii/](https://leetcode-cn.com/problems/jump-game-ii/)

## 11-二分查找

- [二分查找代码模板](https://shimo.im/docs/hjQqRQkGgwd9g36J)
- [Fast InvSqrt() 扩展阅读](https://www.beyond3d.com/content/articles/8/)

- https://leetcode-cn.com/problems/sqrtx/
- https://leetcode-cn.com/problems/valid-perfect-square/

- https://leetcode-cn.com/problems/search-in-rotated-sorted-array/
- https://leetcode-cn.com/problems/search-a-2d-matrix/
- https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/

## 12-动态规划

- [递归代码模板](http://shimo.im/docs/DjqqGCT3xqDYwPyY/)
- [分治代码模板](http://shimo.im/docs/3xvghYh3JJPKwdvt/)
- [动态规划定义](https://en.wikipedia.org/wiki/Dynamic_programming)
- [不同路径题目](https://leetcode-cn.com/problems/unique-paths/)
- [不同路径 2 题目](https://leetcode-cn.com/problems/unique-paths-ii/)
- [最长公共子序列题目](https://leetcode-cn.com/problems/longest-common-subsequence/)
- [MIT 动态规划课程最短路径算法](https://www.bilibili.com/video/av53233912?from=search&seid=2847395688604491997)

- https://leetcode-cn.com/problems/climbing-stairs/description/
- https://leetcode-cn.com/problems/triangle/description/
- https://leetcode.com/problems/triangle/discuss/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)
- https://leetcode-cn.com/problems/maximum-subarray/
- https://leetcode-cn.com/problems/maximum-product-subarray/description/
- [https://leetcode-cn.com/problems/coin-change/description/](https://leetcode.com/problems/coin-change/description/)

- https://leetcode-cn.com/problems/house-robber/
- https://leetcode-cn.com/problems/house-robber-ii/description/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/#/description
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/

### 高级 DP 实战题目

- https://leetcode-cn.com/problems/perfect-squares/
- [https://leetcode-cn.com/problems/edit-distance/ ](https://leetcode-cn.com/problems/edit-distance/)（重点）
- https://leetcode-cn.com/problems/jump-game/
- https://leetcode-cn.com/problems/jump-game-ii/
- https://leetcode-cn.com/problems/unique-paths/
- https://leetcode-cn.com/problems/unique-paths-ii/
- https://leetcode-cn.com/problems/unique-paths-iii/
- https://leetcode-cn.com/problems/coin-change/
- https://leetcode-cn.com/problems/coin-change-2/

### 课后作业

- https://leetcode-cn.com/problems/longest-valid-parentheses/
- https://leetcode-cn.com/problems/minimum-path-sum/
- https://leetcode-cn.com/problems/edit-distance/
- https://leetcode-cn.com/problems/decode-ways
- https://leetcode-cn.com/problems/maximal-square/
- https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/
- https://leetcode-cn.com/problems/frog-jump/
- https://leetcode-cn.com/problems/split-array-largest-sum
- https://leetcode-cn.com/problems/student-attendance-record-ii/
- https://leetcode-cn.com/problems/task-scheduler/
- https://leetcode-cn.com/problems/palindromic-substrings/
- https://leetcode-cn.com/problems/minimum-window-substring/
- https://leetcode-cn.com/problems/burst-balloons/

## 13-字典树和并查集

- [二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
- [实现 Trie](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/)
- [Tire 树代码模板](https://shimo.im/docs/Pk6vPY3HJ9hKkh33)
- [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)
- [并查集代码模板](https://shimo.im/docs/ydPCH33xDhK9YwWR)

- https://leetcode-cn.com/problems/implement-trie-prefix-tree/#/description
- https://leetcode-cn.com/problems/word-search-ii/

- https://leetcode-cn.com/problems/friend-circles
- https://leetcode-cn.com/problems/number-of-islands/
- https://leetcode-cn.com/problems/surrounded-regions/

## 14-高级搜索

### 剪枝

- [DFS 代码模板](http://shimo.im/docs/ddgwCccJQKxkrcTq/)
- [BFS 代码模板](http://shimo.im/docs/P8TqKHGKt3ytkYYd/)
- [AlphaZero Explained](https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/)
- [棋类复杂度](https://en.wikipedia.org/wiki/Game_complexity)

- https://leetcode-cn.com/problems/climbing-stairs/
- https://leetcode-cn.com/problems/generate-parentheses/
- [https://leetcode-cn.com/problems/n-queens](https://leetcode-cn.com/problems/n-queens/)
- https://leetcode-cn.com/problems/valid-sudoku/description/
- https://leetcode-cn.com/problems/sudoku-solver/#/description

### 双向BFS

- https://leetcode-cn.com/problems/word-ladder/
- https://leetcode-cn.com/problems/minimum-genetic-mutation/

### 启发式搜索

- [A* 代码模板](https://shimo.im/docs/CXvjHyWhpQcxXjcw/)
- [相似度测量方法](https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/)
- [二进制矩阵中的最短路径的      A* 解法](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python)
- [8 puzzles 解法比较](https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/)

- https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/
- https://leetcode-cn.com/problems/sliding-puzzle/
- https://leetcode-cn.com/problems/sudoku-solver/

## 15-红黑树和AVL树

- [平衡树](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)

## 16-位运算

- [如何从十进制转换为二进制](https://zh.wikihow.com/从十进制转换为二进制)

- [N 皇后位运算代码示例](https://shimo.im/docs/rHTyt8hcpT6D9Tj8/)

- https://leetcode-cn.com/problems/number-of-1-bits/
- https://leetcode-cn.com/problems/power-of-two/
- https://leetcode-cn.com/problems/reverse-bits/
- https://leetcode-cn.com/problems/n-queens/description/
- https://leetcode-cn.com/problems/n-queens-ii/description/
- https://leetcode-cn.com/problems/counting-bits/description/

## 17-布隆过滤器和LRU缓存

- [布隆过滤器的原理和实现](https://www.cnblogs.com/cpselvis/p/6265825.html)
- [使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重](https://blog.csdn.net/tianyaleixiaowu/article/details/74721877)
- [布隆过滤器 Python 代码示例](https://shimo.im/docs/xKwrcwrDxRv3QpKG/)
- [布隆过滤器 Python 实现示例](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/)
- [高性能布隆过滤器 Python 实现示例](https://github.com/jhgg/pybloof)
- [布隆过滤器 Java 实现示例      1](https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java)
- [布隆过滤器 Java 实现示例      2](https://github.com/Baqend/Orestes-Bloomfilter)

- [Understanding the Meltdown exploit](https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/)
- [替换算法总揽](https://en.wikipedia.org/wiki/Cache_replacement_policies)
- [LRU Cache Python 代码示例](https://shimo.im/docs/tTxRkGwJpXG6WkGY/)

- https://leetcode-cn.com/problems/lru-cache/#/

### 18-排序算法

- [十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)
- [快速排序代码示例](https://shimo.im/docs/98KjvGwwGpTpYGKy/)
- [归并排序代码示例](https://shimo.im/docs/YqgG6vtdKwkXJkWx/)
- [堆排序代码示例](https://shimo.im/docs/6kRVHRphpgjHgCtx/)

- [十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)
- [9 种经典排序算法可视化动画](https://www.bilibili.com/video/av25136272)
- [6 分钟看完 15 种排序算法动画展示](https://www.bilibili.com/video/av63851336)

- https://leetcode-cn.com/problems/relative-sort-array/
- https://leetcode-cn.com/problems/valid-anagram/
- https://leetcode-cn.com/problems/design-a-leaderboard/
- https://leetcode-cn.com/problems/merge-intervals/
- https://leetcode-cn.com/problems/reverse-pairs/

## 19-高级动态规划 

- [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
- [不同路径](https://leetcode-cn.com/problems/unique-paths/)
- [打家劫舍](https://leetcode-cn.com/problems/house-robber/)
- [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
- [股票买卖](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- [使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)
- [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- https://leetcode-cn.com/problems/longest-increasing-subsequence/
- https://leetcode-cn.com/problems/decode-ways/
- https://leetcode-cn.com/problems/longest-valid-parentheses/
- https://leetcode-cn.com/problems/maximal-rectangle/
- https://leetcode-cn.com/problems/distinct-subsequences/
- https://leetcode-cn.com/problems/race-car/

## 20-字符串算法

- [不可变字符串](https://lemire.me/blog/2017/07/07/are-your-strings-immutable/)
- [Atoi 代码示例](https://shimo.im/docs/KkDKkpWxjjrJXdpY/)

### 字符串基础问题

- https://leetcode-cn.com/problems/to-lower-case/
- https://leetcode-cn.com/problems/length-of-last-word/
- https://leetcode-cn.com/problems/jewels-and-stones/
- https://leetcode-cn.com/problems/first-unique-character-in-a-string/
- https://leetcode-cn.com/problems/string-to-integer-atoi/

### 字符串操作问题

- https://leetcode-cn.com/problems/longest-common-prefix/description/
- https://leetcode-cn.com/problems/reverse-string
- https://leetcode-cn.com/problems/reverse-string-ii/
- https://leetcode-cn.com/problems/reverse-words-in-a-string/
- https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/
- https://leetcode-cn.com/problems/reverse-only-letters/

### 异位词问题

- https://leetcode-cn.com/problems/valid-anagram/
- https://leetcode-cn.com/problems/group-anagrams/
- https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/

### 回文串问题

- https://leetcode-cn.com/problems/valid-palindrome/
- https://leetcode-cn.com/problems/valid-palindrome-ii/
- https://leetcode-cn.com/problems/longest-palindromic-substring/

### 最长子串、子序列问题

- https://leetcode-cn.com/problems/longest-common-subsequence/
- https://leetcode-cn.com/problems/edit-distance/
- https://leetcode-cn.com/problems/longest-palindromic-substring/

### 字符串 +DP 问题

- https://leetcode-cn.com/problems/regular-expression-matching/
- https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/
- https://leetcode-cn.com/problems/wildcard-matching/
- https://leetcode-cn.com/problems/distinct-subsequences/

### 其他

- [Boyer-Moore 算法](http://xn--https-ni33a/www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)
- [Sunday 算法](https://blog.csdn.net/u012505432/article/details/52210975)
- [字符串匹配暴力法代码示例](https://shimo.im/docs/dQDxQW8yXPXxh3Hg/)
- [Rabin-Karp 代码示例](https://shimo.im/docs/KXDdkT99TVtXvTXP/)
- [KMP 字符串匹配算法视频](https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171)
- [字符串匹配的KMP 算法](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)

- https://leetcode-cn.com/problems/first-unique-character-in-a-string/
- https://leetcode-cn.com/problems/string-to-integer-atoi/
- https://leetcode-cn.com/problems/reverse-string-ii/
- https://leetcode-cn.com/problems/reverse-words-in-a-string/
- https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/
- https://leetcode-cn.com/problems/reverse-only-letters/
- https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/
- https://leetcode-cn.com/problems/longest-palindromic-substring/
- https://leetcode-cn.com/problems/isomorphic-strings/
- https://leetcode-cn.com/problems/valid-palindrome-ii/
- https://leetcode-cn.com/problems/wildcard-matching
- https://leetcode-cn.com/problems/longest-valid-parentheses
- https://leetcode-cn.com/problems/distinct-subsequences/

# 模板

## 递归

```python
# Python
def recursion(level, param1, param2, ...):     
    # recursion terminator     
    if level > MAX_LEVEL: 	  
        # process_result 	   
        return     
    # process logic in current level     
    process(level, data...)     
    # drill down     
    self.recursion(level + 1, p1, ...)     
    # reverse the current level status if needed
```

```java
// Java
public void recur(int level, int param) {   
	// terminator   
    if (level > MAX_LEVEL) {     
        // process result     
        return;   
    }  
    // process current logic   
    process(level, param);   
    // drill down   
    recur(level: level + 1, newParam);   
    // restore current status 
```

```c
// C/C++
void recursion(int level, int param) {   
    // recursion terminator  
    if (level > MAX_LEVEL) {     
        // process result     
        return ;   
    }  
    // process current logic   
    process(level, param);  
    // drill down   
    recursion(level + 1, param);  
    // reverse the current level status if needed}
```

```javascript
// JavaScript
const recursion = (level, params) =>{   
    // recursion terminator   
    if(level > MAX_LEVEL) {     
        // process_result     
        return    
    }   
    // process current level   
    process(level, params)   
    //drill down   
    recursion(level+1, params)   
    //clean current level status if needed   
}
```

## 分治

```python
# Python
def divide_conquer(problem, param1, param2, ...): 
    # recursion terminator 
    if problem is None: 
        print_result 
        return 
	
    # prepare data 
    data = prepare_data(problem) 
    subproblems = split_problem(problem, data) 
 
    # conquer subproblems 
    subresult1 = self.divide_conquer(subproblems[0], p1, ...) 
    subresult2 = self.divide_conquer(subproblems[1], p1, ...) 
    subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
    # ... ...
    
    # process and generate the final result 
    result = process_result(subresult1, subresult2, subresult3, …)

    # revert the current level states
```

```c
// C/C++
int divide_conquer(Problem *problem, int params) {
 // recursion terminator
 if (problem == nullptr) {
  process_result
  return return_result;
 } 

 // process current problem
 subproblems = split_problem(problem, data)
 subresult1 = divide_conquer(subproblem[0], p1)
 subresult2 = divide_conquer(subproblem[1], p1)
 subresult3 = divide_conquer(subproblem[2], p1)
 ...

 // merge
 result = process_result(subresult1, subresult2, subresult3)
 
 // revert the current level status
 return 0;
}
```

```java
// Java
private static int divide_conquer(Problem problem, ) {
  if (problem == NULL) {
	int res = process_last_result();
	return res;     
  }

  subProblems = split_problem(problem)
  
  res0 = divide_conquer(subProblems[0])
  res1 = divide_conquer(subProblems[1])

  result = process_result(res0, res1);
  
  return result;
}
```

```javascript
// Javascript
const divide_conquer = (problem, params) => {
 // recursion terminator
 if (problem == null) {
  process_result
  return
 } 

 // process current problem
 subproblems = split_problem(problem, data)
 subresult1 = divide_conquer(subproblem[0], p1)
 subresult2 = divide_conquer(subproblem[1], p1)
 subresult3 = divide_conquer(subproblem[2], p1)
 ...

 // merge
 result = process_result(subresult1, subresult2, subresult3)
 // revert the current level status
}
```

## BFS

```python
# Python

def BFS(root):
    visited = set()
	queue = [] 
	queue.append([root]) 

    while queue: 
        node = queue.pop() 
        visited.add(node)
        
        process(node) 
        nodes = generate_related_nodes(node) 
        queue.push(nodes)

    # other processing work 
```

```java
// Java
public class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;
	TreeNode(int x) {
    	val = x;
	}
}

public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if (root == null) {
        return allResults;
    }

    Queue<TreeNode> nodes = new LinkedList<>();
    nodes.add(root);
    while (!nodes.isEmpty()) {
        int size = nodes.size();
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = nodes.poll();
            results.add(node.val);
            if (node.left != null) {
                nodes.add(node.left);
            }

            if (node.right != null) {
                nodes.add(node.right);
            }
        }
        allResults.add(results);
    }
    return allResults;
}
```

```c
// C/C++
void bfs(Node* root) {
 map<int, int> visited;
 if(!root) return ;
    
 queue<Node*> queueNode;
 queueNode.push(root);
    
 while (!queueNode.empty()) {
  Node* node = queueNode.top();
  queueNode.pop();
  if (visited.count(node->val)) continue;
  visited[node->val] = 1;
     
  for (int i = 0; i < node->children.size(); ++i) {
	queueNode.push(node->children[i]);
  }
 }
    
 return ;
}
```

```javascript
// JavaScript
const bfs = (root) => {
 let result = [], queue = [root]
 while (queue.length > 0) {
  let level = [], n = queue.length
  for (let i = 0; i < n; i++) {
   let node = queue.pop()
   level.push(node.val) 
   if (node.left) queue.unshift(node.left)
   if (node.right) queue.unshift(node.right)
  }
  result.push(level)
 }
 return result
};
```

## DFS

递归写法

```python
# python
visited = set()

def dfs(node, visited):    
    if node in visited: 
        # terminator    	
        # already visited     	
        return
    
    visited.add(node)   
    # process current node here.  
    ... 
    
    for next_node in node.children():  	
        if next_node not in visited:  		
            dfs(next_node, visited)
```

非递归写法

```python
def DFS(self, root):   
    if tree.root is None:  	
        return []   
    
    visited, stack = [], [root]  
    
    while stack:  	
        node = stack.pop()  	
        visited.add(node)  
        
        process (node)         
        # 生成相关的节点 	
        nodes = generate_related_nodes(node)  	
        stack.push(nodes)   
        
        # other processing work 
        ... ...
```

```c
//C/C++
//递归写法：
map<int, int> visited;

void dfs(Node* root) {
  // terminator
  if (!root) return ;

  if (visited.count(root->val)) {
    // already visited
    return ;
  }

  visited[root->val] = 1;

  // process current node here. 
  // ...
  for (int i = 0; i < root->children.size(); ++i) {
    dfs(root->children[i]);
  }
  return ;
}

//非递归写法：
void dfs(Node* root) {
  map<int, int> visited;
  if(!root) return ;

  stack<Node*> stackNode;
  stackNode.push(root);

  while (!stackNode.empty()) {
    Node* node = stackNode.top();
    stackNode.pop();
    if (visited.count(node->val)) continue;
    visited[node->val] = 1;


    for (int i = node->children.size() - 1; i >= 0; --i) {
        stackNode.push(node->children[i]);
    }
  }

  return ;
}
```

```javascript
	// Java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> allResults = new ArrayList<>();
        if(root==null){
            return allResults;
        }
        travel(root,0,allResults);
        return allResults;
    }

    private void travel(TreeNode root,int level,List<List<Integer>> results){
        if(results.size()==level){
            results.add(new ArrayList<>());
        }
        results.get(level).add(root.val);
        if(root.left!=null){
            travel(root.left,level+1,results);
        }
        if(root.right!=null){
            travel(root.right,level+1,results);
        }
    }
```

```javascript
// javascript
const visited = new Set()
const dfs = node => {
  if (visited.has(node)) return
  visited.add(node)
  dfs(node.left)
  dfs(node.right)
}
```

## 二分查找

```python
# Python
left, right = 0, len(array) - 1 
while left <= right: 
	mid = (left + right) / 2 
	if array[mid] == target: 
        # find the target!! 
        break or return result 
	elif array[mid] < target: 
		left = mid + 1 
	else: 
		right = mid - 1
```

```c
// C/C++
int binarySearch(const vector<int>& nums, int target) {
	int left = 0, right = (int)nums.size()-1;

    while (left <= right) {
        int mid = left + (right - left)/ 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
	return -1;
}
```

```java
// Java
public int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1, mid;
    
    while (left <= right) {
        mid = (right - left) / 2 + left;
        if (array[mid] == target) {
            return mid;
        } else if (array[mid] > target) {
     		right = mid - 1;
        } else {
     		left = mid + 1;
        }
    }
    return -1;
}
```

```javascript
// JavaScript
let left = 0, right = len(array) - 1

while (left <= right) {
 let mid = (left + right) >> 1
 if (array[mid] === target) { /*find the target*/; return }
 else if (array[mid] < target) left = mid + 1
 else right = mid - 1
}
```

