<!-- MarkdownTOC -->
- [如何理解“跳表”](#如何理解跳表)
- [跳表的时间复杂度与空间复杂度](#跳表的时间复杂度与空间复杂度)
  - [时间复杂度](#时间复杂度)
  - [空间复杂度](#空间复杂度)
- [插入、删除和更新操作](#插入删除和更新操作)
  - [插入和删除](#插入和删除)
  - [动态更新](#动态更新)
- [参考资料](#参考资料)

<!-- /MarkdownTOC -->

前面讲到，二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫作**跳表**（Skip list），跳表是一种各方面性能都比较优秀的**动态数据结构**，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树（Red-black tree）。

# 如何理解“跳表”

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021042617214755.png" width="600px"/>
</div>

那怎么来提高查找效率呢？如果像下图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作**索引**或**索引层**。图中的 down 表示 down 指针，指向下一级结点。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426172235848.png" width="600px"/>
</div>

如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。

从这里可以看出来，**加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了**。那如果我们再加一级索引呢？效率会不会提升更多呢？

跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426172435351.png" width="600px"/>
</div>

从上面案例来看，提升的效率并不明显，本来需要遍历8个元素，优化了半天，还需要遍历 4 个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 ... 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，**从而使得链表能够实现二分查找**。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426172726240.png" width="750px"/>
</div>
# 跳表的时间复杂度与空间复杂度

## 时间复杂度

先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？

按照上面所讲，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，**第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k^)**。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2^h^)=2，从而求得 h=log~2~n-1。如果包含原始链表这一层，整个跳表的高度就是 log~2~n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。

按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3。为什么是3呢？

假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426185453446.png" width="600px"/>
</div>

通过上面的分析，我们得到 m=3，所以在**跳表中查询任意数据的时间复杂度就是 O(logn)**。

## 空间复杂度

比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。

跳表的空间复杂度分析并不难，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。

```shell
原始链表大小为n,每两个节点抽1个,每层索引的结点数：
n/2, n/4, n/8, ..., 8, 4, 2
```

这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，**跳表的空间复杂度是 O(n)**。就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。那我们有没有办法降低索引占用的内存空间呢？

前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426185840283.png" width="600px"/>
</div>

从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。

```shell
原始链表大小为n,每三个节点抽1个,每层索引的结点数：
n/3, n/9, n/27, ..., 9, 3, 1
```

通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。

# 插入、删除和更新操作

## 插入和删除

实际上，跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且**插入、删除操作的时间复杂度也是 O(logn)**。

在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。

对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/202104261902354.png" width="600px"/>
</div>

我们再来看删除操作。如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。

## 动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426190446608.png" width="500px"/>
</div>

作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。**跳表是通过随机函数来维护前面提到的“平衡性”**。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210426190637192.png" width="600px"/>
</div>

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。至于随机函数的选择，可以看实现跳表的代码——[SkipList](https://github.com/zgkaii/algorithms/blob/main/DataStructrue/list/SkipList.java)。

------

**问题**：为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

**解答**：Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。查看 Redis 的开发手册就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：

- 插入一个数据；
- 删除一个数据；
- 查找一个数据；
- 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；
- 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果想使用跳表就必须要自己实现。

# 参考资料

* [https://www.jianshu.com/p/9d8296562806](https://www.jianshu.com/p/9d8296562806)
* [https://github.com/wangzheng0822/algo](https://github.com/wangzheng0822/algo)