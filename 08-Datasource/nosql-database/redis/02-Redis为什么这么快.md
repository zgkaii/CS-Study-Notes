<!-- MarkdownTOC -->
- [底层数据结构](#底层数据结构)
  - [全局哈希表](#全局哈希表)
  - [解决哈希冲突](#解决哈希冲突)
  - [压缩列表与跳表](#压缩列表与跳表)
  - [不同数据结构的时间复杂度](#不同数据结构的时间复杂度)
- [单线程的Redis为什么这么快](#单线程的redis为什么这么快)
  - [Redis为什么用单线程](#redis为什么用单线程)
  - [Redis为什么这么快](#redis为什么这么快)
- [总结](#总结)

<!-- /MarkdownTOC -->

# 底层数据结构

Redis为何如此突出呢？一方面是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快；另一方面，这要归功于它的高效的数据结构。

Redis数据保存方式（即键值对中值）主要有String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）几种类型，这些数据结构的底层数据结构可以由**简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组**实现。

<div align="center"> <img src="..\..\images\redis\Redis底层数据结构.jpg" width="600px"></div>

可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是一**个键对应了一个集合的数据**。

## 全局哈希表

Redis使用了一个哈希表来保存所有的键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中元素保存的并不是值本身，而是指向具体值的指针。

在下图中，可以看到，哈希桶中的 entry 元素中保存了`*key`和`*value`指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过`*value`指针被查找到。

<div align="center"> <img src="..\..\images\redis\全局哈希表.jpg" width="600px"></div>

因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。

## 解决哈希冲突

当你往哈希表中写入数据越多，两个 key 的哈希值和哈希桶计算对应关系时落在了同一个哈希桶中，这就是所谓的**哈希冲突**。

**解决方法：链式哈希**

链式哈希就是指**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。

跟Java中HashMap存储类似，哈希冲突的entry通过next指针指向下一个entry，即使哈希桶  中的元素有 100 个，我们也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。

> **产生问题**：哈希冲突链上的元素只能通过指针逐一查找再操作，元素越多查询越慢。

**继续解决：rehash**

rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

* 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
* 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
* 释放哈希表 1 的空间。

> **产生问题**：涉及大量数据拷贝，一次性拷贝完容易造成线程阻塞。

**继续解决：渐进式 rehash**

渐进式 rehash把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

<div align="center"> <img src="..\..\images\redis\渐进式rehash.jpg" width="600px"></div>

> 渐进式rehash执行时，除了根据键值对的操作来进行数据迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地（例如每100ms一次）搬移一些数据到新的哈希表中，这样可以缩短整个rehash的过程。

## 压缩列表与跳表

**压缩列表**

压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

<div align="center"> <img src="..\..\images\redis\压缩列表.jpg" width="600px"></div>

查找定位第一个元素和最后一个元素，可通过表头三个字段的长度直接定位，复杂度是 O(1)；查找其他元素时，复杂度就是 O(N) 。

**跳表**

跳表在链表的基础上，**增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位**。

<div align="center"> <img src="..\..\images\redis\跳表.jpg" width="700px"></div>

例如查询33这个元素：

* 传统链表查询，时间复杂度O(N)：从头开始遍历，需要6次查询；
* 增加一级索引：每两个元素选一个出来作为索引，只需要 4 次查找。
* 增加二级索引：从一级索引中，再抽取部分元素作为二级索引，只需要 3 次查找。

## 不同数据结构的时间复杂度

底层数据结构的时间复杂度如下表：

| 名称     | 时间复杂度 |
| -------- | ---------- |
| 哈希表   | O(1)       |
| 跳表     | O(logN)    |
| 双向链表 | O(N)       |
| 压缩列表 | O(N)       |
| 整数数组 | O(N)       |

集合常见操作的复杂度可总结为：

* **单元素操作基本为O(1)**，指每一种集合类型对单个数据实现的增删改查操作。
  * Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。
* **范围操作一般为O(N)**，指集合类型中的遍历操作，可以返回集合中的所有数据。
  * 比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。
* **统计操作只有O(1)**，指集合类型对集合中所有元素个数的记录。
  * 例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。
* **例外情况为O(1)**，指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。
  * 对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

------

**引出问题**：整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

**解答**：（1）内存利用率：整数数组和压缩列表内存利用紧凑，比链表占用内存小。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。（2）数组对CPU高速缓存支持更友好。Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。

# 单线程的Redis为什么这么快

**Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程**。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

## Redis为什么用单线程

的确，对于一个系统而言，在在有合理的资源分配的情况下，可以尝试增加线程数量，进而增加系统吞吐率，或是可以增加系统扩展性。但是，当增加线程在一定数量时，系统吞吐率可能会增长迟缓了，有时甚至还会出现下降的情况。

**本质原因**：这是一个线程编程模式面临的共享资源的并发访问控制问题。系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。为了保证共享资源的正确性，就需要额外的机制进行保证。例如只是简单地采用一个粗粒度互斥锁，即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。

采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。

## Redis为什么这么快

一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是 Redis 采用了**多路复用机制**，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

**基本 IO 模型与阻塞点**

以 Get 请求为例，SimpleKV 为了处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。

<div align="center"> <img src="..\..\images\redis\基本IO模型.jpg" width="600px"></div>

这里潜在的阻塞点分别是 accept() 和 recv()。不过，socket 网络模型本身支持非阻塞模式。

Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上：

| 调用方法 | 返回套接类型 | 非阻塞模式 | 效果                |
| -------- | ------------ | ---------- | ------------------- |
| socket() | 主动套接字   |            |                     |
| listen() | 监听套接字   | 可设置     | accept()非阻塞      |
| accept() | 已连接套接字 | 可设置     | send()/recv()非阻塞 |

针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() （已经存在监听套接字）但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待，但是有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

类似的，可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。但有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。

**基于多路复用的高性能 I/O 模型**

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，**同时存在多个监听套接字和已连接套接字**。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

下图就是基于多路复用的 Redis IO 模型。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。

<div align="center"> <img src="..\..\images\redis\多路复用.jpg" width="600px"></div>

> FD——多个套接字

为了在请求到达时能通知到 Redis 线程，select/epoll 提供**了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数**。

* select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。
* 事件会放进事件队列，Redis 单线程对该事件队列不断进行处理（避免轮询，避免CPU资源浪费）。同时，事件队列中的事件处理时，调用相应的处理函数，实现了基于事件的回调。

# 总结

Redis是单线程指的是它处理网络IO和键值对读写是由一个线程完成的，之所以用单线程的核心原因是为了避免多线程编程的并发控制问题。Redis单线程也能保持性能跟其多路复用IO模型密切相关，因为这避免了accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。

除此之外，Redis在于其大部分操作都在内存上完成，内存的访问速度本身就很快；同时，它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。

Redis使用一个全局哈希表来存在键值对数据，全局哈希表的哈希桶中存放的指向具体值的指针。为了避免哈希冲突，Redis采用渐进性rehash的方式，提高了键值对的数据迁移效率。

Redis键值对中值存放类型主要有String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）五种，它们对应的底层数据结构如下：

| 数据类型   | 底层数据结构       |
| ---------- | ------------------ |
| String     | 简单动态字符串     |
| List       | 双向链表、压缩列表 |
| Hash       | 压缩列表、哈希表   |
| Sorted Set | 压缩列表、跳表     |
| Set        | 哈希表、整数数组   |