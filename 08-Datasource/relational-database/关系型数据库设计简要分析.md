<!-- MarkdownTOC -->
- [如何进行数据库设计？](#如何进行数据库设计)
  - [什么是数据库？](#什么是数据库)
    - [DB、DBMS、DBA、DBS区别与联系？](#dbdbmsdbadbs区别与联系)
    - [DBMS分类？关系型与非关系型？](#dbms分类关系型与非关系型)
    - [SQL作用？](#sql作用)
  - [数据库设计的是什么？](#数据库设计的是什么)
  - [数据库设计步骤？](#数据库设计步骤)
- [什么是设计范式？](#什么是设计范式)
  - [关系型数据库基础概念](#关系型数据库基础概念)
  - [函数依赖关系](#函数依赖关系)
  - [常见设计范式](#常见设计范式)
    - [1NF](#1nf)
    - [2NF](#2nf)
    - [3NF](#3nf)
    - [BCNF](#bcnf)
- [什么是ER模型图？](#什么是er模型图)
- [案例分析](#案例分析)
  - [需求分析](#需求分析)
  - [概念设计](#概念设计)
  - [逻辑设计](#逻辑设计)
  - [物理设计](#物理设计)
  - [数据库实现](#数据库实现)
  - [维护和优化](#维护和优化)
- [总结](#总结)
- [参考资料](#参考资料)

<!-- /MarkdownTOC -->

# 如何进行数据库设计？

## 什么是数据库？

### DB、DBMS、DBA、DBS区别与联系？

**数据库**（Database，简称**DB**）是存储数据的集合。而**数据库管理系统**（Database Management System，简称**DBMS**）是一种操纵和管理数据库的软件系统，通常用于建立、使用和维护数据库。

还有两个主要的概念：

* **数据库管理员**（Database Administrator，简称**DBA**）负责全面管理和控制数据库系统。

* **数据库系统**（Database System，简称**DBS**）由硬件和软件共同构成。硬件主要用于存储数据库中的数据，包括计算机、存储设备等。软件部分主要包括数据库管理系统、支持数据库管理系统运行的操作系统，以及支持多种语言进行应用开发的访问技术等。也就是说，数据库系统包含了**数据库**和**数据库管理系统**和**数据库管理人员**。

数据库系统基本构成如下图所示：

<div align="center">  
<img src="https://images.xiaozhuanlan.com/photo/2019/eb713d4b4df6193ce4c5fcaea8678708.jpg" width="600px"/>
</div>

### DBMS分类？关系型与非关系型？

> 首先声明，我们常说的xxx数据库实际指的是xxx数据管理系统。

数据库主要有两种类型，分别是关系型数据库和非关系型数据库。

* **关系型数据库**是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。简单说，关系型数据库是由多张能互相连接的表组成的数据库。

* **非关系型数据库**又被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。

关系型数据库与非关系型数据库对比如下：

| 数据库对比               | 关系型数据库                                                 | 非关系型数据库                                               |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据表VS.数据集          | 使用表存储相关数据。                                         | 使用类JSON格式的文档存储键值对。                             |
| 预定义结构VS.动态结构    | 使用表之前需要定义表的结构（列）。                           | 不需要特定结构。                                             |
| 存储规范化VS存储代价     | 鼓励使用规范化来减少数据的冗余。                             | 使用非规范化的标准存储信息，以保证一个文档中包含一个条目的所以信息。 |
| 结构化查询VS非结构化查询 | 结构化查询语言来操作数据（SQL）。                            | 以块(像文档一样)为单元操纵数据（UnQL）                       |
| 映射VS本地化             | 数据需要规范化映射进数据库，通常使用ORM框架解决。            | 复杂数据实体可以整体存放在独立单元中。                       |
| 事务性VS纯扩展性         | 支持对事务原子性细粒度控制，并且易于回滚事务。               | 可以使用事务操作，但真正的价值是在在操作的扩展性和大数据量处理方面。 |
| ACID VS CAP              | ACID属性(原子性，一致性，隔离性，持久性)保证数据完整性。     | CAP(一致性，可用性，分区容忍度)中的任意两项中选择。          |
| 数据VS大数据             | 可靠地存储和处理数据。                                       | 横向扩展潜力是无限的，是处理大数据捕获、管理、检索、分析和可视化的唯一有效途径。 |
| 内部部署VS云计算         | 通常是以服务形式提供的，是可复制、高可用性且分布式的，极大地提高了横向扩展能力。 | 天然享有自动分片的好处，可以阶段性地灵活弹性处理，集成高速缓存和巨大的计算能力来捕获、存储和分析大数据。 |
| 付费VS开源               | SQL数据库大多数比较昂贵。                                    | NoSQL数据库通常都是开源的。                                  |

> 参考：https://www.cnblogs.com/wanghongyun/p/6193912.html

常见的关系数据库有：  Oracle、MySQL/MariaDB、SQL Server、PostgreSQL、DB2

常见的NoSQL数据库有：

| 类别        | 主要使用                                                                                 | 说明                                                                                                                                                                 |
| ----------- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 时序数据库  | InfluxDB、RRDtool、Graphite、OpcnTSDB、Kdb+  InfluxDB、RRDtool、Graphite、OpcnTSDB、Kdb+ | 存储时间序列数据，每条记录都带有时间戳。如存储从感应器采集到的数据存储时间序列数据，每条记录都带有时间戳。如存储从感应器采集到的数据。                               |
| 键/值数据库 | Redis、Memcached<br/>Riak KV、Hazelcast、Ehcache                                         | 遵循“键——值”模型，是最简单的数据库管理系统。                                                                                                                         |
| 文档数据库  | MongoDB、Couchbase、Amazon DynamoDB、CouchDB、MarkLogic                                  | 无固定结构，不同的记录允许有不同的列数和列类型。列允许包含多值，记录允许嵌套。                                                                                       |
| 图数椐库    | Neo4j、OrientDB、Titan、Virtuoso、ArangoDB                                               | 以“点——边”组成的网络（图结构）来存储数据。                                                                                                                           |
| 搜索引擎    | Elasticsearch、Solr、Splunk、MarkLogic、Sphinx                                           | 存储的目的是为了搜索，主要功能是搜索。                                                                                                                               |
| 对象数据库  | Caché、db4o、Versant Object Database、ObjcctStore、Matisse                               | 受面向对象编程语言的启发，把数据定义为对象并存储在数据库中，包括对象之问的关系，如继承。                                                                             |
| 宽列数据库  | Cassandra、HBase、Accumulo                                                               | 按照列（由“键——值”对组成的列表）在数据文件中记录数据，以获得更好的请求及遍历效率。一行中的列数允许动态变化，且列的数目可达数百万，每条记录的关键码不同，支持多值列。 |

> 数据库使用排名：https://db-engines.com/en/ranking

### SQL作用？

SQL 是一种关系型数据库结构化查询语言，用于存取数据以及查询、更新和管理关系数据库系统。结构化查询语言包含6个部分：

* 数据查询语言（**DQL**: Data Query Language）：其语句，也称为“数据检索语句”，用以从表中获得数据，确 定数据怎样在应用程序给出。保留字 SELECT 是 DQL（也是所有 SQL）用得最多的动词，其他 DQL 常用的保留字 有 WHERE，ORDER BY，GROUP BY 和 HAVING。这些 DQL 保留字常与其它类型的 SQL 语句一起使用。
* 数据操作语言（**DML**：Data Manipulation Language）：是指对数据库中表记录的操作，其语句包括动词 INSERT、UPDATE 和 DELETE。它们分别用于添加、修改和删除，是开发人员日常使用最频繁的操作。
* 事务控制语言（TCL）：它的语句能确保被 DML 语句影响的表的所有行及时得以更新。包括COMMIT（提交） 命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。
* 数据控制语言（DCL）：它的语句通过 GRANT 或 REVOKE 实现权限控制，确定单个用户和用户组对数据库对象 的访问。某些 RDBMS 可用 GRANT 或 REVOKE 控制对表单个列的访问。 
* 数据定义语言（**DDL**：Data Definition Language）：对数据库内部的对象进行创建、删除、修改的操作语言，其语句包括动词 CREATE，ALTER 和 DROP。在数据库中创建新表或修改、删除表 （CREAT TABLE 或 DROP TABLE）和为表加入索引等。 DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。
* 指针控制语言（CCL）：它的语句，像 DECLARE CURSOR，FETCH INTO 和 UPDATE WHERE CURRENT 用于对 一个或多个表单独行的操作。

## 数据库设计的是什么？

数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS（数据库管理系统），为这个业务系统构造出最优的数据存储模型，并建立数据库中的表结构以及表与表之间的关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已存储的数据进行访问。

| 优良的设计                                 | 糟糕的设计                         |
| ------------------------------------------ | ---------------------------------- |
| 减少数据维护异常                           | 存在数据插入、更新、删除异常       |
| 减少数据冗余，节省存储空间，便于进一步扩展 | 存在大量数据冗余，浪费大量存储空间 |
| 高效的访问                                 | 访问数据低效                       |

## 数据库设计步骤？

《数据库系统设计、实现与管理》一书描述到，数据库系统开发生命周期大致可以分为以下几个阶段:

```java
数据库规划 --> 系统定义 --> 需求收集与分析 --> 数据库设计 --> DBMS选项 --> 应用程序设计 --> 
建立原型系统（可优化）   --> 实现   --> 数据转换与加载  --> 测试  --> 运行维护
```

简化一下，大致可以分为如下几个步骤：

1. **需求分析**：数据是什么，数据具有哪些属性，数据与属性的特点是什么。
2. **概念设计**：建立**ER模型**。
3. **逻辑设计**：按ER图按照一定规则转换为关系模型，关系模式的规范化和优化（应用**设计范式**）。
4. **物理设计**：给数据模型设计一个合理的物理结构，比如数据存取结构（如数据库管理系统的选择）。
5. **数据库实现**：数据定义语言DDL创建数据库，数据入库。
6. **维护和优化**：对数据库进行监测、评估、调整、备份和修改（如建表、索引优化、大表拆分）。

# 什么是设计范式？

什么是数据库设计范式？——也就是提供了一种准则，帮助我们建立简介高效且结构清晰的数据库设计，避免数据库插入、更新、删除、修改中的异常，并且为最大限度的避免数据库的冗余。在了解设计范式之前，我们先来看一些基本概念。

## 关系型数据库基础概念

- **元组** ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- **码** ：码就是能唯一标识实体的属性，对应表中的列。
- **候选码** ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- **主码** : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- **外码** : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- **主属性** ：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）。显然工号和身份证号都能够唯一标识这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- **非主属性：** 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

这里可以看出主键和外键区别：

- **主键(主码)** ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
- **外键(外码)** ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

## 函数依赖关系

* **函数依赖（functional dependency）** ：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作` X → Y`。
  * （学号）->（姓名）/（学号，课名）->（分数）/（系名）->（系主任）。

* **部分函数依赖（partial functional dependency）** ：如果`X→Y`，并且存在X的一个真子集`X0`，使得`X0→Y`，则称`Y`对`X`部分函数依赖。
  * （学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名），所以姓名部分函数依赖与（学号，身份证号）。

* **完全函数依赖(Full functional dependency)** ：如果`X→Y`，并且任何X的真子集`X‘`，都不能满足`X’→Y`，则称`Y`对`X`完全函数依赖。**完全函数依赖必须要通过码中的所有属性才可以唯一确定一个值，而部分函数依赖只需要码中的部分属性即可**。
  * （学号，课名）->（分数），但是（学号）->（分数）不成立，（课名）->（分数）不成立，所以分数完全函数依赖与（学号，课名）。

* **传递函数依赖** ： 设X，Y，Z是U的不同的属性子集，如果 Z -> Y，Y -> X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X，（X∪Y）∩Z=空集合。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。
  * （学号，姓名，系名，系主任）中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。

## 常见设计范式

关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式/巴斯范式（BCNF）、第四范式（4NF）和第五范式（5NF）。 满足最低要求的范式是第一范式（1NF）。 在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。越高的范式数据库的冗余度就越低。

但并不是说遵循的范式等级越高越好，范式过高虽然具有对数据关系有更好的约束性，但是也会导致表之间的关系更加繁琐，从而导致每次操作的表会变多，数据库性能下降。

通常设计中，**最高也就遵循到 BCNF，普遍还是 3NF**。

### 1NF

关系 R 属于第一范式，当且仅当 R 中的每一个属性 A 的值域只包含原子项。直白地讲，**数据库中的所有字段都是单一属性，不可再分的，每个列都是原子的**。这个单一属性由基本数据类型所构成，例如整数、浮点数、字符串等。

例如下面的表，就明显违反了`1 NF`。

| 学号   | 姓名     | 班级 | 系名   | 系主任 | 课程               |
| ------ | -------- | ---- | ------ | ------ | ------------------ |
| 123456 | zhangsan | 2班  | 超人系 | xxx    | 如何拯救地球，80分 |

### 2NF

1NF 只是设计数据库最基本的要求，但是数据会存在大量的冗余，例如选课表：

| 学号   | 姓名     | 班级 | 系名   | 系主任 | 课程         | 分数 |
| ------ | -------- | ---- | ------ | ------ | ------------ | ---- |
| 123456 | zhangsan | 2班  | 超人系 | xxx    | 如何拯救地球 | 80   |

**2NF 在 1NF 的基础上，消除了非主属性对码的部分函数依赖** 。判断是否符合 2NF 可以通过以下步骤：

* 找出表中所有的**码（候选码）**：（学号、课程）
* 根据第一步得出的码找出所有的**主属性**：（学号、课程）
* 除了主属性之外的其他属性，就都是**非主属性**：（姓名、系名、系主任、班级、分数）
* 判断是否存在非主属性**部分函数依赖**于码。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/202106262345210.png" width="600px"/>
</div>

- （学号，课名）->（姓名），存在（学号）->（姓名），存在非主属性**姓名**部分函数依赖于码。
- （学号，课名）->（系名），存在（学号）->（系名），存在非主属性**系名**部分函数依赖于码。
- ……

消除部分依赖，表中没有列只与主键的部分相关，即每一行都被主键唯一标识。每个表都有主键。上表可以拆分成下面两个表：

选课表：

| 学号   | 课程         | 分数 |
| ------ | ------------ | ---- |
| 123456 | 如何拯救地球 | 80   |

学生表：

| 学号   | 姓名     | 班级 | 系名   | 系主任 |
| ------ | -------- | ---- | ------ | ------ |
| 123456 | zhangsan | 2班  | 超人系 | xxx    |

可以看到，选课表中只有一个码（学号、课程）与非主属性，不存在部分函数依赖。学生表中也只存在一个码（学号），非主属性（姓名，系名，系主任，班级），也不存在部分函数依赖。

### 3NF

**3NF 就是在 2NF 的基础上，消除非主属性对码的传递函数依赖**。分析上面学生表中的函数依赖关系：

1. 找出学生表中的码：（学号）
2. 主属性：学号
3. 非主属性：（姓名，系名，系主任，分数）
4. 学号与系主任之间存在传递函数依赖（学号确定系名，系名确定系主任，学号不能确定系主任）。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210626235355455.png" width="600px"/>
</div>

消除传递函数依赖，需要消除表中列不依赖主键而依赖表中的非主键列的情况，即没有列是与主键不相关的。 从表只引用主表的主键， 即表中每列都和主键相关。

学生表：

| 学号   | 姓名     | 班级 |
| ------ | -------- | ---- |
| 123456 | zhangsan | 2班  |

系名：

| 系名   | 系主任 |
| ------ | ------ |
| 超人系 | xxx    |

### BCNF

BCNF消除**主属性**对于码的部分函数依赖和传递函数依赖（前面的 2NF、3NF都是**非主属性**对码的部分函数依赖和传递函数依赖）。

例如下例，假设供应商联系只能受雇于一家供应商，每个供应商可以供应多个商品：

| 供应商 | 商品ID | 供应商联系人 | 商品数量 |
| ------ | ------ | ------------ | -------- |
| 冰工厂 | 123456 | 张三         | 10       |

分析上表中的函数依赖关系：

1. 码：（供应商，商品ID）（供应商联系人，商品ID）
2. 主属性：供应商，商品ID、供应商联系人
3. 非主属性：数量

非主属性只有数量，不存在对码的部分函数依赖和传递函数依赖，符合2NF/3NF。但主属性存在对码的部分函数依赖：

* （供应商，商品ID）-> 供应商联系人；（供应商联系人，商品ID）-> 供应商。

那么将该表进行拆分才能让供应商符合 BCNF。将该表拆分为两个表：商品表和供应商表。

商品表：

| 供应商 | 商品ID | 商品数量 |
| ------ | ------ | -------- |
| 冰工厂 | 123456 | 10       |

供应商表：

| 供应商 | 供应商联系人 |
| ------ | ------------ |
| 冰工厂 | 张三         |

> **4NF**：消除非平凡的多值依赖 ；**5NF**：消除一些不合适的连接依赖
>
> 4NF与5NF使用不多，不做分析。

# 什么是ER模型图？

**ER图**也称实体-联系图（Entity Relationship Diagram），提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法，是表示概念关系模型的一种方式。

**表示方法**

实体型：用矩形框，矩形框内写明实体名。

属性：用椭圆型表示，并用无向边将其与相应的实体连接起来。（可以连实体，也可以连联系）。

联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁边标上联系的类型。

数量：一对一（1:1），一对多（1：n），多对多（m:n）。

**实例演示**

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201214235342989.png" width="600px"/>
</div>

> 注：有的属性下面有下划线，就表示主键。

# 案例分析

以一个小型的电子商务网站为例，在这个电子商务网站的系统中包括了几个核心模块：用户模块，商品模块，订单模块，购物车模块，供应商模块，问如何设计一个简单的关系型数据库。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201214233227760.png" width="600px"/>
</div>

## 需求分析

需求分析要搞清楚的一些问题：实体及实体之间的关系（1对1，1对多，多对多）？实体所包含的属性有什么？属性有很多，哪些属性是可以标识出这个实体的？哪些属性或属性的组合可以唯一标识一个实体？存储上有什么特性，增长量是什么样？数据的时效性，生命周期呢？


* 用户模块：用于记录注册用户信息
  属性：用户id，用户昵称，密码，电话，邮箱，性别，生日，收获地址.....

  可唯一标识属性：用户id，电话

  存储特点：随系统上线时间的增长，需要永久存储

* 商品模块：用于记录网站中所销售的商品信息
  属性：商品id，类别编号，商品名称，商品描述，商品品类，供货商名称，重量，有效期，价格......

  可唯一标识属性：商品id

  存储特点：对于下线商品可以归档存储（不能直接删除，可能跟订单有关）

* 订单模块：用于用户订购商品的信息
  属性：订单id，用户id，实际付款金额，支付类型，运费，商品名称，数量，价格，订单状态，支付状态.....

  可唯一标识属性：订单id

  存储特点：永久存储（分表，分库存储）

* 购物车模块：用于保存用户购物时选的商品
  属性：购物车id，用户id，商品编号，商品数量，加入时间......
  可唯一标识属性：购物车id

  存储特点：不用永久存储（设置归档，清理规则）

* 供应商模块：用于保存供应商信息
  属性：供应商id，供应商名称，供应商注册号，联系人，电话，商品id.....

  可唯一标识属性：供应商id，供应商注册号

  存储特点：永久存储

## 概念设计

这里采用E-R图表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210627002914870.png" width="1000px"/>
</div>
## 逻辑设计

以商品模块为例，主要属性有：商品ID，商品名称，商品描述，商品品类，供货商名称，上架OR下架，有效期，价格，商品存储地址......比如我们最终要用2 NF。

先按照1 NF设计，商品表：

| 商品ID | 商品名称 | 品牌ID | 商品描述 | 供货商 | 商品图片 | 仓库ID | 剩余数量 | 商品价格 | 图片ID | ... ... |
| ------ | -------- | ------ | -------- | ------ | -------- | ------ | -------- | -------- | ------ | ------- |
| xxx    | xxx      | xxx    | xxx      | xxx    | xxx      | xxx    | xxx      | xxx      | xxx    | ... ... |

2 NF 在 1NF 的基础上，需要消除非主属性对码的部分函数依赖。分析上面表中的函数依赖关系：

1. 找出表中的码：（商品ID，供应商ID，仓库ID，商品ID，图片ID）
2. 主属性：商品ID，供应商ID，仓库ID，商品ID，图片ID
3. 非主属性：（商品名称，商品品牌，商品描述，供货商 ，商品图片，存储仓库，剩余数量 ，商品价格... ...）
4. 存在太多的部分函数依赖了。比如（商品ID，供应商ID，仓库ID，商品ID，图片ID）-> （商品名称），（商品ID）-> （商品名称），存在非主属性**商品名称**部分函数依赖于码。

可以把商品表简单拆分成上面ER图中的5个表。

## 物理设计

**(1) 选择数据库管理系统（应用特点和成本）**

常见的DBMS系统：

* 开源：MySQL、PostgreSQL
* 商业：Oracle，DB2，SQL Server
* 内存数据库：Redis？，VoltDB
* 图数据库：Neo4j，Nebula
* 时序数据库：InfluxDB、openTSDB
* ... ...

如果采用MySQL，常用MySQL数据库存储引擎选择：

| 功 能        | MYISAM | Memory | InnoDB | Archive |
| :----------- | :----- | :----- | :----- | :------ |
| 存储限制     | 256TB  | RAM    | 64TB   | None    |
| 支持事务     | No     | No     | Yes    | No      |
| 支持全文索引 | Yes    | No     | No     | No      |
| 支持树索引   | Yes    | Yes    | Yes    | No      |
| 支持哈希索引 | No     | Yes    | No     | No      |
| 支持数据缓存 | No     | N/A    | Yes    | No      |
| 支持外键     | No     | No     | Yes    | No      |

* 如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现MVCC并发控制，InnoDB是一个好的选择。
* 如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率。
* 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。
* 如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive。

那么我们这里默认采用InnoDB引擎。

**(2) 定义数据库、表以及字段的命名规范（不同数据库对命名的规范是有差异的）**

* 可读性规则：使用大写和小写来格式化的库对象名字以获得良好的可读性。
* 表意性原则：对象的名字应该能够描述它所标识的对象。
* 长命原则：尽量少使用或者不使用缩写。

**(3) 根据所选的DBMS系统选择合适的字段类型**

列的数据类型一方面影响数据存储空间的开销，另一方面也会影像数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑INT数据类型，其次时日期或二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。

| 列类型     | 存储空间                     |
| ---------- | ---------------------------- |
| TINYINT    | 1 字节                       |
| SMALLINT   | 3 字节                       |
| MEDIUMINT  | 3 字节                       |
| INT        | 4 字节                       |
| BIGGINT    | 8 字节                       |
| DATE       | 3 字节                       |
| DATETIME   | 8 字节                       |
| TIMESTAMP  | 4 字节                       |
| CHAR(M)    | M 字节，1<=M<=255            |
| VARCHER(M) | L+1字节，其中L<=M和1<=M<=255 |

**char与varchar**

* 如果列中要存储的数据长度差不多是一致的，则优先选择char。

* 列中最大数据长度小于50byte，则一般考虑使用char。

**decimal与float**

* decimal主要用于存储数据比float要精确。

* float占用空间较小，当数据要求不精确优先选择。

**时间类型**

比如，同样存储日期`1978-03-01`，有以下几种存储方式：

| 类型       | 数据           |
| ---------- | -------------- |
| char(10)   | `'1978-03-01'` |
| vachar(10) | `'1978-03-01'` |
| datetime   | `1978-03-01`   |
| int        | `257529600`    |

那么int > datetime > char(10) > vachar(10)，int最优。以上选用主要从两个角度考虑：

* 同样的数据，字符处理往往比数字处理慢。
* 列的长度越小，有利于性能的提升。

但另外需要考虑的是：

* 优先选择用`int`或者`timestamp`来存储时间数据。缺点是使用不方便，需要进行函数转换。

* 同时需要关注时间存储的粒度——`年 月 日 时 分 秒`。

**(4) 反范式化设计（为了效率的提升而做的，可能数据冗余）**

上面已经提到，范式过高也会导致表之间的关系更加繁琐，从而导致每次操作的表会变多，数据库性能下降。

而**反范式化**就是为了性能和读取效率，适当地对范式进行违反，**本质上就是用空间来换取时间**，把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联。

这里有个简单的例子，例如下面遵守范式设计的几个表：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215214451570.png" width="450px"/>
</div>

反范式的设计：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215214502963.png" width="550px"/>
</div>

这样，查询订单信息就大大简化了：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2020121521473944.png" width="500px"/>
</div>

其实在日常生活中，大多数数据库都是读比写多。反反范式化设计虽然在写的时候增加了冗余，但是在读的时候我们大大的提高了效率。

| 设计       | 优点                                       | 缺点                                           |
| ---------- | ------------------------------------------ | ---------------------------------------------- |
| 范式设计   | 数据没有冗余，更新操作容易，数据一致性高。 | 关联表查询太多，查询性能下降。                 |
| 反范式设计 | 数据大量冗余，查询性能较快。               | 更新性能下降，磁盘空间消耗较大，数据一致性低。 |

## 数据库实现

这里选择MySQL数据库，存储引擎选择Innodb，这里我们采用PowerDesigner来设计数据库各表。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021050701022088.png" width="1000px"/>
</div>
生产DDL、数据库执行、数据入库... ...

## 维护和优化

**(1) 维护数据字典——数据大量冗余，查询性能较快。**  

* 使用第三方工具对数据字典进行维护

* 利用数据库本身的备注字段来对数据字典进行维护，后面直接导出数据字典即可。例如：

```mysql
CREATE TABLE shopping (
  userid        varchar(64) NOT NULL COMMENT '用户id',
  orderid       varchar(64) NOT NULL COMMENT '订单id',
  receivername  varchar(20) NOT NULL COMMENT '收货姓名',
  PRIMARY KEY (shoppingid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**(2) 维护索引——随着数据量和查询的不断变化，需要优化索引。**

- 在SQL语句中不要强制使用索引关键字。

- 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描。
- 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描。
- 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段。
- 字符字段只建前缀索引。
- 字符字段最好不要做主键。
- 不用外键，由程序保证约束。
- 尽量不用UNIQUE，由程序保证约束。
- 使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引。

**(3) 维护表结构——随着需求的不断变化，需要对表进行扩充或裁剪。**

MySQL5.5之前使用在线工具`pt-online-schema-change`调整表结构；MySQL5.6自身支持在线表结构的变更，同时对数据字典进行维护，控制表的宽度和大小。

数据库中适合的操作：

* 尽量使用批量操作，少用逐条操作。

* 尽量少用使用`SELECT *`语句。

* 尽量少用用户自定义函数。

* 谨慎使用用数据库全文索引。

**(4) 适当时候对表进行水平拆分或垂直拆分——随着数据量的增大，达到表的存储瓶颈，使操作变慢，需要拆分表。**

表的**垂直拆分**——减小表的宽度。
* 将经常查询的列放在一起，不经常查询的列单独拆成一张附表。
* 表中数据量不发生变化。

通常我们按以下原则进行垂直拆分:

1. 把不常用的字段单独放在一张表;
2. 把text，blob，clob等大字段拆分出来放在附表中;
3. 经常组合查询的列放在一张表中;

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215220118383.png" width="550px"/>
</div>
表的**水平拆分**——减小表的高度（表的行数超过200万行时，就会变慢）。
* 通过主键hash的方式将一张大表拆分成n个小表。
* 表中各个列不发生变化。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215220231717.png" width="550px"/>
</div>
数据库设计优化相关问题：

* 唯一约束和索引的关系？
* 是否可以冗余字段？
* 是否使用外键、触发器？
* 是否使用游标、变量、视图、自定义函数、存储过程？ 
* 自增主键的使用问题？
* 能够在线修改表结构（DDL 操作）？ 
* 逻辑删除还是物理删除？
* 要不要加 create_time,update_time 时间戳？
* 数据库碎片问题？
* 如何快速导入导出、备份数据？
* ... ...

# 总结

数据库设计的步骤大致可以分为需求分析、概念设计、逻辑设计、物理设计、数据库实现，维护和优化几个步骤。实际开发中，通常根据业务模块的需求去分析，抽像成E-R图概念模型，然后进行关系模式的规范化和优化，经过数据库选型及生成PDM，最终生成数据库表，然后才能开始coding，测试、发布上线以及版本迭代，为了保证线上业务的安全稳定高效，就需要对数据库进行精细化管理和维护。

不难发现，数据库设计的核心就是对需求分析的理解以及抽象建成ER模型图，这就需要对行业及相关业务有深刻认知及抽象能力。实际开发中，可能大多数人在项目中接触到的数据库都已经是在维护和优化阶段，这并不意味着我们只需要关注数据库相关的优化问题。理清数据库设计的设计流程有助于我们理解行业及相关业务，也有助于我们数据库的管理、维护及优化。

# 参考资料

* 《数据库系统设计、实现与管理》
* [数据库设计的基础——数据库范式](https://juejin.cn/post/6844904183611523086)
* [如何设计一个数据库](https://juejin.cn/post/6905914933020459016)
* [数据库设计](http://c.biancheng.net/mysql/35/)
* [为了彻底搞清楚数据库 E-R 模型设计，我肝了这篇万字长文](https://zhuanlan.zhihu.com/p/356216273)