<!-- MarkdownTOC -->

- [1. 代理模式](#1-代理模式)
- [2. 静态代理](#2-静态代理)
- [3. 动态代理](#3-动态代理)
  - [3.1. JDK 动态代理机制](#31-jdk-动态代理机制)
    - [3.1.1. 介绍](#311-介绍)
    - [3.1.2. JDK 动态代理类使用步骤](#312-jdk-动态代理类使用步骤)
    - [3.1.3. 代码示例](#313-代码示例)
  - [3.2. CGLIB 动态代理机制](#32-cglib-动态代理机制)
    - [3.2.1. 介绍](#321-介绍)
    - [3.2.2. CGLIB 动态代理类使用步骤](#322-cglib-动态代理类使用步骤)
    - [3.2.3. 代码示例](#323-代码示例)
  - [3.3. JDK 动态代理和 CGLIB 动态代理对比](#33-jdk-动态代理和-cglib-动态代理对比)
- [4. 静态代理和动态代理的对比](#4-静态代理和动态代理的对比)
- [5. 总结](#5-总结)

<!-- /MarkdownTOC -->
## 1. 代理模式

代理模式是一种比较好的理解的设计模式。简单来说就是 **我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**

举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210630233339599.png" width="600px"/>
</div>

代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。

## 2. 静态代理

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的（_后面会具体演示代码_），非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类_)。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， **静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

静态代理实现步骤:

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

下面通过代码展示！

**1.定义发送短信的接口**

```java
public interface SmsService {
    String send(String message);
}
```

**2.实现发送短信的接口**

```java
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```

**3.创建代理类并同样实现发送短信的接口**

```java
public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}
```

**4.实际使用**

```java
public class Main {
    public static void main(String[] args) {
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send("java");
    }
}
```

运行上述代码之后，控制台打印出：

```bash
before method send()
send message:java
after method send()
```

可以输出结果看出，我们已经增加了 `SmsServiceImpl` 的`send()`方法。

## 3. 动态代理

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( _CGLIB 动态代理机制_)。

**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。

**动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。**

就 Java 来说，动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。

[guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。

另外，虽然 [guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 没有用到 **CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和**JDK 动态代理的对比。

### 3.1. JDK 动态代理机制

#### 3.1.1. 介绍

**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ，这个方法主要用来生成一个代理对象。

```java
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }
```

这个方法一共有 3 个参数：

1. **loader** :类加载器，用于加载代理对象。
2. **interfaces** : 被代理类实现的一些接口；
3. **h** : 实现了 `InvocationHandler` 接口的对象；

要实现动态代理的话，还必须需要实现`InvocationHandler` 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用。

```java
public interface InvocationHandler {

    /**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

`invoke()` 方法有下面三个参数：

1. **proxy** :动态生成的代理类
2. **method** : 与代理类对象调用的方法相对应
3. **args** : 当前 method 方法的参数

也就是说：**你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。** 你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

#### 3.1.2. JDK 动态代理类使用步骤

1. 定义一个接口及其实现类；
2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；

#### 3.1.3. 代码示例

这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！

**1.定义发送短信的接口**

```java
public interface SmsService {
    String send(String message);
}
```

**2.实现发送短信的接口**

```java
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```

**3.定义一个 JDK 动态代理类**

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @author shuang.kou
 * @createTime 2020年05月11日 11:23:00
 */
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }


    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return result;
    }
}

```

`invoke()` 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 `invoke()` 方法，然后 `invoke()` 方法代替我们去调用了被代理对象的原生方法。

**4.获取代理对象的工厂类**

```java
public class JdkProxyFactory {
    public static Object getProxy(Object target) {
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(), // 目标类的类加载
                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个
                new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler
        );
    }
}
```

`getProxy()` ：主要通过`Proxy.newProxyInstance（）`方法获取某个类的代理对象

**5.实际使用**

```java
SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
smsService.send("java");
```

运行上述代码之后，控制台打印出：

```
before method send
send message:java
after method send
```

### 3.2. CGLIB 动态代理机制

#### 3.2.1. 介绍

**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**

**为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**

[CGLIB](https://github.com/cglib/cglib)(_Code Generation Library_)是一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了[CGLIB](https://github.com/cglib/cglib)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**

你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。

```java
public interface MethodInterceptor
extends Callback{
    // 拦截被代理类中的方法
    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,
                               MethodProxy proxy) throws Throwable;
}

```

1. **obj** :被代理的对象（需要增强的对象）
2. **method** :被拦截的方法（需要增强的方法）
3. **args** :方法入参
4. **methodProxy** :用于调用原始方法

你可以通过 `Enhancer`类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。

#### 3.2.2. CGLIB 动态代理类使用步骤

1. 定义一个类；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 通过 `Enhancer` 类的 `create()`创建代理类；

#### 3.2.3. 代码示例

不同于 JDK 动态代理不需要额外的依赖。[CGLIB](https://github.com/cglib/cglib)(_Code Generation Library_) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。

```xml
<dependency>
  <groupId>cglib</groupId>
  <artifactId>cglib</artifactId>
  <version>3.3.0</version>
</dependency>
```

**1.实现一个使用阿里云发送短信的类**

```java
package github.javaguide.dynamicProxy.cglibDynamicProxy;

public class AliSmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```

**2.自定义 `MethodInterceptor`（方法拦截器）**

```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 自定义MethodInterceptor
 */
public class DebugMethodInterceptor implements MethodInterceptor {


    /**
     * @param o           被代理的对象（需要增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return object;
    }

}
```

**3.获取代理类**

```java
import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {

    public static Object getProxy(Class<?> clazz) {
        // 创建动态代理增强类
        Enhancer enhancer = new Enhancer();
        // 设置类加载器
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new DebugMethodInterceptor());
        // 创建代理类
        return enhancer.create();
    }
}
```

**4.实际使用**

```java
AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
aliSmsService.send("java");
```

运行上述代码之后，控制台打印出：

```bash
before method send
send message:java
after method send
```

### 3.3. JDK 动态代理和 CGLIB 动态代理对比

1. **JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

## 4. 静态代理和动态代理的对比

1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

## 5. 总结

这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。

文中涉及到的所有源码，你可以在这里找到：[https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy](https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy) 。

* 《从零开始手把手教你实现一个简单的RPC框架》](https://t.zsxq.com/iIUv7Mn) 











# 动态代理

动态代理在 Java 中有着广泛的应用，比如 **AOP 的实现原理、RPC远程调用、Java 注解对象获取、日志框架、全局性异常处理、事务处理等**。

代理模式（Proxy Design Pattern）的核心思想是，在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。这样做的好处是可以在**目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能**。

## 静态代理

一般而言，静态代理其实就是指设计模式中的代理模式。代理模式为其他对象提供一种代理以控制对这个对象的访问。

例如我们构建一个用户接口，定义一个保存用户的模版方法。

```java
public interface UserDao {
    void save();
}
```

构建一个用户实现类，这个用户实现类是真正进行用户操作的方法

```java
public class UserDaoImpl implements UserDao {
    
    @Override
    public void save() {
        System.out.println("------保存用户------");
    }
}
```

构建一个用户代理类，用户代理类也有一个保存用户的方法，不过这个方法属于代理方法，它不会执行真正的保存用户，而是内部持有一个真正的用户对象，进行用户保存。

```java
public class UserProxy {

    private UserDao userDao;

    public UserProxy(UserDao userDao) {
        this.userDao = userDao;
    }

    public void proxy() {
        System.out.println("------代理开始------");
        userDao.save();
        System.out.println("------代理结束------");
    }
}
```

下面是测试方法。

```java
public class ProxyTest {
    public static void main(String[] args) {
        UserDaoImpl userDao = new UserDaoImpl();
        UserProxy userProxy = new UserProxy(userDao);
        userProxy.proxy();
    }
}
```

**代理模式具有无侵入性的优点**，以后我们增加什么新功能的话，我们可以直接增加一个代理类，让代理类来调用用户操作，这样我们就实现了不通过改源码的方式增加了新的功能。

静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和` UserDaoImpl`的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，会导致系统结构比较臃肿和松散。

## JDK动态代理

**动态代理（Dynamic Proxy）是一种方便运行时动态构建代理、动态处理代理方法调用的机制**。也就是说，我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

动态代理利用了[JDK API](http://tool.oschina.net/uploads/apidocs/jdk-zh/)，动态地在内存中构建代理对象，从而实现对目标对象的代理功能，动态代理又被称为JDK代理或接口代理。

Java 动态代理基于经典代理模式，引入了一个 `InvocationHandler`，`InvocationHandler `负责统一管理所有的方法调用。

动态代理步骤：

* 获取 `UserDaoImpl`上的所有接口列表；
* 确定要生成的代理类的类名，默认为：`com.sun.proxy.$ProxyXXXX`；
* 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；
* 将对应的字节码转换为对应的 class 对象；
* 创建 `InvocationHandler` 实例 handler，用来处理 `Proxy` 所有方法调用；
* Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。

可以看出，JDK动态代理的实现是基于实现接口的方式，使得Proxy和 `UserDaoImpl `具有相同的功能。

在 Java 的动态代理机制中，有两个重要的类（接口），一个是 `InvocationHandler` 接口、另一个则是 `Proxy` 类，这一个类和一个接口是实现我们动态代理所必须用到的。

### InvocationHandler 接口

`InvocationHandler` 接口定义：

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

每一个动态代理类都必须要实现 `InvocationHandler` 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 `InvocationHandler` 这个接口的 `invoke` 方法来进行调用。

我们来看看 `InvocationHandler` 这个接口的唯一一个方法 invoke 方法：

```java
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
```

参数说明：

- **proxy** - 代理的真实对象。
- **method** - 所要调用真实对象的某个方法的 `Method` 对象
- **args** - 所要调用真实对象某个方法时接受的参数

### Proxy 类

`Proxy` 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 `newProxyInstance` 这个方法：

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException
```

这个方法的作用就是得到一个动态的代理对象。

参数说明：

- **loader** - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。
- **interfaces** - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
- **h** - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上

### 动态代理实例

例如我们构建一个用户接口，定义一个保存用户的模版方法。

```java
public interface UserDao {
    void save();
}
```

构建一个用户实现类，这个用户实现类是真正进行用户操作的方法

```java
public class UserDaoImpl implements UserDao {
    
    @Override
    public void save() {
        System.out.println("------保存用户------");
    }
}
```

我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：

```java
public class UserHandler implements InvocationHandler {
    /**
     * 这个就是我们要代理的真实对象
     */
    private UserDao userDao;

    public UserHandler(UserDao userDao) {
        this.userDao = userDao;
    }

    /**
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        saveStart();

        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        Object obj = method.invoke(userDao, args);

        saveEnd();
        return obj;
    }

    private void saveStart() {
        System.out.println("------插入开始------");
    }

    private void saveEnd() {
        System.out.println("------插入结束------");
    }
}
```

编写测试类：

```java
public class DynamicProxyTest {
    public static void main(String[] args) {
        // 要代理的真实对象
        UserDao userDao = new UserDaoImpl();
        // 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法
        UserHandler handler = new UserHandler(userDao);

        ClassLoader classLoader = handler.getClass().getClassLoader();
        Class<?>[] interfaces = userDao.getClass().getInterfaces();

        /*
         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
         * 第一个参数classLoader，这里使用handler这个类的ClassLoader对象来加载我们的代理对象
         * 第二个参数interfaces，为代理对象提供的接口是真实对象所实行的接口，表示代理的是该真实对象
         * 第三个参数handler，这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
         */
        UserDao proxy = (UserDao) Proxy.newProxyInstance(classLoader, interfaces, handler);

        System.out.println(proxy.getClass().getName());
        proxy.save();
    }
}
```

看看控制台的输出：

```java
com.sun.proxy.$Proxy0
------插入开始------
------保存用户------
------插入结束------
```

通过 `Proxy.newProxyInstance` 创建的代理对象是在 JVM 运行时动态生成的一个对象，它并不是我们的 `InvocationHandler` 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，Proxy 为中，最后一个数字表示对象的标号。

## CGLIB 动态代理

上面我们提到 JDK 动态代理是基于接口的代理，而 CGLIB 动态代理**是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法** ，也就是说 CGLIB 动态代理采用类继承 -> 方法重写的方式进行的。

下面我们通过一个示例来演示一下 CGLIB 动态代理的使用

首先导入 CGLIB 相关 jar 包，我们使用的是 MAVEN 的方式

```xml
       <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.1</version>
        </dependency>
```

然后我们新创建一个 UserService 类，为了和上面的 UserDao 和 UserDaoImpl 进行区分。

```java
public class UserService {
    public void saveUser(){
        System.out.println("---- 保存用户 ----");
    }
}
```

之后我们创建一个自定义方法拦截器，这个自定义方法拦截器实现了拦截器类

```java
public class AutoMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, 
                            MethodProxy methodProxy) throws Throwable {
        System.out.println("before-------切面加入逻辑");
        Object object = methodProxy.invokeSuper(o, objects);
        System.out.println("after-------切面加入逻辑");
        return object;
    }
}
```

这里解释一下这几个参数都是什么含义：

- `Object o`: `o`是 CGLIB 动态生成代理类实例。
- `Method method`: Method 为实体类所调用的被代理的方法引用。
- `Object[] objects`: 这个就是方法的参数列表。
- `MethodProxy methodProxy` : 这个就是生成的代理类对方法的引用。

对于 `methodProxy` 参数调用的方法，在其内部有两种选择：`invoke()` 和 `invokeSuper()` ，二者的区别不在本文展开说明，感兴趣的读者可以参考本篇文章：[Cglib源码分析 invoke和invokeSuper的差别](https://blog.csdn.net/makecontral/article/details/79593732?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-4&spm=1001.2101.3001.4242)

然后我们创建一个测试类进行测试：

```java
public class CglibTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback(new AutoMethodInterceptor());

        UserService userService = (UserService) enhancer.create();

        userService.saveUser();
        System.out.println(userService);
    }
}
```

测试类主要涉及 `Enhancer` 的使用，Enhancer 是一个非常重要的类，它允许为`非接口类型`创建一个 Java 代理，Enhancer 动态的创建给定类的子类并且拦截代理类的所有的方法，和 JDK 动态代理不一样的是不管是接口还是类它都能正常工作。测试类运行结果：

```java
before-------切面加入逻辑
---- 保存用户 ----
after-------切面加入逻辑
before-------切面加入逻辑
before-------切面加入逻辑
after-------切面加入逻辑
after-------切面加入逻辑
org.zgkaii.proxy.cglib.UserService$$EnhancerByCGLIB$$b044764d@69663380
```

JDK 动态代理与 CGLIB 动态代理都是将真实对象`隐藏`在代理对象的后面，以达到 `代理` 的效果。与 JDK 动态代理所不同的是 CGLIB 动态代理使用 Enhancer 来创建代理对象，而 JDK 动态代理使用的是 `Proxy.newProxyInstance `来创建代理对象；还有一点是 CGLIB 可以代理大部分类，而 JDK 动态代理只能代理实现了接口的类。

**动态代理**

代理模式的核心思想是，在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，扩展目标对象的功能。

静态代理相对简单，只要代理对象对目标对象进行包装，就可以实现增强功能，具有无侵入性的优点。同时，静态代理在编译时产生class字节码文件，可以直接使用，效率高。但是静态代理只能为一个目标对象服务，如果目标对象过多，就会产生过多的代理类，这样容易造成系统臃肿和松散。

动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制。很多场景都是利用反射机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）、日志框架、全局性异常处理、事务处理等。

实现动态代理的方式很多，比如利用了反射机制的 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、CGLIB（基于 ASM）、`Javassist` 等。

* JDK 动态代理只需要目标对象实现业务接口，而代理类只实现 `InvocationHandler`接口，在程序运行时通过`反射机制`使用使用`Proxy.newProxyInstance `动态生成代理类`com.sun.proxy.$Proxy0`，可以减少代理类的数量，使用灵活。
* CGLIB 与 JDK 动态代理都是将真实对象隐藏在代理对象的后面。但 CGLIB 代理无需实现接口，通过`Enhancer` 生产类字节码实现代理生产代理类`org.zgkaii.proxy.cglib.UserService$$EnhancerByCGLIB$$b044764d@69663380`，比反射稍快，不存在性能问题。但是CGLIB会继承目标对象，需要重写方法，所以目标对象不能为final类。