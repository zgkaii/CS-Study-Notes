- [Redis如何避免数据丢失](#redis如何避免数据丢失)
  - [实现AOF日志](#实现aof日志)
  - [重写机制](#重写机制)
    - [如何避免重写阻塞主线程](#如何避免重写阻塞主线程)
- [Redis如何实现快速恢复](#redis如何实现快速恢复)
  - [快照时数据能修改吗](#快照时数据能修改吗)
  - [做快照的频率](#做快照的频率)

**写在最前**

Redis是内存数据库，它把后端数据库中的数据存储在内存中，然后直接从内存中读取数据，响应速度会非常快。但是**一旦服务器宕机，内存中的数据将全部丢失**。如果仅仅从后端恢复数据，那么

* 频繁访问数据库，会给数据库带来巨大的压力；
* 数据从慢速数据库中读取，性能不及Redis，会导致使用这些数据的应用程序响应变慢。

所以，对 Redis 来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。目前，Redis 的持久化主要有两大机制，即 **AOF（Append Only File）日志和 RDB 快照**。

# Redis如何避免数据丢失

## 实现AOF日志

传统数据库是写前日志（Write Ahead Log, WAL），即在实际写数据前，先将修改数据写入日志文件中，一遍故障时进行修复。

AOF日志正好相反，它是**写后日志**，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。

AOF日志的优势在于，命令执行成功才能写入日志，这样**避免出现记录错误命令，同时不会阻塞当前的写操作**。

AOF潜在的风险：

* 执行完命令还未来得及写入日志就宕机，命令和相应的数据就有丢失的风险。
* 避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。AOF 日志是在主线程中执行的，如果日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。

风险分析：这些问题都是和AOF写回磁盘时机相关。那么如何找到AOF 日志写回磁盘的最佳时机呢？。

**三种写回策略**

AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。

* **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
  * “同步写回”基本不丢数据，但是每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
* **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
  * 每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。
* **No**，操作系统控制的写回：每个写命令执行完，日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。
  * 虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了。

三者对比如下：

| 配置项   | 写回时机           | 优点                     | 缺点                             |
| -------- | ------------------ | ------------------------ | -------------------------------- |
| Always   | 同步写回           | 可靠性高、数据基本不丢失 | 每个写命令都要落盘，性能影响较大 |
| Everysec | 每秒写回           | 性能适中                 | 宕机师丢失1秒内数据              |
| No       | 操作系统控制的写回 | 性能好                   | 宕机时丢失数据较多               |

可见，无论哪一种写回策略都不能做到“高枕无忧”。另外引出的问题就是，随着接收的命令越来越多，AOF文件越来越大，肯定会带来性能问题，主要表现在以下三方面：

* 文件系统本身对文件大小有限制，无法保存过大的文件；
* 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
* 如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复。如果日志文件太大，整个恢复过程就会非常缓慢影响到 Redis 的正常使用。

## 重写机制

AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 

具体的实现是：检查当前键值数据库中的键值对，记录键值对的最终状态，对某个键值对重复操作后产生的多条操作记录压缩成一条的效果，进而实现压缩AOF文件的大小（“多变一”）。

<div align="center"> <img src="..\..\..\images\redis\多变一.jpg" width="700px"></div>

例如上图，我们对一个列表先后做了 6 次修改操作后，列表的最后状态是[“D”, “C”, “N”]，此时，只用 LPUSH u:list “N”, “C”, "D"这一条命令就能实现该数据的恢复，这就节省了五条命令的空间。

### 如何避免重写阻塞主线程

AOF重写的过程可以总结为“**一个拷贝，两处日志**”。和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

“一个拷贝”：每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

> fork子进程时，子进程会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，就能共享访问父进程的内存数据了，这就类似于有了父进程的所有内存数据。

“两处日志”：因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。

而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。

<div align="center"> <img src="..\..\..\images\redis\AOF重写.jpg" width="600px"></div>

总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。

# Redis如何实现快速恢复

**内存快照**，就是指内存中的数据在某一个时刻的状态记录，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。

Redis执行的是**全量快照**，即把内存中所有的数据都记录到磁盘中。它提供了两个命令来生成RDB文件，分别是save和bgsave:

* save：在主线程中执行，会导致阻塞；
* bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

## 快照时数据能修改吗

在给别人拍照时，一旦对方动了，那么这张照片就拍糊了，我们就需要重拍，所以我们当然希望对方保持不动。对于内存快照而言，我们也不希望数据“动”。

举个例子。我们在时刻 t 给内存做快照，假设内存数据量是 4GB，磁盘的写入带宽是 0.2GB/s，简单来说，至少需要 20s（4/0.2 = 20）才能做完。如果在时刻 t+5s 时，一个还没有被写入磁盘的内存数据 A，被修改成了 A’，那么就会破坏快照的完整性，因为 A’不是时刻 t 时的状态。因此，和拍照类似，我们在做快照时也不希望数据“动”，也就是不能被修改。

如果快照执行期间数据不能被修改，是会有潜在问题的。对于刚刚的例子来说，在做快照的 20s 时间里，如果这 4GB 的数据都不能被修改，Redis 就不能处理对这些数据的写操作，那无疑就会给业务服务造成巨大的影响。

这里需要注意的是，**避免阻塞和正常处理写操作并不是一回事**。此时，主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。

**解决办法**：借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

<div align="center"> <img src="..\..\..\images\redis\写时复制技术.jpg" width="600px"></div>

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

## 做快照的频率

对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。那么是否快照的频率越高越好呢？答案是否定的。

如果频繁地执行全量快照，会带来两方面的开销：

*  频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
* bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。

**解决办法**：增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。但是，这么做的前提是，**我们需要记住哪些数据被修改了**，它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。

Redis 4.0 中提出了**一个混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

<div align="center"> <img src="..\..\..\images\redis\AOF与RDB混用.jpg" width="600px"></div>

如上图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

关于 AOF 和 RDB 的选择问题，这里提三点建议：

* 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
* 如果允许分钟级别的数据丢失，可以只使用 RDB；
* 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。