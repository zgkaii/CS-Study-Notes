- [什么是事务](#什么是事务)
- [隔离性与隔离级别](#隔离性与隔离级别)
- [事务隔离的实现](#事务隔离的实现)
- [事务的启动方式](#事务的启动方式)
- [事务的查看与设置](#事务的查看与设置)
  - [查看当前会话隔离级别](#查看当前会话隔离级别)
  - [设置隔离级别](#设置隔离级别)
- [实际情况演示](#实际情况演示)
  - [脏读(读未提交)](#脏读读未提交)
  - [避免脏读(读已提交)](#避免脏读读已提交)
  - [不可重复读](#不可重复读)
  - [可重复读](#可重复读)
  - [防止幻读(可重复读)](#防止幻读可重复读)
- [参考](#参考)
# 什么是事务

提到事务，肯定都不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友转100块钱，转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，这就涉及到“事务”这个概念了。

简单来说，**事务**就是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元（unit），**要么全部执行，要么全部不执行，是不可分割的工作单元**。

MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务，**事务能否生效取决于数据库引擎是否支持事务**。常用的MySQL 数据库默认使用`innodb`引擎是支持事务的。但是，如果把数据库引擎变为 `MYISAM`，那么也就不再支持事务了。

# 隔离性与隔离级别

提到事务，肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），详细可参考[事务管理](https://blog.csdn.net/KAIZ_LEARN/article/details/108614496)一文。今天主要还是研究一下隔离性。

当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）等并发问题。例如现在有两个事务——A和B并发执行。  

* **脏读**（dirty read) 
  1）A将某条记录的AGE值从20修改为30。 
  2）B读取了A更新后的值：30。 
  3）A回滚，AGE值恢复到了20。 
  4）B读取到的30就是一个无效的值。  
* **不可重复读**（non-repeatable read）
  1）A读取了AGE值为20。
  2）B将AGE值修改为30。
  3）A再次读取AGE值为30，和第一次读取不一致。
* **幻读**（phantom read）
  1）A读取了STUDENT表中的一部分数据。
  2）B向STUDENT表中插入了新的行。
  3）A读取了STUDENT表时，多出了一些行或少了一些行。

为了解决上述这些问题，就有了“隔离性”的概念，它要求每个事务都应该与其他事务隔离开来，多个事务在并发执行过程中不会互相干扰。

一个事务与其他事务隔离的程度称为隔离级别。在谈隔离级别之前，首先要知道，隔离级别越高，数据一致性就越好，但并发性越弱。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（READ_UNCOMMITTED）、读提交（READ_COMMITTED）、可重复读（REPEATABLE_READ）和串行化（SERIALIZABLE）。

| 隔离级别         | 含义                                                         | 举例                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| READ_UNCOMMITTED | 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 | 允许A读取B未提交的修改。                                     |
| READ_COMMITTED   | 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 | 要求A只能读取B已提交的修改。                                 |
| REPEATABLE_READ  | 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 | 确保A可以多次从一个字段中读取到相同的值，即A执行期间禁止其它事务对这个字段进行更新。 |
| SERIALIZABLE     | 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读。 | 确保A可以多次从一个表中读取到相同的行，在A执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。 |

各个隔离级别解决并发问题的能力见下表: 

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ_UNCOMMITTED | √    | √          | √    |
| READ_COMMITTED   | ×    | √          | √    |
| REPEATABLE_READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |

其中“读提交”和“可重复读”比较难理解，下面就用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。

```mysql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

<img src="https://img-blog.csdnimg.cn/20201123225719474.png" style="zoom: 67%;" />
我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。

- 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
- 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
- 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

各种数据库产品对事务隔离级别的支持程度：

| 隔离级别         | Oracle  | MySQL   |
| ---------------- | ------- | ------- |
| READ_UNCOMMITTED | ×       | √       |
| READ_COMMITTED   | √(默认) | √       |
| REPEATABLE_READ  | ×       | √(默认) |
| SERIALIZABLE     | √       | √       |

Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。

配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。

```mysql
mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+
```

哪个隔离级别都有它自己的使用场景，要根据具体的业务情况来定。比如下面这个数据校对逻辑的案例，如果是  MySQL数据库，该选择隔离级别呢？

假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。

# 事务隔离的实现

理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里以“可重复读”为例。

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

![](https://img-blog.csdnimg.cn/20201123230601584.png)
当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是——在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。

什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。

理解上面知识后，就明白为什么不建议使用长事务了。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。

# 事务的启动方式

MySQL的事务启动方式有以下几种：

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。

```mysql
START TRANSACTION;
-- 事务代码
commit;
```

2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

因此，建议开发中总是使用set autocommit=1, 之后通过显式语句的方式来启动事务。

# 事务的查看与设置

## 查看当前会话隔离级别

**方式一**：`SHOW VARIABLES LIKE 'transaction_isolation';`

```mysql
mysql> show variables like 'transaction_isolation';
+-----------------------+--------------+
| Variable_name  | Value |
+-----------------------+--------------+
| transaction_isolation | SERIALIZABLE |
+-----------------------+--------------+
```

**方式2**：`SELECT @@transaction_isolation;`

```mysql
mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| SERIALIZABLE            |
+-------------------------+
```

## 设置隔离级别

**方式一**：通过set命令——`SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;`

其中level有4种值：

```
level: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}
```

**关键词：GLOBAL**

表示只对执行完该语句之后产生的会话起作用，对当前已经存在的会话无效。

**关键词：SESSION**

表示对当前会话的所有后续的事务有效。该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务；如果在事务之间执行，则对后续的事务有效。

**无关键词**——`SET TRANSACTION ISOLATION LEVEL level;`

表示， 只对当前会话中下一个即将开启的事务有效。下一个事务执行完后，后续事务将恢复到之前的隔离级别。
* 该语句不能在已经开启的事务中间执行，会报错。

**方式二**：通过服务启动项命令——修改启动参数transaction-isolation的值

比方说启动服务器时指定了`transaction-isolation=READ UNCOMMITTED`，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。

# 实际情况演示

在下面就使用 2 个命令行mysql ，模拟多线程（多事务）对同一份数据的脏读问题。

MySQL 命令行的默认配置中事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：`START TARNSACTION`。

我们可以通过下面的命令来设置隔离级别。

```sql
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]
```

我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:

- `START TARNSACTION` |`BEGIN`：显式地开启一个事务。
- `COMMIT`：提交事务，使得对数据库做的所有修改成为永久性。
- `ROLLBACK`：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。

## 脏读(读未提交)

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1脏读(读未提交)实例.jpg" width="800px"/>
</div>


## 避免脏读(读已提交)

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-2读已提交实例.jpg" width="800px"/>
</div>


## 不可重复读

还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-32-1不可重复读实例.jpg"/>
</div>


## 可重复读

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33-2可重复读.jpg"/>
</div>


## 防止幻读(可重复读)

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33防止幻读(使用可重复读).jpg"/>
</div>


一个事务对数据库进行操作，这种操作的范围是数据库的全部行，然后第二个事务也在对这个数据库操作，这种操作可以是插入一行记录或删除一行记录，那么第一个是事务就会觉得自己出现了幻觉，怎么还有没有处理的记录呢? 或者 怎么多处理了一行记录呢?

幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。

# 参考

* [彻底搞懂 MySQL 事务的隔离级别](https://developer.aliyun.com/article/743691)

* [【Spring学习笔记】事务管理_](https://blog.csdn.net/KAIZ_LEARN/article/details/108614496)

* [Innodb 中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)