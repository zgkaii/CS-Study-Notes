- [数据库基础知识](#数据库基础知识)
  - [DB、DBMS、DBS与DBA](#dbdbmsdbs与dba)
  - [元组，码等基础概念](#元组码等基础概念)
  - [函数依赖关系](#函数依赖关系)
  - [drop、delete与truncate区别](#dropdelete与truncate区别)
  - [SQL语言](#sql语言)
- [如何进行数据库设计](#如何进行数据库设计)
- [需求分析](#需求分析)
- [逻辑设计](#逻辑设计)
  - [ER图（实体关系图）](#ER图（实体关系图）)
  - [设计范式](#设计范式)
    - [1NF](#1nf)
    - [2NF](#2nf)
    - [3NF](#3nf)
    - [BCNF](#bcnf)
- [物理设计](#物理设计)
- [维护优化](#维护优化)
- [参考](#参考)

# 数据库基础知识

## DB、DBMS、DBS与DBA

- **数据库** ：数据库(DataBase简称DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。
- **数据库管理系统** : 数据库管理系统(Database Management System 简称DBMS)是一种操纵和管理数据库的大型软件，通常用语用于建立、使用和维护数据库。
- **数据库系统** : 数据库系统(Data Base System，简称DBS)通常由软件、数据库和数据管理员(DBA)组成。
- **数据库管理员** : 数据库管理员(Database Administrator,简称DBA)负责全面管理和控制数据库系统。

数据库系统基本构成如下图所示：

<div align="center">  
<img src="https://images.xiaozhuanlan.com/photo/2019/eb713d4b4df6193ce4c5fcaea8678708.jpg" width="600px"/>
</div>

## 元组，码等基础概念

- **元组** ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- **码** ：码就是能唯一标识实体的属性，对应表中的列。
- **候选码** ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- **主码** : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- **外码** : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- **主属性** ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）.显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- **非主属性：** 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

这里可以看出主键和外键区别：

- **主键(主码)** ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
- **外键(外码)** ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

## 函数依赖关系

**函数依赖（functional dependency）** ：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作` X → Y`。

**部分函数依赖（partial functional dependency）** ：如果`X→Y`，并且存在X的一个真子集X0，使得`X0→Y`，则称Y对X部分函数依赖。比如学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；

**完全函数依赖(Full functional dependency)** ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；

**传递函数依赖** ： 在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩Z=空集合，则称Z传递函数依赖(transitive functional dependency) 于X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。

## drop、delete与truncate区别

**（1）用法不同**

- drop(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- truncate (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中数据的时候使用。
- delete（删除数据） : `delete from 表名 where 列名=值`，删除某一列的数据，如果不加 where 子句和`truncate table 表名`作用类似。

truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 **truncate 和 delete 只删除数据不删除表的结构(定义)，执行drop语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。**

**（2）属于不同的数据库语言**

truncate和drop 属于DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。

**（3）执行速度不同**

一般来说:drop>truncate>delete（这个我没有设计测试过）。

## SQL语言

结构化查询语言包含6个部分：

* 数据查询语言（**DQL**: Data Query Language）：其语句，也称为“数据检索语句”，用以从表中获得数据，确 定数据怎样在应用程序给出。保留字 SELECT 是 DQL（也是所有 SQL）用得最多的动词，其他 DQL 常用的保留字 有 WHERE，ORDER BY，GROUP BY 和 HAVING。这些 DQL 保留字常与其它类型的 SQL 语句一起使用。
* 数据操作语言（**DML**：Data Manipulation Language）：是指对数据库中表记录的操作，其语句包括动词 INSERT、UPDATE 和 DELETE。它们分别用于添加、修改和删除，是开发人员日常使用最频繁的操作。
* 事务控制语言（TCL）：它的语句能确保被 DML 语句影响的表的所有行及时得以更新。包括COMMIT（提交） 命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。
* 数据控制语言（DCL）：它的语句通过 GRANT 或 REVOKE 实现权限控制，确定单个用户和用户组对数据库对象 的访问。某些 RDBMS 可用 GRANT 或 REVOKE 控制对表单个列的访问。 
* 数据定义语言（**DDL**：Data Definition Language）：对数据库内部的对象进行创建、删除、修改的操作语言，其语句包括动词 CREATE，ALTER 和 DROP。在数据库中创建新表或修改、删除表 （CREAT TABLE 或 DROP TABLE）和为表加入索引等。 DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。
* 指针控制语言（CCL）：它的语句，像 DECLARE CURSOR，FETCH INTO 和 UPDATE WHERE CURRENT 用于对 一个或多个表单独行的操作。

# 如何进行数据库设计

数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS（数据库管理系统），为这个业务系统构造出最优的数据存储模型，并建立数据库中的表结构以及表与表之间的关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已存储的数据进行访问。

| 优良的设计       | 糟糕的设计                   |
| ---------------- | ---------------------------- |
| 减少数据维护异常 | 存在数据插入、更新、删除异常 |
| 减少数据维护异常 | 存在大量数据冗余             |
| 节约存储空间     | 浪费大量存储空间             |
| 高效的访问       | 访问数据低效                 |

**数据库设计的步骤**

```html
需求分析 -> 逻辑设计 -> 物理设计 —> 维护优化
```

**需求分析**——数据是什么，数据具有哪些属性，数据与属性的特点是什么。
**逻辑分析**——使用ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统。
**物理设计**——根据数据库自身的特点把逻辑设计转换为物理设计。
**维护设计**——对新的需求进行建表；索引优化；大表拆分。

# 需求分析

为了设计最优化的数据库，便于后期的扩展和维护，数据越来越多，越来越大会浪费空间，越来越杂乱，后期是很难处理和维护的。

1. 了解系统中索要存储的数据。
2. 了解数据的存储特点，比如有的数据有时效性，有的没有，有时效性的可以采取定期清理。
3. 了解数据的生命周期。

要搞清楚的一些问题：

1. 实体及实体之间的关系（1对1，1对多，多对多）
2. 实体所包含的属性有什么？属性有很多，哪些属性是可以标识出这个实体的？
3. 哪些属性或属性的组合可以唯一标识一个实体？
4. 存储上有什么特性，增长量是什么样？

**实例演示**

以一个小型的电子商务网站为例，在这个电子商务网站的系统中包括了几个核心模块：用户模块，商品模块，订单模块，购物车模块，供应商模块。下面就对各个模块进行需求分析。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201214233227760.png" width="600px"/>
</div>

* 用户模块：用于记录注册用户信息
  包括属性：用户名，密码，电话，邮箱，身份证号，地址，姓名，昵称.....

  可唯一标识属性：用户名，身份证号，电话

  存储特点：随系统上线时间的增长，需要永久存储

* 商品模块：用于记录网站中说销售的商品信息
  包括属性：商品编码，商品名称，商品描述，商品品类，供货商名称，重量，有效期，价格......

  可唯一标识属性：商品编码，（商品名称，供货商名称）

  存储特点：对于下线商品可以归档存储（不能直接删除，可能跟订单有关）

* 订单模块：用于用户订购商品的信息
  包括属性：订单号，用户姓名，用户电话，收货地址，商品编号，商品名称，数量，价格，订单状态，支付状态.....

  可唯一标识属性：订单号

  存储特点：永久存储（分表，分库存储）

* 购物车模块：用于保存用户购物时选的商品
  包括属性：用户名，商品编号，商品名称，商品价格，加入时间，商品数量......
  可唯一标识属性：（用户名，商品编号，加入时间），购物车编号

  存储特点：不用永久存储（设置归档，清理规则）

* 供应商模块：用于保存供应商信息
  包括属性：供应商编号，供应商名称，联系人，电话，营业执照，供应商品.....

  可唯一标识属性:供应商编号，营业执照

  存储特点：永久存储

# 逻辑设计

## ER图（实体关系图）

**E-R图**也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。

**表示方法**

实体型：用矩形框，矩形框内写明实体名

属性：用椭圆型表示，并用无向边将其与相应的实体连接起来。（可以连实体，也可以连联系）

联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁边标上联系的类型。

数量：一对一（1:1），一对多（1：n），多对多（m:n）

**实例演示**

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201214235342989.png" width="600px"/>
</div>

> 注：有的属性下面有下划线，就表示主键。

## 设计范式

什么是数据库设计范式？

——也就是提供了一种准则，帮助我们建立简介高效且结构清晰的数据库设计，避免数据库插入、更新、删除、修改中的异常，并且为最大限度的避免数据库的冗余。

关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式（4NF）和第五范式（5NF）。 满足最低要求的范式是第一范式（1NF）。 在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。 ... 越高的范式数据库的冗余度就越低。

但并不是说遵循的范式等级越高越好，范式过高虽然具有对数据关系有更好的约束性，但是也会导致表之间的关系更加繁琐，从而导致每次操作的表会变多，数据库性能下降。

通常，在我的设计中，**最高也就遵循到 BCNF，普遍还是 3NF**。

### 1NF

关系 R 属于第一范式，当且仅当 R 中的每一个属性 A 的值域只包含原子项。直白地讲，**数据库中的所有字段都是单一属性，不可再分的，每个列都是原子的**。这个单一属性由基本数据类型所构成，例如整数、浮点数、字符串等。换句话说，第一范式要求数据库中的表都是二维表。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201214235911315.png" width="600px"/>
</div>

### 2NF

1NF 只是设计数据库最基本的要求，但是数据会存在大量的冗余，并存在删除异常、插入异常、更新异常。例如：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215100946703.png" width="600px"/>
</div>

**2NF 在 1NF 的基础上，消除了非主属性对码的部分函数依赖** 。消除部分依赖，表中没有列只与主键的部分相关，即每一行都被主键唯一标识。每个表都有主键。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215000202930.png" width="600px"/>
</div>

### 3NF

**3NF 就是在 2NF 的基础上，消除非主属性对码的传递函数依赖**。消除传递依赖，消除表中列不依赖主键而依赖表中的非主键列的情况，即没有列是与主键不相关的。 从表只引用主表的主键， 即表中每列都和主键相关。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215000433830.png" width="600px"/>
</div>

### BCNF

不存在**主属性**对于码的部分函数依赖和传递函数依赖，那么即符合 BCNF（前面的 2NF、3NF都是**非主属性**对码的部分函数依赖和传递函数依赖）。

例如下例，假设供应商联系只能受雇于一家供应商，每个供应商可以供应多个商品，则存在关系（供应商，商品ID）—> （供应商联系人，商品数量）与（供应商联系人，商品ID）—> （供应商，商品数量），不符合 BCNF。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215000609806.png" width="600px"/>
</div>
**4NF与5NF**

* **4NF**：消除非平凡的多值依赖。

* **5NF**：消除一些不合适的连接依赖。

> 使用不多，不做研究。

# 物理设计

**（1）选择数据库管理系统（应用特点和成本）**

常见的DBMS系统：

* 开源：MySQL、PostgreSQL
* 商业：Oracle，DB2，SQL Server
* 内存数据库：Redis？，VoltDB
* 图数据库：Neo4j，Nebula
* 时序数据库：InfluxDB、openTSDB
* 其他关系数据库：Access、Sqlite、H2、Derby、Sybase、Infomix 等
* NoSQL 数据库：MongoDB、Hbase、Cassandra、CouchDB
* NewSQL/分布式数据库：TiDB、CockroachDB、NuoDB、OpenGauss、OB、TDSQL

比如常用MySQL数据库存储引擎选择：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215104834614.png" width="600px"/>
</div>

**（2）定义数据库、表以及字段的命名规范（不同数据库对命名的规范是有差异的）**

* 可读性规则：使用大写和小写来格式化的库对象名字以获得良好的可读性。

* 表意性原则：对象的名字应该能够描述它所标识的对象。

* 长命原则：尽量少使用或者不使用缩写。

**（3）根据所选的DBMS系统选择合适的字段类型**

列的数据类型一方面影响数据存储空间的开销，另一方面也会影像数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑数据类型，其次时日期或二进制类型，最后时字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。

例如：

| 类型       | 数据           |
| ---------- | -------------- |
| char(10)   | `'1978-03-01'` |
| vachar(20) | `'1978-03-01'` |
| datetime   | `1978-03-01`   |
| int        | `257529600`    |

那么int > datetime > char(10) > vachar(20)，int最优。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215213114874.png" width="400px"/>
</div>

以上选用主要从两个角度考虑：

* 同样的数据，字符处理往往比数字处理慢。
* 列的长度越小，有利于性能的提升。

**char与varchar**

* 如果列中要存储的数据长度差不多是一致的，则优先选择char。

* 列中最大数据长度小于50byte，则一般考虑使用char。

**decimal与float**

* decimal主要用于存储数据比float要精确。

* float占用空间较小，当数据要求不精确优先选择。

**时间类型**

上面的举例已经透出一些选择规则：

优先选择用`int`或者`timestamp`来存储时间数据。缺点是使用不方便，需要进行函数转换。

同时需要关注时间存储的粒度——`年 月 日 时 分 秒`。

**（4）反范式化设计（为了效率的提升而做的，可能数据冗余）**

上面已经提到，范式过高也会导致表之间的关系更加繁琐，从而导致每次操作的表会变多，数据库性能下降。

而**反范式化**就是为了性能和读取效率，适当地对范式进行违反，**本质上就是用空间来换取时间**，把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联。

例如下面遵守范式设计的几个表：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215214451570.png" width="450px"/>
</div>

反范式的设计：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215214502963.png" width="550px"/>
</div>

这样，查询订单信息就大大简化了：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2020121521473944.png" width="500px"/>
</div>

其实在日常生活中，大多数数据库都时读比写多。反反范式化设计虽然在写的时候增加了冗余，但是在读的时候我们大大的提高了效率。

| 设计       | 优点                                       | 缺点                                           |
| ---------- | ------------------------------------------ | ---------------------------------------------- |
| 范式设计   | 数据没有冗余，更新操作容易，数据一致性高。 | 关联表查询太多，查询性能下降。                 |
| 反范式设计 | 数据大量冗余，查询性能较快。               | 更新性能下降，磁盘空间消耗较大，数据一致性低。 |

# 维护优化

**（1）维护数据字典——数据大量冗余，查询性能较快。**  

* 使用第三方工具对数据字典进行维护

* 利用数据库本身的备注字段来对数据字典进行维护，后面直接导出数据字典即可。例如：

```mysql
CREATE TABLE shopping (
  userid        varchar(64) NOT NULL COMMENT '用户id',
  orderid       varchar(64) NOT NULL COMMENT '订单id',
  receivername  varchar(20) NOT NULL COMMENT '收货姓名',
  PRIMARY KEY (shoppingid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**（2）维护索引——随着数据量和查询的不断变化，需要优化索引。**

- 如何选择合适的列建立索引？
  * 出现在where, group by, order by从句后的列。
  * 可选择性高的列要放在索引的前面。
  * 索引中不要包含太长的数据类型。
- 索引要适量，不是越多越好，大量的索引会导致操作效率降低。
- 定期维护索引碎片。
- 在SQL语句中不要强制使用索引关键字。

**（3）维护表结构——随着需求的不断变化，需要对表进行扩充或裁剪。**

MySQL5.5之前使用在线工具`pt-online-schema-change`调整表结构；MySQL5.6自身支持在线表结构的变更，同时对数据字典进行维护，控制表的宽度和大小。

数据库中适合的操作：

* 尽量使用批量操作，少用逐条操作。

* 尽量少用使用`SELECT *`语句。

* 尽量少用用户自定义函数。

* 谨慎使用用数据库全文索引。

**（4）适当时候对表进行水平拆分或垂直拆分——随着数据量的增大，达到表的存储瓶颈，使操作变慢，需要拆分表。**

- 表的**垂直拆分**——减小表的宽度。
  * 将经常查询的列放在一起，不经常查询的列单独拆成一张附表。
  * 表中数据量不发生变化。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215220118383.png" width="550px"/>
</div>

- 表的**水平拆分**——减小表的高度。
  * 通过主键hash的方式将一张大表拆分成n个小表。
  * 表中各个列不发生变化。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201215220231717.png" width="550px"/>
</div>

# 参考

* [数据库设计的基础——数据库范式](https://juejin.cn/post/6844904183611523086)
* [https://www.imooc.com/learn/117](https://www.imooc.com/learn/117)