- [为什么使用索引](#为什么使用索引)
- [为表字段添加索引](#为表字段添加索引)
- [索引的常见模型](#索引的常见模型)
  - [哈希表](#哈希表)
  - [有序数组](#有序数组)
  - [二叉搜索树](#二叉搜索树)
- [InnoDB的索引模型-B+树](#innodb的索引模型-b树)
- [索引维护](#索引维护)
- [覆盖索引](#覆盖索引)
- [最左前缀原则](#最左前缀原则)
  - [=、in自动优化顺序](#in自动优化顺序)
- [索引下推](#索引下推)
- [为什么索引能提高查询速度](#为什么索引能提高查询速度)
  - [从MySQL的基本存储结构说起](#从mysql的基本存储结构说起)
  - [使用索引之后](#使用索引之后)
- [思考题](#思考题)
- [参考资料](#参考资料)

# 为什么使用索引

为什么使用索引呢？简单的说，**索引的出现其实就是为了提高数据查询的效率，就像书的目录一样**。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。

这里总结了索引的优点：

1. 可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。
2. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
3. 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。
4. 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

# 为表字段添加索引

1.添加PRIMARY KEY（主键索引）

```mysql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```

2.添加UNIQUE(唯一索引) 

```mysql
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```

3.添加INDEX(普通索引) 

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

4.添加FULLTEXT(全文索引) 

```mysql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```

5.添加多列索引

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

# 索引的常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却又很多种。这里主要介绍三种常见的数据结构，它们分别是哈希表、有序数组和搜索树。

## 哈希表

哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。

假设，你现在维护一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这是对应的哈希索引的示意图如示：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021061115404243.png" width="500px"/>
</div>

**哈希索引做区间查询的速度挺慢的**。例如，这个记录身份证信息和姓名的表中，需要根据身份证号查找对应的名字。由于不同的身份号码通过哈希运算后值基本不相同且不是有序的，所以要查询要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍，效率很低。

所以，**哈希表这种结构适用于只有等值查询的场景**，适用于`Memcached`及其他一些NoSQL引擎。

## 有序数组

**有序数组在等值查询和范围查询场景中的性能就都非常优秀**。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210611154334568.png" width="500px"/>
</div>

还是上面这个根据身份证号查名字的例子，假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果查ID_card_N对应的名字，用二分法就可以快速得到，时间复杂度是O(log(N))。

同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。

如果仅仅看查询效率，有序数组很完美。但是，在需要更新数据的时，每在中间插入一个记录就必须挪动后面所有的记录，成本太高。

所以，**有序数组索引只适用于静态存储引擎**，比如要保存的是2008年某个城市的所有人口信息（这类数据后续不会再被修改）。

## 二叉搜索树

二叉搜索树是经典的数据结构。二叉搜索树的特点是：每个父节点都有两个子节点（子节点可能为空），每个左子节点都比父节点小，每个右子节点比父节点大。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126212832873.png" width="500px"/>
</div>

在上图中，如果要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -> UserC -> UserF -> User2路径查得，时间复杂度是O(log(N))。

为了维持O(log(N))的查询复杂度，就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。

二叉搜索树搜索效率挺高，但是实际上大多数的数据库存储却并不使用，原因在于数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少I/O次数，对于树来说，IO次数就是树的高度。

你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。(二叉树太高，一次访问过多节点，即访问的数据块过多，而从磁盘随机独缺数据过于耗时)

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，**“N叉”树中的“N”取决于数据块的大小**。

以`InnoDB`的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

> 数据页默认大小为16KB，MySQL 中 `bigint` 为8个字节，指针大小在`InnoDB`为6个字节，那么一个N = 16*1023/（8+6）= 1170 （约等1200）。如果高度为4层，1170^3=17亿。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。

# InnoDB的索引模型-B+树

在MySQL中，索引是在存储引擎层实现的，并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。InnoDB使用了**B+树**索引模型，数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。**B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。**

假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。

```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126220850358.png" width="500px"/>
</div>

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为**聚簇索引**（clustered index）。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为**二级索引**（secondary index）。

**基于主键索引和普通索引的查询有什么区别？**

- 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为**回表**。（回到主键索引树搜索的过程，称为回表）

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，在实际应用中**尽量使用主键查询**。

# 索引维护

B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还会影响数据页的利用率，原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

基于上面的索引维护过程说明，下面来讨论`建表时，在哪些场景下应该使用自增主键，而哪些场景下不应该使用`。

自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。

也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

**比如表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？**

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（`bigint`）则是8个字节。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：

1. 只有一个索引；
2. 该索引必须是唯一索引。

典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。

这时候就要优先考虑“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

# 覆盖索引

还是以上面例子为例：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126220850358.png" width="500px"/>
</div>

如果执行查询SQL语句是`select * from T where k between 3 and 5`，执行流程如下：

* 在k索引树上找到k=3的记录，取得 ID = 300；
* 再到ID索引树查到ID=300对应的R3；
* 在k索引树取下一个值k=5，取得ID=500；
* 再回到ID索引树查到ID=500对应的R4；
* 在k索引树取下一个值k=6，不满足条件，循环结束。

在这个过程中，**回到主键索引树搜索的过程，我们称之为回表**。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。

在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？

如果执行的语句是`select ID from T where k between 3 and 5`，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。

基于上面覆盖索引的说明，我们来讨论一个问题：**在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？**

假设这个市民表的定义是这样的：

```mysql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

身份证是市民的唯一标识。也就是说，如果根据身份号查询市民信息的需求，我们只需要在身份证号字段上建立索引就够了。而建立一个（身份证号，姓名）的联合索引，是不是浪费空间？

如果现在又一个高频请求，要根据市民的身份证查询他的姓名，这个联合索引就又意义了。它可以在高频请求上用到覆盖索引，不再需要回表查询整行记录，减少语句的执行时间。

# 最左前缀原则

到这里大家一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？

这里，我先和你说结论吧。**B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**

为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126223529122.png" width="500px"/>
</div>
可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是"where name like ‘张%’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

基于上面对最左前缀索引的说明，我们来讨论一个问题：**在建立联合索引的时候，如何安排索引内的字段顺序。**

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。**

所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。

那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。

这时候，我们要**考虑的原则就是空间**了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。

这里再举一个例子：如有索引`(a, b, c, d)`，查询条件`a = 1 and b = 2 and c > 3 and d = 4`，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是**相等**的情况，不能是范围匹配)

> 索引只能用于查找key是否**存在（相等）**，遇到范围查询`(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。

> 当构建组合索引(a,b,c,d)时，实际上创建了(a), (a, b), (a, b, c), (a, b,c ,d)四个索引，每个索引先保证前面的key有序，再保证后面的key有序。实际上当查询条件`a = 1 and b = 2 and c > 3 `时，可以用索引(a, b, c)，因为在a，b相同的情况下，c是有序的。但是当查询条件`a = 1 and b = 2 and c > 3 and d = 4`时，就不能用上述建的索引中的任意一个。所以a，b，c命中，d无法命中，如果查询条件a = 1 and b = 2 and c = 3 and d > 4，那么d也命中，就用(a,b,c,d)索引。

## =、in自动优化顺序

**不需要考虑=、in等的顺序**，MySQL会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：如有索引`(a, b, c, d)`，查询条件`c > 3 and b = 2 and a = 1 and d < 4`与`a = 1 and c > 3 and b = 2 and d < 4`等顺序都是可以的，MySQL会自动优化为`a = 1 and b = 2 and c > 3 and d < 4`，依次命中a、b、c。

# 索引下推

还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：

```mysql
select * from user where name like '张%' and age=10 and ismale=1;
```

你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。然后是判断其他条件是否满足。

在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。

而MySQL 5.6 引入的**索引下推优化（index condition pushdown)**， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，大大提升了查询的效率。

如果没有索引下推的话，执行流程如下：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126225305587.png" width="500px"/>
</div>


 索引下推执行流程：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126225346324.png" width="500px"/>
</div>


> 每一个虚线箭头表示回表一次。

第一个图中，在(name,age)索引里面去掉了age的值，这个过程`InnoDB`并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。

第二图中，`InnoDB`在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。

# 为什么索引能提高查询速度

## 从MySQL的基本存储结构说起

MySQL的基本存储结构是页(记录都存在页里边)：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/img_convert/552b7a208ee6fb65063904a719ad727c.png" width="500px"/>
</div>
<div align="center">  
<img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/82053134.jpg" width="800px"/>
</div>
 - **各个数据页可以组成一个双向链表**
 - **每个数据页中的记录又可以组成一个单向链表**
     - 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
     - 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

所以说，如果写`select * from user where indexname = 'xxx'`这样没有进行任何优化的SQL语句，默认会这样做：

* **定位到记录所在的页：需要遍历双向链表，找到所在的页**。

* **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**。

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O(n)。


## 使用索引之后

索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/img_convert/190514dfa37f1034c9a2bf6e67b3c56e.png" width="800px"/>
</div>

要找到id为8的记录简要步骤：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/img_convert/e65a2494171cf02a2b1680cb76d883e9.png" width="800px"/>
</div>

很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 **“目录”** 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(log(N))。

底层数据结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

# 思考题

**思考题1**：对于上面例子中的`InnoDB`表T，如果你要重建索引 k，你的两个SQL语句可以这么写：

```mysql
alter table T drop index k;
alter table T add index(k);
```

如果你要重建主键索引，也可以这么写：

```mysql
alter table T drop primary key;
alter table T add primary key(id);
```

我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？

**解答**：重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程是不合理的。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两句语句可以用这个语句代替：

`alter table T engine=InnoDB`。

------

**思考题2**：实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：

```mysql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。

但是小吕纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？

同事告诉他，是因为他们的业务里面有这样的两种语句：

```mysql
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

**解答**：主键a,b的聚族索引组织顺序相当于`order by a,b`，也就是先按a排序，再按b排序，c无序。

索引ca的组织是先按c排序，再按a排序，同时记录主键，这个跟索引c是一样的。而索引cb的组织是先按c排序，再按b排序，同时记录主键。所以，结论是ca可以去掉，cb需要保留。

> `InnoDB`会把主键字段放到索引定义字段后面，并且会去重。所以，当主键是(a,b)时，定义为c的索引，实际是(c,a,b)；定义为（c,a）的索引，实际是(c,a,a,b)=>(c,a,b)，也就是说索引c与索引(c,a)是一样的；为（c,b）索引时，则为(c,b,a)。

# 参考资料

- 《Java工程师修炼之道》
- 《MySQL高性能书籍_第3版》
- [数据库两大神器【索引和锁】](https://juejin.im/post/5b55b842f265da0f9e589e79)
- [MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)