<!-- MarkdownTOC -->
- [池化技术](#池化技术)
  - [什么是池化技术](#什么是池化技术)
  - [池化技术常见应用](#池化技术常见应用)
    - [数据库连接池](#数据库连接池)
    - [线程池](#线程池)
    - [内存池](#内存池)
    - [HttpClient 连接池](#httpclient-连接池)
  - [总结](#总结)
  - [参考资料](#参考资料)

<!-- /MarkdownTOC -->

# 池化技术

## 什么是池化技术

池化技术是一种常见的软件设计思想，其核心就是**空间换时间**，期望使用预先创建好的对象来减少频繁创建对象的性能开销，同时还可以对对象进行统一的管理，降低了对象的使用的成本。

以Java对象的创建来说，在对象创建时要经历以下步骤：

1. 根据 new 标识符后面的参数，在常量池查找类的符号引用；
2. 如果没找到符号应用（类并未加载），进行类的加载、解析、初始化等；
3. 虚拟机为对象在堆中分配内存，并将分配的内存初始化为 0，针对对象头，建立相应的描述结构（耗时操作：需要查找堆中的空闲区域，修改内存分配状态等）；
4. 调用对象的初始化方法（耗时操作：用户的复杂的逻辑验证等操作，如IO、数值计算是否符合规定等）。

从上述的流程中可以看出，创建一个类需要经历复杂且耗时的操作，因此**我们应该尽量复用已有的类，以确保程序的高效运行，当然如果能够提前创建这些类就再好不过了，而这些功能都可以用池化技术来实现**。

## 池化技术常见应用

常见的池化技术的使用有：线程池、内存池、数据库连接池、HttpClient 连接池、Redis连接池等等。

### 数据库连接池

数据库连接池的基本思想是在系统初始化的时候将数据库连接作为对象存储在内存中，当用户需要访问数据库的时候，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。在使用完毕后，用户也不是将连接关闭，而是将连接放回到连接池中，以供下一个请求访问使用，而这些连接的建立、断开都是由连接池自身来管理的。

连接池有两个最重要的配置：**最小连接数和最大连接数**，它们控制着从连接池中获取连接的流程：

- 如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
- 如果连接池中有空闲连接则复用空闲连接；
- 如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
- 如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
- 如果等待超过了这个设定时间则向用户抛出错误。

对于数据库连接池，一般在线上建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。

如何保证连接可用呢？

- **可以启动一个线程来定期检测连接池中的连接是否可用**，如使用连接发送“select 1”的命令给数据库看是否会抛出异常，如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。目前 C3P0 连接池可以采用这种方式来检测连接是否可用。
- 在获取到连接之后，先校验连接是否可用，如果可用才会执行 SQL 语句。比如 DBCP 连接池的 testOnBorrow 配置项，就是控制是否开启这个验证。这种方式在获取连接时会引入多余的开销，在线上系统中还是尽量不要开启，在测试服务上可以使用。

### 线程池

JDK 1.5 中引入的 ThreadPoolExecutor 就是一种线程池的实现，它有两个重要的参数：**coreThreadCount 和 maxThreadCount**，这两个参数控制着线程池的执行过程。线程池的执行原理：

- 如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；
- 如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；
- 当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；
- 当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃。

**JDK实现的线程池适用于CPU密集型任务**，也就是需要执行大量 CPU 运算的任务。因为JDK实现的线程池优先把任务放入队列暂存起来，当执行CPU密集型任务时，CPU特别繁忙。这时我们只需要创建和 CPU 核数相当的线程，多了反而会造成线程上下文切换，降低任务执行效率。所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。

但是，平时的Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。所以说，在**I/O 密集型任务**中，线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。

所以说，Tomcat 使用的线程池就不是 JDK 原生的线程池，而是做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达 maxThreadCount，这样就比较适合于 Web 系统大量 IO 操作的场景。

最后，使用线程池请一定记住**不要使用无界队列**（即没有设置固定大小的队列），因为大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，造成服务不可用。

最后需要注意，池子中的对象需要在使用之前预先初始化完成，这叫做池子的**预热**，比方说使用线程池时就需要预先初始化所有的核心线程。如果池子未经过预热可能会导致系统重启后产生比较多的慢请求。

### 内存池

如何更好地管理应用程序内存的使用，同时提高内存使用的频率，这时值得每一个开发人员深思的问题。内存池（Memory Pool）就提供了一个比较可行的解决方案。

内存池在创建的过程中，会预先分配足够大的内存，形成一个初步的内存池。然后每次用户请求内存的时候，就会返回内存池中的一块空闲的内存，并将这块内存的标志置为已使用。当内存使用完毕释放内存的时候，也不是真正地调用 free 或 delete 的过程，而是把内存放回内存池的过程，且放回的过程要把标志置为空闲。最后，应用程序结束就会将内存池销毁，将内存池中的每一块内存释放。

**内存池的优点**：

- 减少内存碎片的产生，这个优点可以从创建内存池的过程中看出，当我们在创建内存池的时候，分配的都是一块块比较规整的内存块，减少内存碎片的产生。
- 提高了内存的使用频率。这个可以从分配内存和释放内存的过程中看出。每次的分配和释放并不是去调用系统提供的函数或操作符去操作实际的内存，而是在复用内存池中的内存。

**内存池的缺点**：会造成内存的浪费，因为要使用内存池需要在一开始分配一大块闲置的内存，而这些内存不一定全部被用到。

### HttpClient 连接池

HttpClient 我们经常用来进行 HTTP 服务访问。我们的项目中会有一个获取任务执行状态的功能使用 HttpClient，一秒钟请求一次，经常会出现 Conection Reset 异常。经过分析发现，问题是出在 HttpClient 的每次请求都会新建一个连接，当创建连接的频率比关闭连接的频率大的时候，就会导致系统中产生大量处于 TIME_CLOSED 状态的连接，这个时候使用连接池复用连接就能解决这个问题。

## 总结

池化技术核心是一种空间换时间优化方法的实践，期望使用预先创建好的对象来减少频繁创建对象的性能开销，同时还可以对对象进行统一的管理，降低了对象的使用的成本。我们需要关注空间占用情况，避免出现空间过度使用出现内存泄露或者频繁垃圾回收等问题。

不过，池化技术也存在一些缺陷，比方说存储池子中的对象肯定需要消耗多余的内存，如果对象没有被频繁使用，就会造成内存上的浪费。再比方说，池子中的对象需要在使用之前预先初始化完成，这叫做池子的预热，比方说使用线程池时就需要预先初始化所有的核心线程。如果池子未经过预热可能会导致系统重启后产生比较多的慢请求。

池子的最大值和最小值的设置也很重要，初期可以依据经验来设置，后面还是需要根据实际运行情况做调整。

## 参考资料

- [池化技术到达有多牛？看了线程和线程池的对比吓我一跳！](https://mp.weixin.qq.com/s/ZraWOaOdYAJA7TV3Zx60Xw)
- [Java 数据持久化系列之池化技术](https://mp.weixin.qq.com/s/UlTKRCrdB8vjD4XReGYgAg)