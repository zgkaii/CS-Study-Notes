<!-- MarkdownTOC -->

- [为什么使用索引](#为什么使用索引)
- [索引的分类](#索引的分类)
- [索引的常见模型](#索引的常见模型)
  - [哈希表](#哈希表)
  - [有序数组](#有序数组)
  - [二叉搜索树](#二叉搜索树)
- [InnoDB的索引模型](#innodb的索引模型)
  - [磁盘基础知识](#磁盘基础知识)
  - [B-树](#b-树)
  - [B+树](#b树)
- [索引相关问题](#索引相关问题)
  - [什么是回表](#什么是回表)
  - [什么是覆盖索引](#什么是覆盖索引)
  - [为什么建议使用自增主键](#为什么建议使用自增主键)
  - [什么是最左前缀匹配原则](#什么是最左前缀匹配原则)
  - [什么是索引下推](#什么是索引下推)
  - [MySQL选错索引怎么办](#mysql选错索引怎么办)
  - [如何给字符串加索引](#如何给字符串加索引)
  - [如何选择普通索引与唯一索引](#如何选择普通索引与唯一索引)
    - [查询过程](#查询过程)
    - [更新过程](#更新过程)
- [索引失效场景](#索引失效场景)
- [参考资料](#参考资料)

<!-- /MarkdownTOC -->

# 为什么使用索引

为什么使用索引呢？简单的说，**索引的出现其实就是为了提高数据查询的效率，就像书的目录一样**。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。

这里总结了索引的**优点**：

1. 可以大大加快数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。
2. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
3. 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。
4. 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

索引并不是万能的，显著的“**缺点**“就是，占用存储空间、降低更新表的速度。在下面情况下使用索引反而会降低效率：

1. 数据量少的场景比如不到 1000 行。
2. 数据重复度大的场景，比如重复高于 10% 的时候（如表中男女性别，不适合建立索引）。

索引的常见**使用场景**有：

1. 字段的数值有唯一性的限制，比如用户名；
2. 频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下；
3. 需要经常 GROUP BY 和 ORDER BY 的列；
4. UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引；
5. DISTINCT 字段需要创建索引；
6. 做多表 JOIN 连接操作时，创建索引需要注意以下的原则：

- 连接表的数量尽量不要超过 3 张；
- 对 WHERE 条件创建索引；
- 用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。

# 索引的分类

按照逻辑上来分，索引主要分为5种类型：

1. 普通索引（INDEX）：最基本的索引，没有任何约束，主要用于提高查询效率。

```
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

2. 唯一索引（UNIQUE）：与普通索引类似，但具有唯一性约束。

```mysql
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```

3. 主键索引（PRIMARY KEY）：特殊的唯一索引，不允许有空值，一张表最多一个主键索引。

```mysql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```

4. 全文索引（FULLTEXT）：MySQL 自带的全文索引只能用于 `InnoDB`、`MyISAM` ，并且只能对英文进行全文检索，一般使用全文索引引擎。

```mysql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```

5. 外键索引（ FOREIGN KEY）：只有`InnoDB`类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。
6. 复合索引/联合索引：将多个列组合在一起创建索引，可以覆盖多个列。

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

按照物理实现方式，索引可以分为 2 种：聚集索引和非聚集索引。

1. 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为**聚簇索引（clustered index）**。数据行按索引的排序方式存储，查询十分有效。

2. 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为**二级索引/辅助索引（secondary index）**。维护索引表，索引指向内容随机（两次查找，先找索引，再找数据行）。
3. 聚集索引与非聚集索引的原理不同，在使用上也有一些区别：

- 聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。
- 一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。
- 使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。

# 索引的常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却又很多种。这里主要介绍三种常见的数据结构，它们分别是哈希表、有序数组和二叉搜索树。

## 哈希表

哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。

假设，你现在维护一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这是对应的哈希索引的示意图如示：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021061115404243.png" width="500px"/>
</div>

**哈希索引做区间查询的速度挺慢的**。例如，这个记录身份证信息和姓名的表中，需要根据身份证号查找对应的名字。由于不同的身份号码通过哈希运算后值基本不相同且不是有序的，所以要查询要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍，效率很低。

Hash索引一定程度上比B+树都快，但是不支持范围查询，也不支持联合索引。同时hash索引不支持Order by排序，Hash指向的数据是无序的，不能进行排序优化。所以，**哈希表这种结构适用于只有等值查询的场景**，适用于`Memcached`及其他一些NoSQL引擎。

## 有序数组

**有序数组在等值查询和范围查询场景中的性能就都非常优秀**。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210611154334568.png" width="500px"/>
</div>

还是上面这个根据身份证号查名字的例子，假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果查ID_card_N对应的名字，用二分法就可以快速得到，时间复杂度是O(log(N))。

同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。

如果仅仅看查询效率，有序数组很完美。但是，在需要更新数据的时，每在中间插入一个记录就必须挪动后面所有的记录，成本太高。

所以，**有序数组索引只适用于静态存储引擎**，比如要保存的是2008年某个城市的所有人口信息（这类数据后续不会再被修改）。

## 二叉搜索树

二叉搜索树是经典的数据结构。二叉搜索树的特点是：每个父节点都有两个子节点（子节点可能为空），每个左子节点都比父节点小，每个右子节点比父节点大。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126212832873.png" width="500px"/>
</div>

在上图中，如果要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -> UserC -> UserF -> User2路径查得，时间复杂度是O(log(N))。

为了维持O(log(N))的查询复杂度，就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。

二叉搜索树搜索效率挺高，但是实际上大多数的数据库存储却并不使用，原因在于数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少I/O次数，对于树来说，IO次数就是树的高度。

你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。(二叉树太高，一次访问过多节点，即访问的数据块过多，而从磁盘随机独缺数据过于耗时)

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，**“N叉”树中的“N”取决于数据块的大小**。

以`InnoDB`的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

> 数据页默认大小为16KB，MySQL 中 `bigint` 为8个字节，指针大小在`InnoDB`为6个字节，那么一个N = 16*1023/（8+6）= 1170 （约等1200）。如果高度为4层，1170^3=17亿。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。

# InnoDB的索引模型

## 磁盘基础知识

我们知道数据是放在持久化存储中的，例如采用硬盘。一般的持久化存储都是使用磁盘作为存储介质的，而普通磁盘数据由机械手臂、磁头、转轴、盘片组成，盘片又分为磁道、柱面和扇区。盘片构造图如下：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/9414f4f53a024772a16d5341a781e1a8.png" width="500px"/>
</div>

盘片是存储介质，每个盘片被划分为多个同心圆，信息都被存储在同心圆之中，这些同心圆就是磁道。在磁盘工作时盘片是在高速旋转的，机械手臂驱动磁头沿着径向移动，在磁道上读取所需要的数据。我们把磁头寻找信息花费的时间叫做寻道时间。

**普通磁盘的寻道时间是 10ms 左右，而相比于磁盘寻道花费的时间，CPU 执行指令和内存寻址的时间都是在 ns（纳秒）级别，从千兆网卡上读取数据的时间是在μs（微秒）级别**。所以在整个计算机体系中磁盘是最慢的一环，甚至比其它的组件要慢几个数量级。因此减少磁盘 I/O的次数，也就减少了时间消耗。

硬盘的读写以**扇区（sector）**为基本单位。磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。硬盘的物理读写以扇区为基本单位。通常情况下每个扇区的大小是 512 KB。

文件系统读写数据的最小单位，也叫磁盘簇。扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。每个磁盘块可以包括 2、4、8、16、32 或 64 个扇区。**磁盘块（block）**是操作系统所使用的逻辑概念，而非磁盘的物理概念，位于同一个磁盘块中的数据会被一次性读取出来。

**页（page）**是内存的最小存储单位。页的大小通常为磁盘块大小的 2^n 倍。

在InnoDB写入数据时，都是以页（page）为基本单位，其中InnoDB**默认每个页的大小为 16 KB**，可通过参数 `innodb_page_size` 将页的大小设置为 4K、8K、16K ，也可通过命令查看页的大小`show variables like 'innodb_page_size'`。

但是，系统磁盘块（block）的存储空间往往没有这么大，因此 `InnoDB` 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。因此，我们在查询数据时，如果一个页中的每条数据都能够帮助定位到实际数据记录的位置，这将会大大减少磁盘 I/O 次数，提高查询效率。  

## B-树

在上面场景的索引模型中，我们已经知晓了二叉搜索树的局限性了，为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。因此一个节点就不能只有 2 个子节点，而应该允许有 M 个子节点 (M>2)。

B 树的出现就是为了解决这个问题，B 树的英文是 Balance Tree，也就是平衡的多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中的索引结构经常采用 B 树来实现。

一颗三阶的 B 树结构如下：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/5c6bf841f606496b87bbc1dd5473b43d.png" width="700px"/>
</div>

B 树作为平衡的多路搜索树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。

一个 M 阶的 B 树（M>2）有以下的特性：

1. 根节点的儿子数的范围是 [2,M]。
2. 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。
3. 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。
4. 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]<Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。
5. 所有叶子节点位于同一层。

B 树相比于平衡二叉树来说磁盘 I/O 操作要少，在数据查询中比平衡二叉树效率要高。但是，**B-Tree的每个索引节点都有Data域，每个节点即存放key又存放数据**，当存储的数据量很大会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。

## B+树

B+ 树基于 B 树做出了改进，主流的 DBMS 都支持 B+ 树的索引方式。B+ 树和 B 树的差异在于以下几点：

1. 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。
2. 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。
3. **非叶子节点仅用于索引，不保存数据记录**，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点既保存索引，也保存数据记录。
4. **所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接**。

下面是一颗3阶的B+树结构：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2026f7bb23d34776bacce7cdb26f6b58.png" width="700px"/>
</div>

InnoDB 存储引擎中页大小为16KB，一般表的主键类型为 int（占用4个字节） 或 bigint（占用8个字节），指针大小在InnoDB为6个字节，那么一个N = 16*1023/（8+6）= 1170 （约等1200）。如果高度为4层，1170^3=17亿。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL 的 `InnoDB` 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

比如，我们想要查找关键字 16，B+ 树会自顶向下逐层进行查找：

1. 与根节点的关键字 (1，18，35) 进行比较，16 在 1 和 18 之间，得到指针 P1（指向磁盘块 2）
2. 找到磁盘块 2，关键字为（1，8，14），因为 16 大于 14，所以得到指针 P3（指向磁盘块 7）
3. 找到磁盘块 7，关键字为（14，16，17），然后我们找到了关键字 16，所以可以找到关键字 16 所对应的数据。

**B+树相对B-树有什么优势呢**？

- **查询效率更稳定**。B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。
- **查询效率更高**。B+ 树比 B 树更矮胖（阶数更大，深度更低），查询所需要的磁盘 I/O 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字（相对红黑树也是一样）。
- **查询范围上，B+ 树的效率也比 B 树高**。因为所有关键字都出现在 B+ 树的叶子节点中，并通过有序链表进行了链接。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。

# 索引相关问题

## 什么是回表

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。InnoDB使用了**B+树**索引模型，数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。

假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。

```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126220850358.png" width="500px"/>
</div>

上面已经提到过，在InnoDB里主键索引也就是聚簇索引，他的叶子节点存的是整行数据。非主键索引/二级索引/辅助索引的叶子节点内容是主键的值。

**基于主键索引和普通索引的查询有什么区别？**

- 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为**回表**。（**回到主键索引树搜索的过程，称为回表**）

也就是说，基于非主键索引的查询时，需要先通过普通索引定位到主键值，然后通过聚簇索引定位到行记录，也就是需要多扫描一棵索引树。所以我们尽量使用主键索引来查询。

## 什么是覆盖索引

有没有可能经过索引优化，避免回表过程呢？还是以上面例子为例：


如果执行查询SQL语句是`select * from T where k between 3 and 5`，执行流程如下：

* 在k索引树上找到k=3的记录，取得 ID = 300；
* 再到ID索引树查到ID=300对应的R3（回表）；
* 在k索引树取下一个值k=5，取得ID=500；
* 再回到ID索引树查到ID=500对应的R4（回表）；
* 在k索引树取下一个值k=6，不满足条件，循环结束。

可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。

如何减少回表呢？这里就需要引出覆盖索引了。

**覆盖索引（covering index ，或称为索引覆盖），指一个索引包含（或者覆盖）了所有需要查询的字段的值，那么就可以通过索引直接获取数据，不需要回表查询主键索引中的记录**。这样减少了树的搜索次数，显著提升性能。

将上面的SQL语句修改为`select ID from T where k between 3 and 5`，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。**explain了SQL语句，其中的Extra中是Using index，这就代表了使用了覆盖索引**。

需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。

## 为什么建议使用自增主键

首先，我们要了解页分裂。B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。还是以上面的图为例，插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦，需要逻辑上挪动后面的数据，空出位置。

更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为**页分裂**。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还会影响数据页的利用率，原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。

> 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

而**自增主键**是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。

也就是说，自增主键的插入数据模式，正符合**递增插入**的场景。**每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂**。

问题在于，**建表时，在哪些场景下应该使用自增主键，而哪些场景下不应该使用呢？**

这里用一个例子说明，比如身份证表中有一个唯一字段，比如字符串类型的身份证号，那我们应该用身份证号做主键，还是用自增字段做主键呢？

- 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（`bigint`）则是8个字节。**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**
- 而且，使用业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

**有没有什么场景适合用业务字段直接做主键的呢**？还是有的。比如，有些业务的场景需求是这样的：

1. 只有一个索引；
2. 该索引必须是唯一索引。

典型的K-V场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候就要优先考虑“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

## 什么是最左前缀匹配原则

**最左前缀匹配原则**是相对联合索引而言的，指的是**索引是一种顺序结构，我们按照什么顺序创建索引，就只能按照这个顺序使用索引**，这很容易理解。 在MySQL建立联合索引时就会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

这里举一个例子：如有索引`(a, b, c, d)`，查询条件`a = 1 and b = 2 and c > 3 and d = 4`，则会在每个节点依次命中a、b、c，无法命中d。这是因为索引只能用于查找key是否**存在（相等）**，遇到范围查询`(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。

也就是说，当构建组合索引(a,b,c,d)时，实际上创建了(a), (a, b), (a, b, c), (a, b,c ,d)四个索引，每个索引先保证前面的key有序，再保证后面的key有序。实际上当查询条件`a = 1 and b = 2 and c > 3 `时，可以用索引(a, b, c)，因为在a，b相同的情况下，c是有序的。但是当查询条件`a = 1 and b = 2 and c > 3 and d = 4`时，就不能用上述建的索引中的任意一个。所以a，b，c命中，d无法命中，如果查询条件a = 1 and b = 2 and c = 3 and d > 4，那么d也命中，就用(a,b,c,d)索引。

基于上面对最左前缀索引的说明，我们来讨论一个问题：**在建立联合索引的时候，如何安排索引内的字段顺序。**

- 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。联合索引(a, b)意味着不需要建立a的索引了，因为这个联合索引意味着建立了(a,b)和(a)这两种索引；
- 其次考虑的原则就是空间。字段长的尽量少建，比如name字段是比age字段大的 ，建议创建一个（name,age)的联合索引和一个(age)的单字段索引。

需要注意的是，虽然遇到范围查询时最左匹配原则会失效，但是并**不需要考虑=、in等的顺序**，MySQL会自动优化这些条件的顺序，以匹配尽可能多的索引列。

举个例子，有索引`(a, b, c, d)`，查询条件`c > 3 and b = 2 and a = 1 and d < 4`与`a = 1 and c > 3 and b = 2 and d < 4`等顺序都是可以的，MySQL会自动优化为`a = 1 and b = 2 and c > 3 and d < 4`，依次命中a、b、c。

## 什么是索引下推

**索引下推（index condition pushdown ）**简称ICP，在Mysql5.6的版本上推出， 可以在索引遍历过程中，**对于不在最左前缀索引中的其他联合索引字段加以利用，对其包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**，大大提升了查询的效率。

如果查询利用到了索引下推ICP技术，在**Explain输出的Extra字段中会有“Using index condition”**。

假如有一张市民表，其存在一个联合索引（name, age），主键为自增主键ID。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126223529122.png" width="500px"/>
</div>

如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：

```mysql
select * from user where name like '张%' and age=10 and ismale=1;
```

根据最左前缀索引原则，该语句搜索索引树的时候，因为用到了模糊查询，所以只能命中name索引，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。然后是判断其他条件是否满足。

如果没有索引下推的话，执行流程如下：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126225305587.png" width="500px"/>
</div>
 存在索引下推，执行流程如下：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126225346324.png" width="500px"/>
</div>
> 每一个虚线箭头表示回表一次。

第一个图中，在(name,age)索引里面去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。

第二图中，InnoDB在(name,age)索引下推先判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。

## MySQL选错索引怎么办

选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，**扫描行数多少、是否使用临时表、是否排序**等是影响执行代价的因素之一。

**1、扫描行数判断**

MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。

这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而**一个索引上不同的值的个数，我们称之为“基数”（cardinality）**。也就是说，这个基数越大，索引的区分度越好。我们可以使用 `show index` 方法，看到一个索引的基数。

MySQL 是怎样得到索引的基数的呢？MySQL是通过**采样统计**的，因为把整张表取出来一行行精确统计代价太高。

- InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
- 数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：

- 设置为 on ，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。
- 设置为 off ，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

此外，我们可以explain查看SQL，其中**rows**这个字段表示的是预计扫描行数。MySQL 选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。如果发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可以采用`analyze table t` 命令来处理。

**2、索引选择异常和处理**

**一种方法是，采用 force index 强行选择一个索引**。MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。

**第二种方法就是，修改语句，引导 MySQL 使用我们期望的索引**。

**第三种方法是，在有些场景下，新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。**

## 如何给字符串加索引

**1、前缀索引**

先看一个例子，在email 字段上创建索引的语句：`alter table SUser add index index2(email(6));`，这样创建的index2 索引里面，对于每个记录都是只取前 6 个字节。

这就是所谓的浅醉索引。**使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本**。

前缀索引由于只保存了字段的一个前缀（不完整），在二级索引上无法将数据确定出来，因此必须需要回表一次以确定数据行；而前缀索引的目的是在二级索引树上保存更多的数据以减少回表的次数。还需要注意的是，使用前缀索引后，可能会导致查询语句读数据的次数变多。

当要给字符串创建前缀索引时，有什么方法能够确定应该使用多长的前缀呢？

- 建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。

例如，先算出这个列上有多少个不同的值：

```mysql
mysql> select count(distinct email) as L from SUser;
```

然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引：

```mysql
mysql> select 
  count(distinct left(email,4)）as L4,
  count(distinct left(email,5)）as L5,
  count(distinct left(email,6)）as L6,
  count(distinct left(email,7)）as L7,
from SUser;
```

当然，使用前缀索引很可能会**损失区分度**，所以需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。

> 在身份证存储的场景中，国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。这个时候可能需要创建长度为 12 以上的前缀索引，才能够满足区分度要求。
>
> 索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。有其他的处理方法吗？

**2、倒序存储**

如果存储身份证号的时候把它倒过来存，每次查询的时候，可以这么写：

```mysql
mysql> select field_list from t where id_card = reverse('input_id_card_string');
```

由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然，实践中不要忘记使用 count(distinct) 方法去做个验证。

**3、hash 字段**

可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。

```mysql
mysql> alter table t add id_card_crc int unsigned, add index(id_card_crc);
```

然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。

```mysql
mysql> select field_list from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string'
```

这样，索引的长度变成了 4 个字节，比原来小了很多。

4、**倒序存储 vs hash 字段**

相同点：**都不支持范围查询**。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash 字段的方式也只能支持等值查询。

区别，主要体现在以下三个方面：

- **占用的额外空间**来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。
- **CPU 消耗**方面来看，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。
- 从**查询效率**上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。

## 如何选择普通索引与唯一索引

假设维护了一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：

```java
select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz';
```

所以，可以考虑在`id_card`字段建立索引。由于身份证字段比较大，不建议将其当作主键，现在就有两个选择：那么是给id_card建立唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。

从性能的角度考虑，**选择唯一索引还是普通索引呢**？选择的依据是什么呢？

假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，k上的值不重复。

```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20201126220850358.png" width="500px"/>
</div>
接下来我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。

### 查询过程

假设，执行查询的语句是`select id from T where k=5`。这个查询语句在索引树上的查询过程，先是通过B+树丛树根开始，按层搜索叶子节点，也就是图中右下角的数据页，然后可以认为数据页内部通过二分法来定位记录。

* 对于普通索引而言，查找到满足条件的第一个记录（5，500）后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
* 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

**两者在查询时性能差距微乎其微**。`InnoDB`的数据时按数据页单位来读写的。在`InnoDB`中，每个数据页大小默认尾16KB。所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。

当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。

### 更新过程

**1、change buffer**

当需要更新一个数据页的时候，如果数据页在内存中就直接更新；如果数据页还未存在内存中的话，在不影响数据一致性的前提下，`InnoDB`会将这些更新操作缓存到change buffer里面，这样就需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据来读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

需要说明的是，虽然名字叫做changer buffer，实际上它是可以持久化的数据。也就是说，**changer buffer 在内存中有拷贝，也会被写入到磁盘上**。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。触发merge的时机有：（1）访问数据也会将change buffer 与buffer pool中的数据合并（2）系统有后台线程也会定期merge（3）数据库正常关闭（shutdown）的过程中，也会执行merge操作。

显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。

那么，**什么条件下可以使用change buffer呢？**

对于唯一索引来说，所有的更新操作都必须要先判断这个操作是否违反唯一性选择。。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

因此，**唯一索引就不能使用change buffer，事实也是只有普通索引能够使用change buffer**。

change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小（**默认25**），可以通过参数`innodb_change_buffer_max_size`来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

**唯一索引与普通索引区别案例**：**如果要在这张表中插入一个新记录(4,400)的话，`InnoDB`的处理流程是怎样的。**

第一种情况是，**这个记录要更新的目标页在内存中**。这时，`InnoDB`的处理流程如下：

* 对于唯一索引来说，找到3和5之间的位置，判断没有冲突，插入这个值，语句执行结束。
* 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。

这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。

但，这不是我们关注的重点。

第二种情况是，**这个记录要更新的目标页不在内存中**。这时，`InnoDB`的处理流程如下：

* 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
* 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

有DBA碰见过这种事儿，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。

**2、change buffer的使用场景**

普通索引的所有场景，使用change buffer都可以起到加速作用吗？

因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

因此，对于**写多读少**的业务来说，页面在写完以后马上被访问到的概率比较小，此时**change buffer的使用效果最好**。这种业务模型常见的就是账单类、日志类的系统。

反过来，假设一个业务的更新模式是**写入之后马上会做查询**，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，**change buffer反而起到了副作用**。

因此我们在选择唯一索引和普通索引的时候，考虑两类索引在查询能力上是没有差别的，主要考虑的是对更新性能的影响，建议尽量使用普通索引；但是如果业务更新后要伴随着对这个记录的查询，就需要用关闭change buffer。而在其他情况下，change buffer都能提升更新性能。

在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。

**3、change buffer与redo log**

 现在，我们要在表上执行这个插入语句：

```mysql
mysql> insert into t(id,k) values(id1,k1),(id2,k2);
```

这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存`(InnoDB buffer pool`)中，k2所在的数据页不在内存中。下图是带change buffer的更新状态图。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210612082801897.png" width="500px"/>
</div>	
分析这条更新语句，你会发现会涉及四个部分：内存、redo log(`ib_log_fileX`)、数据表空间(`t.ibd`)、系统表空间(`ibdata1`)。

这条更新语句做了如下的操作（按照图中的数字顺序）：

1. Page1 在内存中，直接更内存；
2. Page2 没有在内存中，就在内存的change buffer区域，记录`add (id2,k2) to Page2`这条信息；
3. 将上述两个动作记入 redo log（图中第3、4步）。

做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。

那在这之后的读请求，要怎么处理呢？比如，我们现在要执行 `select * from t where k in (k1, k2)`。

如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（`ibdata1`）和 redo log（`ib_log_fileX`）无关了。所以，图中就没画出这两部分。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021061208343315.png" width="500px"/>
</div>	
从图可以看出：

1. 读取Page1 的时候，直接从内存中返回。WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下上图中这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。
2. 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。

可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。

所以，简要地对比两个机制在提升性能上的收益的话，**redo log主要节省的是随机写磁盘的IO消耗（转成顺序写），而changer buffer 主要节省的是随机读磁盘的IO消耗**。

# 索引失效场景

这里总结了9种常见的索引失效场景：

1. **OR**导致索引失效：查询条件包含or，可能导致索引失效，如果要想使用`or`又不想让索引失效，那就得需要为`or`条件中的每个列都建立索引。
2. **类型不一致**导致的索引失效：如何字段类型是字符串，where时一定用引号括起来，否则索引失效。
3. **模糊查询**导致索引失效：使用模糊查询（like）的时候以`%`开头也会导致索引失效。（优化：使用覆盖索引或把%放后面）
4. **函数**导致索引失效：在索引列上使用MySQL的内置函数，索引失效。
5. **运算符**导致索引失效：索引字段上使用（!= 或者 < >）时，可能会导致索引失效。
6. **not in、not exists**导致索引失效。
7. 索引字段上使用**is null、 is not null**，可能导致索引失效。左连接查询或者右连接查询查询关联的字段。
8. **编码格式**不一样，可能导致索引失效：比如一个表的编码是utf8mb4，而另外一个表字段编码为utf8。
9. **联合索引如果不遵循最左前缀原则**，那么索引也将失效，例如**查询时的条件列不是联合索引中的第一个列，或者遇到范围查询（**`>、<、!=、between、like`左匹配）。

# 参考资料

- 《Java工程师修炼之道》
- 《MySQL高性能书籍_第3版》
- [MySQL实战45讲](https://time.geekbang.org/column/intro/139)