<!-- MarkdownTOC -->

- [1 一条SQL查询语句是如何执行的](#1-一条sql查询语句是如何执行的)
  - [1.1  MySQL 基本架构概览](#11--mysql-基本架构概览)
  - [1.2 Server 层基本组件介绍](#12-server-层基本组件介绍)
    - [1.2.1 连接器](#121-连接器)
    - [1.2.2 查询缓存](#122-查询缓存)
    - [1.2.3 分析器](#123-分析器)
    - [1.2.4 优化器](#124-优化器)
    - [1.2.5 执行器](#125-执行器)
  - [1.3 小结](#13-小结)
- [2 一条SQL更新语句是如何执行的](#2-一条sql更新语句是如何执行的)
  - [2.1 redo log](#21-redo-log)
  - [2.2 binlog](#22-binlog)
  - [2.3 两阶段提交](#23-两阶段提交)
  - [2.4 小结](#24-小结)
- [3 思考题](#3-思考题)
- [参考资料](#参考资料)

<!-- /MarkdownTOC -->

# 1 一条SQL查询语句是如何执行的

平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：

```mysql
mysql> select * from T where ID=10；
```

我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。

所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。

## 1.1  MySQL 基本架构概览

MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。

下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210611090819527.png" width="500px"/>
</div>
 MySQL 主要分为 Server 层和存储引擎层：

* **Server层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。有一个通用的日志模块 **binlog** 日志模块。
* **存储引擎层**：负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 **redolog** 日志模块。
  * InnoDB 存储引擎：MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。
  * MyISAM 存储引擎：MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。
  * Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。
  * NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。
  * Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。

## 1.2 Server 层基本组件介绍

### 1.2.1 连接器

连接器主要负责跟客户端建立连接、获取权限、维持和管理连接等操作。连接命令一般是这么写的：

```shell
mysql -h$ip -P$port -u$user -p
```

* 如果用户名或密码不对，会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
* 如果用户名密码认证通过，连接器会到权限表里面查出所拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。

这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

连接完成后，如果没有后续动作，这个连接就会处于空闲状态，可以使用`show processlist;`命令看到它。下面Command 列显示为“Sleep”的这一行，说明系统中目前有一个空闲连接。

```mysql
mysql> show processlist;
+----+------+-----------+------+---------+------+----------+------------------+
| Id | User | Host      | db   | Command | Time | State    | Info             |
+----+------+-----------+------+---------+------+----------+------------------+
|  4 | root | localhost | NULL | Query   |    0 | starting | show processlist |
|  5 | root | localhost | NULL | Sleep   |    5 |          | NULL             |
+----+------+-----------+------+---------+------+----------+------------------+
```

客户端如果长时间没有动静，连接器会自动断开。这个时间由参数`time_timeout`控制，默认为8个小时。

数据库中，**长连接**是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接指每次执行完很少的几次查询就断开连接，下次查询需要重新建立一个。（建立连接过程比较复杂，所以还是建议使用长连接）

但是如果全部使用长连接的化，你可能会发现，有些时候MySQL占用内存上涨很快，这是因为MySQL在执行过程中临时使用的内存时管理在连接对象里的。这些资源会在连接断开的时候释放。所以长连接累积下来，可能会导致内存占用太大，会被系统强行杀掉（OOM），从现象上来看，就是MySQL异常重启了。

如何解决这个问题呢?可以考虑如下两种方案。

* 定期断开长连接。使用一段时间后，或者程序里面判断执行过一个占用内存的大量查询后，断开连接，之后要查询再重连。
* 如果使用的时MySQL 5.7 或更新版本，可以再每次执行一个比较大的操作后，通过`mysql_reset_connection`来重新初始化连接资源。这回过程不需要重连做权限验证，但是会将连接恢复到刚钢创建完时的状态。

### 1.2.2 查询缓存

连接建立完成后，就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。

MySQL拿到一个查询请求后，会先到查询缓存看看，这个 sql 之前是否执行过。之前执行过的语句及其结果可能会以key-value对的形式缓存在内存中，key是查询的语句，value是查询的结果。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。

**但是大多数情况下建议不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**

因为查询缓存失效在实际业务场景中可能会非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。对于不经常更新的数据来说，使用缓存还是可以的。比如一个系统配置表，这张表的查询适合使用查询缓存。

可以将参数`query_cache_type`设置成`DEMAND`，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用`SQL_CACHE`显式指定，像下面这个语句一样：

```mysql
mysql> select SQL_CACHE * from Table1 where ID=10；
```

需要注意的是，MySQL 8.0 版本就删除了缓存的功能，也就是说8.0版本开始彻底没有这个功能了。

### 1.2.3 分析器

MySQL 没有命中缓存，那么就会进入分析器真正地执行语句了，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：

**第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select。然后提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

**第二步，语法分析**，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。如果语法不对，就会收到一个`"You have an error in your SQL syntax"`的错误提醒，比如下面这个语句select少打了开头的字母“s”。

```mysql
mysql> elect * from t where ID=1;

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```

一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。

完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

### 1.2.4 优化器 

优化器的作用就是它认为的最优的执行方案去执行，比如在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面的这样的语句，这个语句时执行两个表的join：

```mysql
mysql> select * from t1 join t2 using(ID) where t1.c = 10 and t2.d = 20;
```

* 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
* 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有所不同，而优化器的作用就是决定选择哪一个方案。

优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

### 1.2.5 执行器

MySQL通过分析器知道了要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示。

```mysql
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T
```

比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了。

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。

你会在数据库的慢查询日志中看到一个`rows_examined`的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟rows_examined并不是完全相同的。**

## 1.3 小结

总结一下，当一条查询MySQL语句执行时，主要经历如下流程：

```powershell
	连接器 --> 查询缓存 --> 分析器 --> 优化器 --> 执行器 --> 执行引擎
```

* 连接器：管理连接，权限校验。
* 查询缓存：在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果命中缓存直接返回结果；如过没有命中缓存，进行下一步。
* 分析器：通过词法分析，提取sql语句的关键元素；通过语法分析，验证sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。
* 优化器：确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。

* 执行器：调用数据库引擎接口，返回引擎的执行结果。在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。

# 2 一条SQL更新语句是如何执行的

我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：

```mysql
mysql> create table T(ID int primary key, c int);
```

如果要将ID=2这一行的值加1，SQL语句就会这么写：

```mysql
mysql> update T set c=c+1 where ID=2;
```

可以说，查询语句这一套流程，更新语句也会同样走一遍。你既然要更新，要么肯定要在数据库中定位到相关数据。但与查询流程不一样的是，更新流程还涉及两个重要的日志模块：**redo log（重做日志）与binlog（归档日志）**。

## 2.1 redo log

这里可以引用《孔乙己》的故事理解：酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。

如果有人要赊账或者还账的话，掌柜一般有两种做法：

- 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
- 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。

而粉板和账本配合的整个过程，其实就是MySQL里经常说到的**WAL技术**，WAL的全称是**`Write-Ahead Logging`**，它的关键点就是**先写日志，再写磁盘**，也就是先写粉板，等不忙的时候再写账本。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。

与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/2021061110060971.png" width="450px"/>
</div>
write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。

## 2.2 binlog

MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。

我想你肯定会问，**为什么会有两份日志呢**？

实际上，MySQL最开始 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

这**两种日志有三点不同**：

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

**binlog的三种模式**：

* **Row Level**：`ROW` 基于行的复制(`row-based replication, RBR`)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改。
  * 优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题； 
  * 缺点：会产生大量的日志，尤其是`alter table`的时候会让日志暴涨，效率和空间上消耗是最大的。
* **Statement Level（默认）**：`STATMENT` 基于`SQL`语句的复制(`statement-based replication, SBR`)，每一条会修改数据的SQL语句会记录到`binlog`中。 
  * 优点：不需要记录每一行的变化，减少了`binlog`日志量，节约了`IO`, 从而提高了性能； 
  * 缺点：在某些情况下会导致主从数据不一致，比如执行`sysdate()`、`sleep()`等。
* **Mixed Level**：`MIXED` 基于`STATMENT`和`ROW`两种模式的混合复制(`mixed-based replication, MBR`)，一般的复制使用`STATEMENT`模式保存`binlog`，对于`STATEMENT`模式无法复制的操作使用`ROW`模式保存`binlog`。

就在InnoDB 模式下来探讨上述语句的执行流程。流程如下：

* 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
* 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
* 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
* 执行器生成这个操作的binlog，并把binlog写入磁盘。
* 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210611101237224.png" width="450px"/>
</div>

你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。

## 2.3 两阶段提交

为什么必须有“两阶段提交”呢？**这是为了让两份日志之间的逻辑一致**。这里就需要探讨一个问题，**MySQL是怎样让数据库恢复到半个月内任意一秒的状态呢？**

binlog会记录所有的日志操作，并采用的“追加写”的形式。如果你的DBA承诺说半个月可以恢复，那么备份系统中一定可以保存着最近半个月的所以binlog，同时系统会定期做整库备份，这里的定期取决于系统的重要性，可以是一天一备，也可以是一周一备。

当要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那么可以这么做：

* 首先，找到最近的一次全量备份，如果运气好，可能是昨天晚上的一个备份，从这个备份恢复到临时库；
* 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。

这样，你的临时库就根误删之前的线上库一样，然后就可以把表数据从临时库中取出来，按需要恢复到线上库去了。

好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。

由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

1. **先写redo log后写binlog**。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
   但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
   然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。
2. **先写binlog后写redo log**。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？

其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。

简单说，**redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致**。采用两阶段提交来恢复数据时，redo log 用于恢复主机故障时的未更新的物理数据，binlog用于备份操作。每个阶段的log操作都是记录在磁盘中的，在恢复数据时，redo log状态为commit则说明binlog也成功，直接恢复数据；如果redo log 时prepare，则需要查询对应的binlog事务是否成功，决定回滚还是执行。 

## 2.4 小结

当一条更新MySQL语句执行时，大致流程与查询语句MySQL执行流程一致。但需要注意的是，只要有对一个表更新了，这个表上之前的所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。所以我们不建议使用查询缓存。

除此之外，更新流程还涉及两个非常重要的日志模块：redo log（重做日志） 和 binlog（归档日志）。

redo log是物理日志，记录的是“在某个数据页做了什么修改”；binlog 是逻辑日志，记录的是每个sql语句的原始逻辑。

| 对比     | redo log                                                     | binlog                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 文件大小 | 大小固定<br/>`innodb_log_files_in_group`：日志文件数量<br/>`innodb_log_file_size`：每个日志文件大小 | `max_binlog_size `：每个日志文件大小                         |
| 实现方式 | 引擎层实现，`InnoDB `引擎独有                                | Server层实现，所有引擎皆可使用                               |
| 记录方式 | "循环写"，当写到结尾时<br/>会回到开头循环写日志（覆盖）      | 追加写，文件写到一定大小后<br/>切换到下一个（不会覆盖）(体现归档的功能) |
| 适用场景 | 提升性能和崩溃恢复(crash-safe)                               | 主从复制和数据回滚/恢复                                      |

`binlog `日志只用于归档，只依靠 `binlog `是没有`
crash-safe `能力的。但只有 `redo log `也不行，因为 `redo log `是 `InnoDB `特有的，且日志上的记录落盘后会被覆盖掉。因此需要 `binlog `和 `redo log`二者同时记录，通过"两阶段提交"，维持数据逻辑一致性，也能保证当数据库发生宕机重启时，数据不会丢失。

相关参数设置建议：

* `innodb_flush_log_at_trx_commit`：设置为1，表示每次事务的redo log都直接持久化到磁盘（注意是这里指的是redo log日志本身落盘），异常重启之后数据不丢失。

* `sync_binlog`： 设置为1，表示每次事务的binlog都直接持久化到磁盘（注意是这里指的是binlog日志本身落盘），保证mysql重启后binlog记录是完整的。

# 3 思考题

**思考题1**：如果表T中没有字段k，而你执行了这个语句 `select * from T where k=1`, 那肯定是会报“不存在这个列”的错误`“Unknown column ‘k’ in ‘where clause’”`。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

* 《高性能MySQL》里提到了解析器和预处理器。机械其处理语法和解析查询，生成一颗对应的解析树。预处理器进一步检查解析树的合法性。比如：数据表和数据列是否存在，别名是否有歧义等。当通过预处理器则生成新的解析树，再提交给优化器。所以这个错误应该是在分析器处理阶段。

------

**思考题2**：上面说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？

* “一天一备”相较“一周一备“，好处在于”最长恢复时间”更短。

* 在“一天一备”的模式里，最坏的情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份。而“一周一备“最坏情况就是谣应用一周binlog了。
* 系统对应指标就是RTO（恢复目标时间）。但是“一天一备”这种更频繁地全量备份需要消耗更多的存储空间，所以这个RTO也是需要成本换来的，就需要你根据业务重要性来评估。

------

**思考题3**：为什么要有redo log？

* （1）保证InnoDB 的持久性；（2）redo log 要进行磁盘操作是与Buffer Pool `磁盘随机写入`比， redo log 的磁盘操作有几个优势：`1.引入redo log buffer，按组写入，不是一条条写。2.磁盘为顺序写入。`这样， redo log 日志的磁盘操作比起 Buffer Pool 的磁盘操作性能要好很多。

------

**思考题4**：binlog为什么不具备crash-safe的能力？

* 如果 binlog 写入成功了，数据还没写入磁盘，数据库异常崩溃，重启后主库没有这部分数据，而通过 binlog 同步的从库却有了这部分配置，导致主从数据不一致。
* 如果 数据写入磁盘，binlog 写入失败了，数据库异常崩溃，重启后主库有这部分数据，而通过 binlog 同步的从库没有这部分数据，导致主从数据不一致。

# 参考资料

* [必须了解的mysql三大日志-binlog、redo log和undo log](https://juejin.cn/post/6860252224930070536)
* [MySQL实战45讲](https://time.geekbang.org/column/intro/139)

