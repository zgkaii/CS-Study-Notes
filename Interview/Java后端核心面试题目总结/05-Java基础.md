<!-- MarkdownTOC -->
- [01 谈谈你对Java平台的理解？"Java是解释执行"这句话对吗？](#01-谈谈你对java平台的理解java是解释执行这句话对吗)
- [02 什么是面向对象？它与面向过程有什么区别？](#02-什么是面向对象它与面向过程有什么区别)
- [03 谈谈接口和抽象类有什么区别？](#03-谈谈接口和抽象类有什么区别)
- [04 什么是内部类？匿名内部类呢？](#04-什么是内部类匿名内部类呢)
- [05 Java 中的几种基本数据类型是什么？各自占用多少字节？](#05-java-中的几种基本数据类型是什么各自占用多少字节)
- [06 String、StringBuffer、StringBuilder有什么区别？String为什么是不可变的？](#06-stringstringbufferstringbuilder有什么区别string为什么是不可变的)
- [07 equals()与==和hashcode()的区别与联系？](#07-equals与和hashcode的区别与联系)
- [08 int和Integer有什么区别？](#08-int和integer有什么区别)
- [09 Exception和Error有什么区别？运行时异常与一般异常又有什么区别？](#09-exception和error有什么区别运行时异常与一般异常又有什么区别)
- [10 谈谈final、finally、 finalize有什么不同？](#10-谈谈finalfinally-finalize有什么不同)
- [11 什么是Java序列化？](#11-什么是java序列化)
- [12 如何实现对象拷贝/克隆 (深拷贝与浅拷贝)？](#12-如何实现对象拷贝克隆-深拷贝与浅拷贝)
- [13 强引用、软引用、弱引用、虚引用有什么区别？](#13-强引用软引用弱引用虚引用有什么区别)
- [14 说说反射机制及其用途？反射有什么缺点？](#14-说说反射机制及其用途反射有什么缺点)
- [15 动态代理是基于什么原理？它与静态代理有什么区别？](#15-动态代理是基于什么原理它与静态代理有什么区别)
- [16 Java提供了哪些IO方式？ NIO如何实现多路复用？](#16-java提供了哪些io方式-nio如何实现多路复用)
- [17 Java有几种文件拷贝方式？哪一种最高效？](#17-java有几种文件拷贝方式哪一种最高效)
- [18 什么时候用断言（assert）？](#18-什么时候用断言assert)
- [19 Java对象的创建方式有几种呢？](#19-java对象的创建方式有几种呢)
- [20 什么是注解？](#20-什么是注解)
- [21 Object有哪些方法，有什么作用？](#21-object有哪些方法有什么作用)
- [22 Java8 Stream流实现原理？](#22-java8-stream流实现原理)
- [23 既然有了字节流，为什么还要有字符流?](#23-既然有了字节流为什么还要有字符流)
- [24 Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？](#24-java-泛型了解么什么是类型擦除介绍一下常用的通配符)
- [25 不同字符集编码的字节数？](#25-不同字符集编码的字节数)
- [26 & 和 && 的区别？](#26--和--的区别)
- [27 Java不同版本有哪些新特性？](#27-java不同版本有哪些新特性)

<!-- /MarkdownTOC -->

## 01 谈谈你对Java平台的理解？"Java是解释执行"这句话对吗？

Java作为一门面向对象的编程语言，最显著的特性有两个方面，一是**跨平台**的特性，也就是所谓的“一次编译，到处运行”；另外一个特性是Java通过**垃圾回收器**（GC）回收分配和回收内存。而实现这些特性的基础就是Java虚拟机（JVM），所以我们经常说JVM是Java语言的核心。

"Java是解释执行"这句话并不完全正确。我们编写的`.java`源文件先是通过`javac`编译器编译成`bytecode`字节码文件，然后通过JVM内嵌的解释器将字节码文件转换成机器码。但是，我们常用的JVM例如`Hotspot JVM`中，提供了 JIT（Just-In-Time）编译器，也就是所谓的动态编译器。**JIT编译器**能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就是属于编译执行了。



## 02 什么是面向对象？它与面向过程有什么区别？

面向对象（OOP）是一种编程范式或者说是一种编程风格。它以**类或对象**作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。

相较于面向对象编程，面向过程编程以**过程或者方法**作为组织代码的基本单元。起主要的特点就是数据和方法相分离。

面向对象相较于面向过程编程有如下两个优势：

* 面向对象编程更能应付大规模的复杂程序开发；
* 面向对象编程有更丰富的特性（封装、抽象、继承、多态），写出的代码扩展性、复用性、可维护性更好。

**封装（Encapsulation）**

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 `private、protected、public` 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

**抽象（Abstraction）**

封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 `interface` 关键字语法）或者抽象类（比如 Java 中的 `abstract` 关键字语法）这两种语法机制，来实现抽象这一特性。

抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

**继承（Inheritance）**

继承是用来表示类之间的 `is-a` 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

编程语言需要提供特殊的语法机制来支持，比如 Java 使用 `extends` 关键字来实现继承，C++ 使用冒号（`class B : public A`），Python 使用 `parentheses()`，Ruby 使用 `<`。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。

继承主要是用来解决代码复用的问题；但是如果过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。

**多态（Polymorphism）**

多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing，在Java中多态一般通过“继承+重写”的方式实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

多态存在的三个必要条件：（1）继承（2）重写（3）父类引用指向子类对象（向上转型）。 

**重载和重写的区别？**

（1）重载：编译时多态、同一个类中同名的方法具有不同的参数列表、不能根据返回类型进行区分（因为函数调用时不能指定类型信息，编译器不知道你要调哪个函数）； 

（2）重写（又名覆盖）：运行时多态、子类与父类之间、子类重写父类的方法具有相同的返回类型、更好的访问权限。



## 03 谈谈接口和抽象类有什么区别？

（1）抽象类和接口的语法特性

| 比较点            | 抽象类 | 接口                  |
| ----------------- | ------ | --------------------- |
| 成员变量类型      | 无限制 | `public static final` |
| 静态代码/静态方法 | 无限制 | 禁止                  |
| 类的继承          | 单继承 | 可多继承              |
| 方法体            | 可包含 | 禁止                  |

（2）设计目的

* 抽象类是对整个类整体进行抽象，包括属性、行为，是一种`is-a`的**继承**关系，主要是为了解决代码复用问题；而接口仅仅是对方法的抽象，是一种`has-a`的**组合**关系，表示某一组行为特性，主要是为了解耦，隔离接口和具体实现，提高代码的扩展性。
* 抽象类作为很多子类的父类，它是一种模板式设计；接口是一种行为规范，它是一种辐射式设计。

 **继承和组合的区别在哪？**

- 继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 `extends` 明确标识，在设计时一般没有争议性。
- 组合：组合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即 `has-a` 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。
  - 比如，计算机与 CPU 、公司与员工的关系等。
  - 表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。详细可参考 [《怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？》](https://www.zhihu.com/question/21862257) 文章。



## 04 什么是内部类？匿名内部类呢？

简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。当然，详细的可以看看 [搞懂 JAVA 内部类](https://juejin.cn/post/6844903566293860366) 文章。

**内部类的作用是什么？**

内部类提供了更好的封装，除了该外部类，其他类都不能访问。

**Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？**

可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。

**内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？**

一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。



## 05 Java 中的几种基本数据类型是什么？各自占用多少字节？

Java支持的数据类型包括基本数据类型和引用类型。

其中**基础类型**有如下8种：

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   |
| ------------ | ------- | -------- | ------------------------------------------ |
| 字节型       | byte    | 1 字节   | -128~127                                   |
| 短整型       | short   | 2 字节   | -32768~32767                               |
| 整型         | int     | 4字节    | -2147483648~2147483647                     |
| 长整型       | long    | 8字节    | -9223372036854775808L~9223372036854775807L |
| 单精度浮点型 | float   | 4字节    | +/-3.4E+38F（6~7 个有效位）                |
| 双精度浮点型 | double  | 8 字节   | +/-1.8E+308 (15 个有效位）                 |
| 字符型       | char    | 2 字节   | ISO 单一字符集                             |
| 单元格       | boolean | 1 字节   | true 或 false                              |

**引用类型**声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。

- 引用类型包括类、接口、数组等。
- 特别注意，String 是引用类型不是基本类型。

**什么是值传递和引用传递？**

- 值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。
- 引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。

一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。



## 06 String、StringBuffer、StringBuilder有什么区别？String为什么是不可变的？

String是Java中非常基础而又重要的类，它提供了构造和处理字符串的各种逻辑。String类是典型的immutable类，被声明为final class，所以的属性都是不可变的。也正是也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。这些频繁的操作往往对应用性能有很大的影响。

StringBuffer是为了解决String拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。

StringBuilder是Java 1.5中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。

> 效率：StringBuilder > StringBuffer > String

查看源码发现，String类是被final关键字修饰，也就是**说String类是不可变的，这样做的好处在哪里呢**？

* **保证String对象的安全性**。网络连接地址 URL、文件路径 path、还有反射机制所需要 的 String 参数等，假若 String 不是固定不变的，将会引起各种安全隐患。
* **保证hash值不会被频繁变更，确保了唯一性**。Java 中 String 对象的哈希码被频繁地使用，比如在 HashMap 等容器中。 字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码；
* **字符串常量池的需要**。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 `String str = new String(“abc”)`。
  * 当代码中使用第一种方式创建字符串对象时，JVM首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。
  * `String str = new String(“abc”) `这种方式，首先在编译类文件时，"abc"常量字符串将会放入到常量结构中，在类加载时，“abc"将会在常量池中创建；其次，在调用 new 时，JVM命令将会调用 String 的构造函数，同时引用常量池中的"abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。



## 07 equals()与==和hashcode()的区别与联系？

[==、equals()与hashcode()的区别和联系](https://blog.csdn.net/KAIZ_LEARN/article/details/113704826)已经阐述清楚：

* **==运算符**比较基本数据类型时，比较的是实际内容值是否相同；比较引用数据类型时，比较的是堆内存地址是否相同。
* **equals() **方法主要用于判断两个对象的值是否相等（当然这是在equals()被重写的情况下）；未重写的equals() 方法与`==`运算符类似，比较的是对象的内存地址。
* 需要注意的是当equals()方法被重写时，hashCode()也要被重写；

引申问题：**为什么equals()方法被重写时，hashCode()也要被重写？**

* hashCode() 的作用是获取哈希码（hashcode），也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。在使用Object的equals()方法进行对象比较时，Java会首先计算出两个对象的hashcode并进行对比（这个过程非常简单而且节省JVM的时间），如果两个对象的hashcode相同，则直接判定为两对象相等。

* 按照一般hashCode()方法的实现来说，equals()相等的两个对象，hashcode()必须保持相等；equals()不相等的两个对象，hashcode()未必不相等。
* 因此，在使用`HashSet, HashTable, HashMap`等等这些本质是**散列表**数据结构的集合类时，重写hashCode()是很有必要的。



## 08 int和Integer有什么区别？

Java语言中，有8类原始数据类型（boolean、byte 、short、char、int、float、double、long），int就是其中一类。Integer是对int的包装类，它有一个int 类型的字段存储数据，并且提供了比如数学运算，字符串转换等基本操作。Java 5引进了自动装箱与自动拆箱的功能，从`int->Integer`的过程即自动装箱，`Integer->int`即自动拆箱。

引申问题1：**有了基本类型为什么还需要包装类**？

* Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。
* 另外，使用ArrayList，HashMap时，像int，double等基本类型是放不进去的，因为容器都是装object的，这时就需要这些基本类型的包装类了。

引申问题2：**基本类型和包装类型二者的主要区别**？

* 声明方式不同：基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间。
* 存储方式及位置不同：基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用。
* 初始值不同：基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null。
* 使用方式不同：基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。


引申问题3：**Integer 的值缓存范围**？

* 关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，**这个值默认缓存是 -128 到 127 之间。**



## 09 Exception和Error有什么区别？运行时异常与一般异常又有什么区别？

Exception和Error都是Throwable类的子类，但它们体现了Java平台设计者处理异常时的不同思想。Exception是程序正常运行中，可以预料的意外情况，应该及时捕获进行相应处理，就比如我们人体感冒一样；而Error是正常情况下不太可能出现的情况，绝大多数的的Error都会导致程序（如JVM）处于非正常、不可恢复的状态，例如`OutofMemory`内存溢出错误。

Exception可以分为可检查异常和不检查异常。可检查就是指在编译器就得显示地捕获处理，是编译期检查的一部分；而不可查异常就是所谓的**运行时异常**，类似`NullPointerException、ArrayIndexOutOfBoundsException `之类，通常是一些代码可以避免的逻辑错误，并不一定要在编译期就强制指出。

常见的异常有：

* NullPointerException：当应用程序试图访问空对象时，则抛出该异常。 
* SQLException：提供关于数据库访问错误或其他错误信息的异常。
* IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
* FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。 
* IOException：当发生某种 I/O 异常时，抛出此异常。此类是失败或中断的 I/O 操作生成的异常的通用类。
* ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。
* llegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。



## 10 谈谈final、finally、 finalize有什么不同？

final 修饰类、方法和变量有不同的含义。final修饰的class不可以被继承，final修饰的变量不可被修改，final修饰的方法也是不可被重写（overrride）的。

finally 是Java保证重点代码一定要被执行的一种机制。我们可以使用`try-finally`和`try-catch-finally`来关闭JDBC连接、保证unclok锁等动作。

finalize 是`java.lang.Object`类中一个方法，设计目的是用来保证对象在垃圾回收前完成特定的资源回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。



## 11 什么是Java序列化？

序列化的原本意图是希望对一个Java对象作一下“变换”，变成字节序列，这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失，另外变换成字节序列也更便于网络运输和传播，所以概念上很好理解：

- **序列化**：把Java对象转换为字节序列。
- **反序列化**：把字节序列恢复为原先的Java对象。

> 我们不能将序列化局限在 Java 对象转换成二进制数组，我们还可以将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串。

**Serializable接口有什么用呢？**

将需要被序列化的类，实现 `Serializable` 接口，该接口没有需要实现的方法，`implements Serializable` 只是为了标注该对象是可被序列化的。

如果一个对象既不是**字符串**、**数组**、**枚举**，而且也没有实现`Serializable`接口的话，在序列化时就会抛出`NotSerializableException`异常！

**Java 序列化中，如果有些字段不想进行序列化怎么办？**

凡是被`static`修饰的字段都是不会被序列化的。因为序列化保存的是**对象的状态**而非类的状态，所以会忽略`static`静态域也是理所应当的。

对于不想进行序列化的变量，一般使用 `transient` 关键字来修饰。

- 当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。
- 当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。
- `transient` 只能修饰变量，不能修饰类和方法。



## 12 如何实现对象拷贝/克隆 (深拷贝与浅拷贝)？

浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。

深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且**修改新对象不会影响原对象**。

实现**浅拷贝**：实现 Cloneable 接口，并重写 Object 类中的 `#clone()` 方法。

实现**深拷贝**一般有两种方式：

- 实现 Cloneable 接口，并重写 Object 类中的 `#clone()` 方法也可以实现深拷贝。与浅拷贝的区别在于重写`#clone()`方法时创建拷贝类的一个新对象，这样就和原始对象相互独立。
- 实现 Serializable 接口，通过对象的序列化和反序列化实现拷贝，可以实现真正的深拷贝。

具体的代码实现，可以看看 [《Java深拷贝和浅拷贝》](https://juejin.cn/post/6844903806577164302) 文章。

实际场景下，我们使用的拷贝比较少，更多是对象之间的属性拷贝。例如说，将 DO 的属性复制到 DTO 中，又或者将 DTO 的属性复制到 VO 中。此时，我们一般使用 BeanUtils 工具类。具体的使用，看看 [《浅谈 BeanUtils 的拷贝，深度拷贝》](https://www.cnblogs.com/tison/p/7840647.html) 文章。



## 13 强引用、软引用、弱引用、虚引用有什么区别？

这些不同的引用类型的区别主要体现在垃圾回收的时候可达性的区别。

强引用——不回收

* 强引用就是我们常见的普通对象引用，只要强引用还指向一个对象（可触及），垃圾回收器就永远不会回收掉它。相对地，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下都是可以被回收的。所以，**强引用是造成Java内存泄漏的主要原因（循环依赖）**。

软引用——内存不足回收

* 软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集。在系统发生内存溢出前时，JVM才会回收这些被弱引用关联的对象。软引用通常用来实现内存敏感的缓存。比如：**高速缓存**就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

弱引用——发现即回收

* 在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。软引用、弱引用都非常适合来保存那些**可有可无的缓存数据**。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

虚引用——对象回收跟踪

* 虚引用又称“幻象引用”，我们不能通过它访问对象。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。**为一个对象设置虚引用关联的目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知**。



## 14 说说反射机制及其用途？反射有什么缺点？

Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，**反射机制指的是程序在运行时能够获取自身的信息的一种能力。**

通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。

反射的主要应用场景有：

- **开发通用框架** - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。例如Spring框架实例化对象时，Spring 会读取配置文件`applicationContext.xml`并解析出里面所有的标签实例化到`IoC`容器中；又比如使用JDBC连接数据库时，指定连接数据库的`驱动类`时用到反射加载驱动类。
- **动态代理** - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。
- **注解** - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。
- **可扩展性功能** - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。

**反射中Class.forName 和 ClassLoader 区别？**

这两者，都可用来对类进行加载。差别在于：

- `Class#forName(...)` 方法，除了将类的 `.class` 文件加载到JVM中之外，还会对类进行解释，执行类中的 `static` 块。
- `ClassLoader`只干一件事情，就是将 `.class` 文件加载到 JVM中，不会执行 `static` 中的内容，只有在 `newInstance`才会去执行 `static` 块。

> `Class#forName(name, initialize, loader)` 方法，带参函数也可控制是否加载 `static` 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。

**反射的优缺点**

* 优点：运行期类型的判断，`class.forName()` 动态加载类，提高代码的灵活度；
* 缺点：性能开销大，没有安全限制的环境运行，内部暴露。



## 15 动态代理是基于什么原理？它与静态代理有什么区别？

动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。

实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。

这里以JDK的动态代理为例：

首先必须定义一个接口，还要有一个 InvocationHandler（将实现接口的类的对象传递给它）处理类。再有一个工具类 Proxy（习惯性将其称为代理类，因为调用它的 newInstance() 可以产生代理对象，其实它只是一个产生代理 对象的工具类）。利用到 InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。

每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 handler， 当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：

```java
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
```

* proxy: 指代我们所代理的那个真实对象 

* method: 指代的是我们所要调用真实对象的某个方法的 Method 对象 

* args: 指代的是调用真实对象某个方法时接受的参数 

Proxy 类的作用是动态创建一个代理对象的类。它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法： 

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,
InvocationHandler handler) throws IllegalArgumentException
```

* loader：一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载； 

* interfaces：一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一 组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 

* handler：一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上。 

通过 Proxy.newProxyInstance 创建的代理对象是在 JVM运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，2也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象。



## 16 Java提供了哪些IO方式？ NIO如何实现多路复用？

Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。

首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。`java.io` 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。

很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。

第二，在 Java 1.4 中引入了 NIO 框架（`java.nio` 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。



## 17 Java有几种文件拷贝方式？哪一种最高效？

Java 有多种比较典型的文件拷贝实现方式，比如：利用 `java.io` 类库，直接为源文件构建一个 `FileInputStream` 读取，然后再为目标文件构建一个 `FileOutputStream`，完成写入工作。

或者，利用 `java.nio` 类库提供的 transferTo 或 transferFrom 方法实现。

当然，Java 标准类库本身已经提供了几种 `Files.copy` 的实现。对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式**可能更快**，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。



## 18 什么时候用断言（assert）？

断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。

- 一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。

- 断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为`true`；如果表达式的值为 `false` ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：

  ```java
  assert(a > 0); // throws an AssertionError if a <= 0
  ```

  - 断言可以有两种形式：
    - `assert Expression1;` 。
    - `assert Expression1 : Expression2;` 。
    - Expression1 应该总是产生一个布尔值。
    - Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。

- 要在运行时启用断言，可以在启动 JVM时使用 `-enableassertions` 或者 `-ea` 标记。要在运行时选择禁用断言，可以在启动 JVM时使用 `-da` 或者 `-disableassertions` 标记。要在系统类中启用或禁用断言，可使用 `-esa` 或 `-dsa` 标记。还可以在包的基础上启用或者禁用断言。

当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。

另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。



## 19 Java对象的创建方式有几种呢？

Java对象创建方式有5种：

- 用**new关键字**创建对象，需要使用构造器。
- 使用**反射机制**创建对象，用**Class类或Constructor类的newInstance()方法**，需要使用构造器。 
- 通过**Object类的clone**方法，需要实现Cloneable接口，重写Object类的clone方法。
- 使用**反序列化**。



## 20 什么是注解？

从 Java5 版本之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation），是 Java 平台中非常重要的一部分。注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。

注解常见的作用有以下几种：

* 生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @see、@param 和 @return 等；

* 跟踪代码依赖性，实现替代配置文件功能。比较常见的是Spring 2.5开始的基于注解配置，作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；

* 在编译时进行格式检查。如把 @Override 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。



## 21 Object有哪些方法，有什么作用？

* clone 方法：用于创建并返回当前对象的一份拷贝；
* getClass 方法：用于返回当前运行时对象的 Class； 
* toString 方法：返回对象的字符串表示形式；
* finalize 方法：实例被垃圾回收器回收时触发的方法； 
* equals 方法：用于比较两个对象的内存地址是否相等，一般需要重写； 
* hashCode 方法：用于返回对象的哈希值；
* notify 方法：唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会唤醒一个。 
* notifyAll 方法：作用跟 notify() 一样，只不过会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 
* wait 方法：让当前对象等待； 
* .......



## 22 Java8 Stream流实现原理？

> 参考[https://time.geekbang.org/column/article/98582](https://time.geekbang.org/column/article/98582)

“Stream流”是一个集合元素的函数模型，它并不是集合容器，也不是数据结构，其本身并不存储任何元素或地址。可以把它理解为一个来自数据源并支持聚合操作的元素队列。

从大的设计方向上来说，Stream 将整个操作分解成了链式结构，不仅简化了遍历操作，还为实现了并行计算打下了基础。

从小的分类方向上来说，Stream 将遍历元素的操作和对元素的计算分为中间操作和终结操作，而中间操作又根据元素之间状态有无干扰分为有状态和无状态操作，实现了链结构中的不同阶段。

**在串行处理操作中，**Stream 在执行每一步中间操作时，并不会做实际的数据操作处理，而是将这些中间操作串联起来，最终由终结操作触发，生成一个数据处理链表，通过 Java8 中的 `Spliterator` 迭代器进行数据处理；此时，每执行一次迭代，就对所有的无状态的中间操作进行数据处理，而对有状态的中间操作，就需要迭代处理完所有的数据，再进行处理操作，最后就是进行终结操作的数据处理。

**在并行处理操作中，**Stream 对中间操作基本跟串行处理方式是一样的，但在终结操作中，Stream 将结合 `ForkJoin` 框架对集合进行切片处理，`Splititerator` 中的 `estimateSize` 方法会估算出分片的数据量，`ForkJoin` 框架将每个切片的处理结果 Join 合并起来。

最后就是要注意 Stream 的使用场景。在循环迭代次数较少的情况下，常规的迭代方式性能反而更好；在单核 CPU 服务器配置环境中，也是常规迭代方式更有优势；而在大数据循环迭代中，如果服务器是多核 CPU 的情况下，Stream 的并行迭代优势明显。所以我们在平时处理大数据的集合时，应该尽量考虑将应用部署在多核 CPU 环境下，并且使用 Stream 的并行迭代方式进行处理。



## 23 既然有了字节流，为什么还要有字符流?

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题是这个过程非常耗时，如果我们还不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。



## 24 Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息例如：List 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。 

类型擦除：**泛型信息只存在于代码编译阶段，在进入 JVM之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除**。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 `< T >` 则会被转译成普通 的 Object 类型，如果指定了上限如 `< T extends String >` 则类型参数就被替换成类型上限。 

**补充**

```java
List<String> list = new ArrayList<String>();
```

1、两个 String 其实只有第一个起作用，后面一个没什么用，只不过 JDK7 才开始支持 ` List<String>list = new
ArrayList<> ` 这种写法。

2、第一个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作用，之后编译器会擦除泛型占位符，以保证兼容以前的代码。

**什么是泛型中的限定通配符和非限定通配符 ?**

限定通配符对类型进行了限制。有两种限定通配符，一种是`< ? extends T >` 它通过确保类型必须是 T 的子类来设定类型的上界，另一种是`< ? super T >`它通过确保类型必须是 T 的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 `< ? >` 表示了非限定通配符，因为 `< ? >` 可以用任意类型来替代。

**`List<? extends T> 和 List <? super T> 之间有什么区别 ?`** 

这两个 List 的声明都是限定通配符的例子，`List< ? extends T >` 可以接受任何继承自 T 的类型的 List。而`List < ? super T >` 可以接受任何 T 的父类构成的 List。例如 `List< ? extends Number >` 可以接受 `List< Integer >` 或 `List< Float >` 。 

> Array 不支持泛型，要用 List 代替 Array，因为 List 可以提供编译器的类型安全保证，而Array却不能。



## 25 不同字符集编码的字节数？

**ascii**：美国使用低7位表示英文的128字符，高一位统一为0，后来欧洲发现不够用，使用全字节编码。

**GB2312**：汉字编码，使用2个字节表示汉字，只能表示65536个汉字字符，所以有的汉字显示不出来。

**unicode**：为了统一符号，所以发明了unicode，可以表示100多万个符号，但是没有规定如何存储，所以出现了unicode的多种存储方式。

**utf-8**：变长的编码方式，是unicode的重要实现方式之一，考虑了如何存储。utf-8的中文是一个汉字一般占3个字节，常见的编码方式：`1110xxxx 10xxxxxx 10xxxxxx`。



## 26 & 和 && 的区别？

Java 中 `&&` 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。 

`&&`：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；

`&`：不管第一个表达式结果是否为 true，第二个都会执行。除此之外，& 还可以用作位运算符：当 & 两边的表达式不是 Boolean 类型的时候，& 表示按位操作。



## 27 Java不同版本有哪些新特性？

> 可参考[new-features-from-jdk8-to-jdk14](https://github.com/zgkaii/CS-Study-Notes/blob/master/05-Java/05-new-features/new-features-from-jdk8-to-jdk14.md)一文。

**Java8 新特性**：

- **Lambda 表达式** − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。
- **方法引用** − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与Lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
- 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
- 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
- **Stream API** −新添加的Stream API（`java.util.stream`） 把真正的函数式编程风格引入到Java中。
- Date Time API − 加强对日期与时间的处理。
- **Optional 类** − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
- Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。
- ... ...

**Java11 新特性**：

* **增强字符串操作**：JDK 11增加了一系列好用的字符串处理方法，例如isBlank() 判空、strip() 去除首尾空格、stripLeading() 去除字符串首部空格、lines() 分割获取字符串流、repeat() 复制字符串。

* 用于 Lambda 参数的局部变量语法：局部变量类型推断是Java 10引入的新特性，但是不能在Lambda 表达式中使用。Java 11再次创新，它允许开发者在 Lambda 表达式中使用 var 进行参数声明。
* **标准化HTTP Client**：Java 9 引入Http Client API，Java 10对它更新，Java 11 对它进行标准化。这几个版本后，Http Client几乎被完全重写，支持HTTP/1.1和HTTP/2 ，也支持 websockets。

* 增强了Java 启动器，使之能够运行单一文件的Java 源代码（`java xxx.java`）

- **ZGC：可伸缩低延迟垃圾收集器**

- 添加 Epsilon 垃圾收集器
- 支持 TLS 1.3 协议
- 飞行记录器分析工具
- 动态类文件常量
- 低开销的 Heap Profiling
