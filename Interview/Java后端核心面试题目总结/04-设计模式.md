# 你了解哪些设计原则呢？

## SOLID 原则

**单一职责原则（Single Responsibility Principle）**：一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。。

**开放-关闭原则 (Open-Closed Principle)**：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。

**里氏替换原则 (Liskov Substitution Principle)**：子类对象能够替换程序（`program`）中父类对象现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

**依赖倒置原则 (Dependence Inversion Principle)**：高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

**接口隔离原则 (Interface Segregation Principle)**：接口的调用者或者使用者不应该被强迫依赖它不需要的接口。也可以理解为不要对外暴露没有实际意义的接口。

## KISS 原则、YAGNI 原则与DRY 原则

**KISS 原则**：代码尽量保持简单。不仅仅指代码行数，还有逻辑复杂度、实现难度、代码的可读性等。

* 不要使用同事可能不懂的技术来实现代码。比如慎用正则表达式，还有一些编程语言中过于高级的语法等。
* 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。
* 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 `if-else`、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

**YAGNI 原则**：不要做过度设计。不要去设计当前用不到的功能，不要去编写当前用不到的代码。比如，在项目中提前引入不需要依赖的开发包。

**DRY原则**：不要写重复的代码。重复代码一般又三种情况：实现逻辑重复、功能语义重复、代码执行重复。

* DRY不是只指代码重复，而是“知识”的重复，意思是指业务逻辑。例如由于沟通不足，两个程序员用两种不同的方法实现同样功能的校验。

## 迪米特法则（LOD）

**何为“高内聚、松耦合”？**

* “高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。
* 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。
* 所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。

**如何理解“迪米特法则”（Law Of Demeter）？**

* 迪米特法则又叫作最小知识原则，**不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口**。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

# 谈谈你知道的设计模式？它们有什么应用场景？

<div align="center">  
<img src="..\..\12-System-Architecture&Design\images\设计模式总结.png" width="800px"/>
</div>

## 创建型

### 单例模式

单例模式很容易理解，一个类只允许创建一个对象（或者实例），那么这个类就是单例类，这种设计模式就是单例设计模式。单例有下面几种经典的实现方式。

* **饿汉式**

饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。

```java
public class Singleton {
    // 构造器私有化，用户无法通过new方法创建该对象实例
    private Singleton() {
    }
    
    // 在静态初始化器中创建单例实例，这段代码保证了线程安全
    private static Singleton uniqueInstance = new Singleton();

    // 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return uniqueInstance;
    }
}
```

* **懒汉式**

懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }
    // 提供一个静态的公有方法，当使用到该方法时，才去创建uniqueInstance
    public static synchronized Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

*  **懒汉式-双重检测锁**

双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }
	//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {// 避免已经实例化后的加锁操作
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {// 避免多个线程同时进行实例化操作
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

* **静态内部类**

利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。

```java
class Singleton {
    //构造器私有化
    private Singleton() {
    }

	// 静态内部类，该类中有一个静态属性 Singleton
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

	// 提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE
    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

* **枚举**

最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。

```java
enum Singleton {
    INSTANCE; //属性

    public void doSomeTing() {
        System.out.println("通过枚举方法实现单例");
    }
}

// 使用
public class EnumSingletonTest {
	public static void main(String[] args) {
		Singleton singleton = Singleton.INSTANCE;
		singleton.doSomeThing();// 通过枚举方法实现单例
	}
}
```

单例的缺点在于：对OOP特性（封装、抽象、继承、多态）的支持不友好，对代码的扩展性不友好。

### 工厂模式

简单工厂

工厂方法

抽象工厂

### 原型模式

### 建造者模式

## 结构型

### 代理模式

* 静态代理
* 动态代理
* 应用场景

### 桥接模式

### 适配器模式

## 行为型
