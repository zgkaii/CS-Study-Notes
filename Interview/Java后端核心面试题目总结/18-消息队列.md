<!-- MarkdownTOC -->
- [初识消息队列](#初识消息队列)
  - [为什么需要消息队列？](#为什么需要消息队列)
  - [消息队列应用场景？](#消息队列应用场景)
    - [异步处理](#异步处理)
    - [削蜂平谷](#削蜂平谷)
    - [系统解耦](#系统解耦)
  - [消息队列有什么缺点？](#消息队列有什么缺点)
  - [消息处理模式有哪些？](#消息处理模式有哪些)
    - [队列模型（Point-To-Point）](#队列模型point-to-point)
    - [发布订阅模型（Publish-Subscribe）](#发布订阅模型publish-subscribe)
  - [消息队列有几种投递方式？](#消息队列有几种投递方式)
  - [如何保证消息的严格顺序？](#如何保证消息的严格顺序)
  - [消息队列如何实现分布式事务？](#消息队列如何实现分布式事务)
  - [如何确保消息不丢失？](#如何确保消息不丢失)
    - [检查消息丢失](#检查消息丢失)
    - [确保消息可靠传递](#确保消息可靠传递)
  - [如何处理消费过程中的重复消息？](#如何处理消费过程中的重复消息)
    - [消息队列的消费语义](#消息队列的消费语义)
    - [用幂等性解决重复消息问题](#用幂等性解决重复消息问题)
  - [如何处理消息积压？](#如何处理消息积压)
    - [如何预防消息积压？](#如何预防消息积压)
    - [发送消息积压如何解决？](#发送消息积压如何解决)
  - [如何选择消息队列？](#如何选择消息队列)
  - [参考资料](#参考资料)

<!-- /MarkdownTOC -->

## 为什么需要消息队列？

系统间通信方式大致有：基于文件、基于共享内存、基于IPC、基于Socket、基于数据库、基于RPC等方式。这些模式在通信时有明显的的缺点，例如：

* 文件: 明显不方便，不及时。
* Socket：使用麻烦，多数情况下不如 RPC。
* 数据库：不实时，但是经常有人拿数据库来模拟消息队列。
  * 如何用数据库来模拟一个消息队列？假设有一个订单表，A系统用于接收订单后将状态更新到订单表中去；B系统用于做订单相关的清算处理，那么B系统会不断地轮询订单表，把所有新进来且未被A系统处理的订单捞出来修改状态，例如100ms轮询一次。这样，订单处理的延迟会很高，每次100ms；而且如果每一批数据量都特别大，那这样会对系统稳定性造成很大压力。
* RPC：调用关系复杂，同步处理，压力大的时候无法缓冲。如下图：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629201838237.png" width="400px"/>
</div>

因此，希望有一种通信方式：

* 可以实现异步的通信方式；
* 可以简化参与各方的复杂依赖关系；
* 可以在请求量很大的时候，可以缓冲一下（类似于线程池中的Queue）；
* 某些情况下能保障消息的可靠性，甚至顺序。

这时就要用到MQ（Message Queue/Messaging System/Message Middlewire），可以类比快递服务。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629202616158.png" width="600px"/>
</div>

## 消息队列应用场景？

对比其他通信模式，MQ 的优势（应用场景）在于： 

- **异步通信**：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作。
- **系统解耦**：系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成。
- **削峰平谷**：压力大的时候，缓冲部分请求消息，类似于背压处理。
- **可靠通信**：提供多种消息模式、服务质量、顺序保障等。

下面通过一个秒杀系统设计的例子，简要分析一下MQ主要应用场景及优势。

### 异步处理

我们知道，秒杀系统需要解决的核心问题是如何利用有限的资源尽可能多地处理短时间内的海量请求。一个秒杀请求一般包含：`风险控制 -> 库存锁定 -> 生产订单 -> 短信通知 -> 更新统计数据`几个步骤。决定秒杀能否成功，关键看`风险控制+库存锁定`两个步骤。那么，我们可以在完成这两步后直接返回秒杀结果，然后把请求的数据放入消息队列中，由消息队列异步地进行后续的操作。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629211523575.png" width="650px"/>
</div>

在这个场景中，消息队列被用于实现服务的异步处理。这样做的好处是：

* 可以更快地返回结果；
* 减少等待，自然实现了步骤之间的并发，提升系统总体的性能。

### 削蜂平谷

秒杀系统常见的一个问题是：如何避免过多的请求压垮我们的系统？一般设计思路就是：使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的。

加入消息队列后，整个秒杀流程变为：

1. 网关在收到请求后，将请求放入请求消息队列；
2. 后端服务从请求消息队列中获取 APP 请求，完成后续秒杀处理过程，然后返回结果。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629213401849.png" width="650px"/>
</div>

也就是说，请求不会直接冲击后端服务，而是先堆积到消息队列中，后端服务根据自己的处理能力从消息队列中消费请求进行处理。如果请求太多，那么就起到了“削峰”作用；请求过少，那么消息堆积就起到了“平谷”的作用。同时超时无响应的请求处理未秒杀失败即可。

* 这样设计增加了系统调用链环节，导致总体的响应时延变长；同时上下游同步调用变为异步，增加了系统的复杂度。

如果我们能预估出秒杀服务的处理能力，就可以用消息队列实现一个令牌桶，更简单地进行流量控制。

* 令牌桶控制流量的原理：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629214027761.png" width="650px"/>
</div>

令牌桶可以简单使用固定容量的消息队列加一个令牌发生器实现：令牌发生器按照预估的处理能力，匀速生产令牌放入令牌桶（如果队列满了就丢弃），网关在收到请求时去令牌队列消费一个令牌，获取到令牌则调用后端秒啥服务。

* 未破坏原有调用链，只在网关处理APP请求时增加一个获取令牌的逻辑。

### 系统解耦

订单是电商系统中比较核心的数据，当一个新订单创建时，往往伴随着：支付系统发起支付请求/客服系统需要给用户发短信告知用户/经营分析系统需要更新统计数据... ...那么下游系统的每一次修改，我们都得在订单系统中修订与这些下游系统的接口，这是不能接受的。

这里就可以选择用消息队列来解决类似的系统耦合过于紧密的问题。引入消息队列后，订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。无论增加、减少下游系统或是下游系统需求如何变化，订单服务都无需做任何更改，实现了订单服务与下游服务的解耦。

## 消息队列有什么缺点？

从上面消息队列的应用场景的中，可分析出三个缺点：

- 降低了系统可用性（消息队列一旦挂掉，整个系统不就崩溃了？所以消息队列一定要做到高可用）。

- 系统复杂度提高。

- 降低了一致性问题（保持一致性需要高代价的补偿，如分布式事务... ...）。


## 消息处理模式有哪些？

### 队列模型（Point-To-Point）

早期的消息队列，就是按照“队列”的数据结构设计的，保证消息严格有序。生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629221339160.png" width="650px"/>
</div>

这个模型的问题在于，多个生产者向同一个同一个队列里面发送消息没有问题，但是无法满足将一份消息数据分发给多个消费者。一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。

### 发布订阅模型（Publish-Subscribe）

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629222010909.png" width="650px"/>
</div>

在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。

> 发布订阅模型与队列模型的最大区别就是，一份消息数据能不能被消费多次的问题。

常用的消息队列中，RabbitMQ 采用的是队列模型，但是它一样可以实现发布 - 订阅的功能。RocketMQ 和 Kafka 采用的是发布 - 订阅模型，并且二者的消息模型是基本一致的。

## 消息队列有几种投递方式？

从上面我们可知，消息队列的角色主要有：

* 生产者（Producer）负责产生消息；
* 消费者（Consumer）负责消费消息；
* 消息代理（Message Broker）负责存储消息和转发消息两件事情。

消息队列一般分为**push 推送**和 **pull 拉取**两种投递方式。

* 拉取（Pull），是指 Consumer 主动从 Message Broker 获取消息；
* 推送（Push），是指 Message Broker 主动将 Consumer 感兴趣的消息推送给 Consumer 。

无论是 push 还是 pull ，都存在各种的利弊。

| 对比 | 拉取                                               | 推送                                             |
| ---- | -------------------------------------------------- | ------------------------------------------------ |
| 优点 | 及时性                                             | 根据自己消费能力**主动**进行消息拉取             |
| 缺点 | 被动，受限于消费者的消费能力，可能造成消息的堆积。 | 消费方难以把握获取最新消息的时机，会有消息延迟。 |

目前的消息队列，大多基于 push + pull 模式结合的方式，Broker 仅仅告诉 Consumer 有新的消息，具体的消息拉取，还是 Consumer 自己主动拉取。

## 如何保证消息的严格顺序？

主题层面是无法保证严格顺序的，只有在队列上才能保证消息的严格顺序。如果你的业务必须要求全局严格顺序，就只能把消息队列数配置成 1，生产者和消费者也只能是一个实例，这样才能保证全局严格顺序。

大部分情况下，我们并不需要全局严格顺序，只要保证局部有序就可以满足要求了。比如，在传递账户流水记录的时候，只要保证每个账户的流水有序就可以了，不同账户之间的流水记录是不需要保证顺序的。

如果需要保证局部严格顺序，可以这样来实现。在发送端，我们使用账户 ID 作为 Key，采用一致性哈希算法计算出队列编号，指定队列来发送消息。一致性哈希算法可以保证，相同 Key 的消息总是发送到同一个队列上，这样可以保证相同 Key 的消息是严格有序的。如果不考虑队列扩容，也可以用队列数量取模的简单方法来计算队列编号。

## 消息队列如何实现分布式事务？

**消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题**。例如电商购物中，一般将商品加入购物车，然后几件商品同时下单，最后支付，完成购物流程。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629222800746.png" width="650px"/>
</div>

我们可以使用用消息队列来异步清理购物车，这样却容易出现数据不一致的情况，例如：

* 创建了订单，没清理购物车；
* 订单没创建成功，购物车里面的商品却被清掉了。

所以我们需要保证，创建订单和发送消息这两个步骤要么都操作成功，要么都操作失败，不允许一个成功而另一个失败的情况出现。如何保证呢？

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629223423188.png" width="650px"/>
</div>

大致步骤如下：

1. 开启事务。
2. 订单系统给消息服务器发送一个“半消息”。
   * **半消息在事务提交之前对于消费者来说是不可见的**。除此之外，半消息与普通消息没有任何区别。
3. 订单系统执行本地事务，创建订单。
4. 提交或回滚：如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。
5. 投递消息。

如果第4步事务提交失败如何解决？

> Kafka：直接抛出异常，让用户自行处理。

在 RocketMQ 中的事务实现中，增加了**事务反查**的机制来解决事务消息提交失败的问题。也就是说RocketMQ的Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629224019246.png" width="800px"/>
</div>

在上面的订单处理的例子中，我们只要根据消息中的订单 ID，在订单库中查询这个订单是否存在即可，如果订单存在则返回成功，否则返回失败。RocketMQ 会自动根据事务反查的结果提交或者回滚事务消息。

## 如何确保消息不丢失？

### 检查消息丢失

我们**可以利用消息队列的有序性来验证是否有消息丢失**。比如在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性。如果没有消息丢失，Consumer 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1。

> Kafka 和 RocketMQ不保证在 Topic 上的严格顺序的，只能保证分区上的消息有序。所以发消息要指定分区，并且，在每个分区单独检测消息序号的连续性。
>
> Producer 是多实例，则需每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。
>
> Consumer实例的数量最好和分区数量一致，做到Consumer和分区一一对应，这样比较方便检测消息序号连续性。

### 确保消息可靠传递

一条消息从生产到消费完成这个过程，可以划分三个阶段：

<div align="center">  
<img src="https://img-blog.csdnimg.cn/20210629225518858.png" width="800px"/>
</div>

* 生产阶段: 从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。
* 存储阶段: 消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。
* 消费阶段: Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。

因此，在不同的阶段，需要不同的处理方式来保证消息不丢失：

* 生产阶段：只需保证捕获消息发送的错误，并重发消息。
  * 需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。
* 存储阶段：可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。
  * 例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。
* 消费阶段：需要在处理完 全部消费业务逻辑之后，客户端再发送消费确认。

## 如何处理消费过程中的重复消息？

### 消息队列的消费语义

MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，从低到高依次是：

* **At most once**，至多一次，消息可能丢失但不会重复发送。
* **At least once**，至少一次，消息不会丢失，但是可能会重复。
* **Exactly once**，精确一次，每条消息肯定会被传输一次且仅一次，消息不丢失也不重复。

> RocketMQ、RabbitMQ 和 Kafka 提供的服务质量都是 At least once。也就是说，消息队列很难保证消息不重复。
>
> Kafka支持的Exactly once与上面的标准是有差异的。

### 用幂等性解决重复消息问题

一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。

幂等（Idempotence） 本来是一个数学上的概念，它是这样定义的：如果一个函数 f(x) 满足：`f(f(x)) = f(x)`，则函数 f(x) 满足幂等性。一个幂等操作的特点是，**其任意多次执行所产生的影响均与一次执行的影响相同**。对于幂等的方法，我们不用担心重复执行会对系统造成任何改变。

如果我们系统消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题了，因为同一条消息，消费一次和消费多次对系统的影响是完全一样的。也就可以认为，消费多次等于消费一次。

从对系统的影响结果来说：**At least once + 幂等消费 = Exactly once**。

如何实现幂等呢？最好的方式就是，**从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作**。但是，不是所有的业务都能设计成天然幂等的，这里就需要一些方法和技巧来实现幂等。

**(1) 利用数据库的唯一约束实现幂等**

比如”给账户加100元“操作，我们可以建立一张包含`转账单 ID、账户 ID 和变更金额`转账流水表，转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束。那么，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作。

不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费。

**(2) 为更新的数据设置前置条件**

给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据。比如”给账户加100元“不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性。

更加通用的方法是，给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。

**(3) 记录并检查操作**

通用性最强，适用范围最广的实现幂等性方法：记录并检查操作，也称为“**Token 机制或者 GUID（全局唯一 ID）机制**”，实现的思路很简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。

具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。

## 如何处理消息积压？

### 如何预防消息积压？

消息积压的直接原因，一定是系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压。由于消息队列本身的处理能力要远大于业务系统的处理能力，所以我们主要关注点在于，**在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能**。

**(1) 发送端性能优化**

发送端发送消息的性能上不去，需要优先检查一下，是不是发消息之前的**业务逻辑耗时**太多导致的。一般而言只需要注意设置**合适的并发和批量**大小，就可以达到很好的发送性能。

**(2) 消费端性能优化**

使用消息队列的时候，大部分的性能问题都出现在消费端，一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。

消费端的性能优化除了**优化消费业务逻辑**以外，也可以通过**水平扩容**，增加消费端的并发数来提升总体的消费性能。特别需要注意的一点是，**在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的**。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。因为对于消费者来说，在每个分区上实际上只能支持单线程消费。

------

**引申问题**：在消费端是否可以通过批量消费的方式来提升消费性能？在什么样场景下，适合使用这种方法？或者说，这种方法有什么局限性？

**回答**：

批量消费有意义的场景要求：（1）要么消费端对消息的处理支持批量处理，比如批量入库（2）要么消费端支持多线程/协程并发处理，业务上也允许消息无序（3）或者网络带宽在考虑因素内，需要减少消息的overhead。

批量消费的局限性：（1）需要一个整体ack的机制，一旦一条靠前的消息消费失败，可能会引起很多消息重试。（2）多线程下批量消费速度受限于最慢的那个线程。

### 发送消息积压如何解决？

对于系统发生消息积压的情况，需要先解决积压，再分析原因，毕竟保证系统的可用性是首先要解决的问题。快速解决积压的方法就是通过水平扩容增加 Consumer 的实例数量。

（1）系统突然发生消息积压，发送变快了 --> 临时扩容，增加消费端实例，用硬件提升消费速度。
（2）没有足够的服务器资源进行扩容 --> 服务降级，关闭一些非核心业务，减少消息生产。

（3）系统消息发送/接收速度不变- -> 分析是否发生因为消费失败而重复消费的问题。

（3）发现系统消费变慢了 --> 通过日志分析，监控等找到挤压原因，消息队列三部分，上游生产者是否异常生产大量数据，中游消息队列存储层是否出现问题，下游消费速度是否变慢，就能确定哪个环节出了问题（死锁、卡点）。

（4）根据排查解决异常部分。

（5）等待积压的消息被消费，恢复到正常状态，撤掉扩容服务器。

## 如何选择消息队列？

ActiveMQ/RabbitMQ/RabbitMQ/Kafka四者简要对比如下：

| 特性                    | ActiveMQ              | RabbitMQ                                           | RabbitMQ                                                                                                               | Kafka                                                                                                                                           |
| :---------------------- | :-------------------- | :------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------- |
| 开发语言                | Java                  | Erlang                                             | Java                                                                                                                   | Scala + Java                                                                                                                                    |
| 单机吞吐量              | 万级                  | 万级                                               | 10 万级，支撑高吞吐                                                                                                    | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景。                                                                     |
| Topic数量对吞吐量的影响 |                       |                                                    | Topic可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 Topic。 | Topic从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 Topic数量不要过多，如果要支撑大规模的 Topic，需要增加更多的机器资源。 |
| 时效性                  | ms 级                 | 微秒级(us)，延迟最低                               | ms 级                                                                                                                  | 延迟在 ms 级以内                                                                                                                                |
| 可用性                  | 高，主从架构          | 高，主从架构                                       | 非常高，分布式架构                                                                                                     | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用。                                                                  |
| 消息可靠性              | 有较低的概率丢失数据  |                                                    | 经过参数优化配置，可以做到 0 丢失。                                                                                    | 同 RocketMQ。                                                                                                                                   |
| 功能支持                | MQ 领域的功能极其完备 | 基于 Erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好。                                                                              | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。                                                          |

简要总结一下：

* 选择ActiveMQ：No，一般不选择。

* 选择RabbitMQ：轻量，开箱即用，易于维护，不追求多功能和高性能。
* 选择RocketMQ：低延迟，稳定可靠，适合交易系统等在线业务。
* 选择Kafka：强大的性能及吞吐量，适合处理海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或配合大数据、流计算相关的开源产品。


## 你会如何设计一个消息队列？

TODO

> **如果让你使用数据库实现消息中间件，你如何设计？**

