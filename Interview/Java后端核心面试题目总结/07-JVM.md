<!-- MarkdownTOC -->

- [JVM体系结构](#jvm体系结构)
  - [JDK、JRE与JVM区别和联系？](#jdkjre与jvm区别和联系)
  - [什么是字节码，采用字节码的好处是什么？](#什么是字节码采用字节码的好处是什么)
  - [.class文件执行过程？](#class文件执行过程)
- [类加载](#类加载)
  - [请介绍类加载过程？](#请介绍类加载过程)
  - [什么是类加载器？](#什么是类加载器)
  - [类加载时机是什么？](#类加载时机是什么)
  - [Java类加载机制是什么？](#java类加载机制是什么)
- [内存模型](#内存模型)
  - [谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?](#谈谈jvm内存区域的划分哪些区域可能发生outofmemoryerror)
    - [程序计数器](#程序计数器)
    - [虚拟机栈](#虚拟机栈)
    - [本地方法栈](#本地方法栈)
    - [堆区](#堆区)
    - [方法区](#方法区)
  - [Java对象在堆中分配过程？](#java对象在堆中分配过程)
  - [TLAB是什么呢？](#tlab是什么呢)
  - [逃逸分析是什么？如何优化？](#逃逸分析是什么如何优化)
  - [请简要描述 Java 对象的存储结构?](#请简要描述-java-对象的存储结构)
- [垃圾回收基础概念](#垃圾回收基础概念)
  - [(标记阶段)如何判断对象已死？](#标记阶段如何判断对象已死)
  - [哪些对象可以作为GC Roots?](#哪些对象可以作为gc-roots)
  - [(清除阶段)常见垃圾回收算法？](#清除阶段常见垃圾回收算法)
  - [串行、并行、并发是什么？](#串行并行并发是什么)
  - [STW是什么？](#stw是什么)
  - [安全点与安全区域是什么？](#安全点与安全区域是什么)
  - [内存溢出与内存泄漏区别？](#内存溢出与内存泄漏区别)
  - [为什么要采用分代收集算法？](#为什么要采用分代收集算法)
  - [Minor GC、Major GC、Full GC区别？](#minor-gcmajor-gcfull-gc区别)
- [垃圾回收器](#垃圾回收器)
  - [常用垃圾回收器组合](#常用垃圾回收器组合)
    - [Serial GC：串行回收](#serial-gc串行回收)
    - [ParNew GC：并行回收](#parnew-gc并行回收)
    - [Parallel GC：吞吐量优先](#parallel-gc吞吐量优先)
  - [CMS：低延迟](#cms低延迟)
  - [G1：可预测停顿](#g1可预测停顿)
  - [Shennandoah GC](#shennandoah-gc)
  - [ZGC](#zgc)
  - [如何正确选择GC？](#如何正确选择gc)
  - [JDK 的默认 GC 是什么？](#jdk-的默认-gc-是什么)
- [执行引擎](#执行引擎)
  - [Java为什么是半解释半编译语言？](#java为什么是半解释半编译语言)
  - [Java中编译器分类有哪些？](#java中编译器分类有哪些)
- [命令行参数与命令行工具](#命令行参数与命令行工具)
  - [JVM常用命令行参数 jmap、jps？](#jvm常用命令行参数-jmapjps)
  - [常用可视化工具有哪些？](#常用可视化工具有哪些)
  - [生成内存转储文件有哪几种方式? 用什么工具进行分析?](#生成内存转储文件有哪几种方式-用什么工具进行分析)
  - [如何监控和诊断JVM堆内和堆外内存使用？](#如何监控和诊断jvm堆内和堆外内存使用)
- [性能调优](#性能调优)
  - [堆内存参数](#堆内存参数)
  - [GC设置参数](#gc设置参数)
  - [JVM 疑难情况问题分析步骤？](#jvm-疑难情况问题分析步骤)
  - [JVM优化Java代码时都做了什么？](#jvm优化java代码时都做了什么)
  - [谈谈你的GC调优思路？](#谈谈你的gc调优思路)
  - [线上OOM如何排查呢？](#线上oom如何排查呢)

<!-- /MarkdownTOC -->

# JVM体系结构

## JDK、JRE与JVM区别和联系？

**JDK(Java Development Kit)**是用于开发Java应用程序的软件工具集合，主要包括了Java运行时环境(JRE)和一些Java开发工具(例如解释器`java.exe`，编译器`javac.exe`，打包工具`jar.exe`，文档生成器`javadoc.exe`等等)。

**JRE(Java RunTime Environment)**提供Java应用程序执行时所需的环境，由Java虚拟机(JVM)、核心类(libraries)及支持文件组成。

**JVM(Java Virtual Environment)**即所谓的Java虚拟机，它用于解释由`.java`文件编译生成的`.class`字节码文件，并将其映射到本地的CPU的指令集或OS系统调用中。虽然不同的操作系统使用不同的JVM映射规则，但JVM解释/编译字节码文件的规则一致，这使得Java语言具有了跨平台的特性。除此之外，JVM平台的不同语言还共享JVM所带来的垃圾回收器(GC)与即时编译器(JIT)。

<div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\runanywhere.png" width="600px"></div>

三者之间关系：

```html
JDK > JRE > JVM
JDK = JRE + tools => JRE = JVM + libraries
```

## 什么是字节码，采用字节码的好处是什么？

我们平时说的Java字节码(Java bytecode)，指的是用Java语言编译成的字节码。不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。

Java虚拟机与Java语言并没有必然的联系，它只与特定的**二进制文件格式**——Class文件格式所关联，Class文件中包含了Java虚拟机指令集(或者称为字节码、Bytecodes)和符号表，还有一些其他辅助信息。

Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心**“字节码”文件**。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，**只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行**。

Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。**这也就是解释了 Java 的编译与解释并存的特点**。

## .class文件执行过程？

Java虚拟机与Java语言并没有必然的联系，它只与特定的**二进制文件格式**——`.class文件`格式所关联，class文件中包含了Java虚拟机指令集(或者称为字节码、Bytecodes)和符号表，还有一些其他辅助信息。

<div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\class执行.png" width="600px"></div>

# 类加载

## 请介绍类加载过程？

一个Java文件从编码到最终执行，主要分为编译、运行两个阶段。编译，即把写好的.java文件，通过javac编译成字节码的.class文件。运行，则是把编译生成的.class文件交给Java虚拟机(JVM)执行。**类加载过程即是指JVM虚拟机把.class字节码文件中类信息加载进内存，并进行解析生成对应的class对象的过程**。

一个类在JVM里的生命周期有7个阶段，分别是加载(Loading)、校验(Verification)、准备(Preparation)、解析(Resolution)、初始化 (Initialization)、使用(Using)、卸载(Unloading)。 其中前五个部分(**加载，验证，准备，解析，初始化**)统称为类加载。完整的流程图如下所示：

<div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\类的生命周期.png" width="600px"></div>

**1、加载阶段：找 class 文件**

* 通过一个类的**全限定名获取定义此类的二进制字节流**，简单点说就是 **找到文件系统中/jar包中/或存在于任何地方的“ class文件 ”**。 如果找不到则会抛出 `NoClassDefFound `错误。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* **在内存中生成一个代表这个类的`java.lang.Class`对象**，作为方法区这个类的各种数据的访问入口。

**2、校验阶段**：**验证格式、依赖，保证虚拟机安全**（-Xverifynone参来关闭大部分的类验证措施，缩短虚拟机类加载的时间）

* 文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以**魔数0xCAFEBABE**开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
* 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类(除了`java.lang.Object`之外，所有的类都应当有父类)；这个类的父类是否继承了不允许被继承的类(被final修饰的类)... ...
* 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
* 符号引用验证：对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

**3、为类的静态变量分配内存，并将其初始化为默认值（0、0L、null、false）**

这个阶段将会创建静态字段, 并将其初始化为标准默认值(**比如 null 或者 0值**，Boolean类型数据的零值为False )，并分配方法表，即在方法区中分配这些变量所使用的内存空间。

* **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化**；

* 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

**4、解析阶段：符号解析为引用（将常量池内的符号引用转换为直接引用的过程）**

* 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
* 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

* 解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型**等。对应常量池中的`CONSTANT Class info、CONSTANT Fieldref info、CONSTANT_Methodref_info`等。

**5、初始化阶段：构造器方法、static静态变量赋值、static静态代码块**（必须在类的首次“主动使用”时才能执行类初始化，初始化阶段也就是执行类构造器法`<clinit>()`的过程）

* 编译器收集`<clinit>()`动作按照源文件顺序执行。所以说，静态语句块中只能访问到定义在静态语句块之外的变量，静态语句块中访问静态语句块中的变量会提示“非法向前引用”。
* 父类的`<cinit>()`方法优先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

## 什么是类加载器？

类加载过程可以描述为**“通过一个类的全限定类名来获取此类的class对象”，即所谓的全限定名来获取描述该类的二进制字节流)**，这个过程由**类加载器**(Class Loader)来完成。

在程序中我们最常见的类加载器主要有3类：**启动类加载器**(BootstrapClassLoader)、**扩展类加载器**(ExtClassLoader) 和**应用类加载器**(AppClassLoader)。

<div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\JVM 类加载器.png" width="800px"></div>

其中，启动类加载器又名引导类加载器，用C/C++语言实现，主要用于加载Java核心类库，如`rt.jar`。

扩展类加载器派生于`ClassLoader`类，主要加载`/lib/ext`扩展目录的jar包。

应用程序类加载器又名系统类加载器，派生于`ClassLoader`类，负责加载用户环境变量`CLASSPATH`或系统属性`java.class.path`指定路径下的类库，该类加载是程序中**默认**的类加载器。

用户自定义类加载器常用于实现隔离加载类、修改类加载的方式、扩展加载源与防止源码泄漏。实现自定义加载器步骤如下：

* 继承抽象类`java.lang.ClassLoader`类。
* JDK 1.2之前，重写`loadClass()`方法；JDK 1.2 之后，建议将类加载逻辑重写在`findclass()`方法中。
* 没有过于复杂的需求，可直接继承`URIClassLoader`类，这样可避免去编写`findclass()`方法及其获取字节码流的方式。

## 类加载时机是什么？

JVM 规范枚举了下述多种触发情况： 

* 当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main方法所在的类； 
* 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new一个类的时候要初始化； 
* 当遇到调用静态方法的指令时，初始化该静态方法所在的类； 
* 当遇到访问静态字段的指令时，初始化该静态字段所在的类； 
* 子类的初始化会触发父类的初始化； 
* 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化； 
* 使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化； 
* 当初次调用 `MethodHandle `实例时，初始化该 `MethodHandle `指向的方法所在的 类。 

同时以下几种情况**不会**执行类初始化： 

* 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始 化。 
* 定义对象数组，不会触发该类的初始化。
* 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的 类，不会触发定义常量所在的类。 
* 通过类名获取Class对象，不会触发类的初始化，`Hello.class`不会让Hello类初始 化。 
* 通过`Class.forName`加载指定类时，如果指定参数`initialize`为false时，也不会触发 类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 `Class.forName(“jvm.Hello”)`默认会加载Hello类。 
* 通过`ClassLoade`r默认的`loadClass`方法，也不会触发初始化动作(加载了，但是 不初始化)。

示例: 诸如 `Class.forName(), classLoader.loadClass()` 等Java API，反射API， 以及` JNI_FindClass` 都可以启动类加载。 JVM本身也会进行类加载。 比如在JVM启动时加载核心类，`java.lang.Object, java.lang.Thread` 等等。

## Java类加载机制是什么？

Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java采用的是**双亲委派机制**，它指的是，当某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，**依次向上**，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。如果最终几个类加载器都没有加载到指定名称的类，那么会抛出`ClassNotFountException`异常 。

<div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\双亲委托.png" width="600px"></div>

**双亲委派机制的优势**：(1) 避免类的重复加载 (2) 保证程序安全稳定运行，防止核心API被随意篡改，如自定义类`java.lang.XXXX`（**报错**：阻止创建`java.lang`开头的类，例如`java.lang.String`）

**Tomcat 类加载器之为何违背双亲委派模型？**

- Tomcat是个Web容器，一个Web容器可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。Web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。这两点采用默认的双亲委派机制是不行的。
- 很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守双亲委派机制，每个**WebappClassLoader**加载自己的目录下的class文件，不会传递给父类加载器。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\tomcat.png" width="400px"></div>

- CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器。
  - CommonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；
  - CatalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
  - SharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
  - WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；
- 从图中的委派关系中可以看出：CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。
- 而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。

# 内存模型

## 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?

JVM在执行Java程序的过程中会把它所管理的内存主要划分5个不同的数据区域：**本地方法栈、程序计数器、虚拟机栈、堆、方法区**。这些区域有各自的用途和创建与销毁的时间。有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\运行时数据区.png" width="800px"></div>

==注意==，《Java 虚拟机规范》中指明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择区进行垃圾收集或者进行压缩。” 但对于 HotSpotJVM 而言，方法区还有一个别名叫做**Non-Heap(非堆)**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

如上图所描述一样，在JDK 1.7 之前，方法区在**逻辑上**属于**非堆**，是一块独立的内存区域，但其实际物理内存其实是在堆区的(存放于永久代)；直到JDK 1.8后，方法区的实现才被移动至直接内存中的元空间(MetaSpace)中，逻辑内存与实际物理内存都与堆区分开。

一般来讲，黄色部分为线程隔离的数据区域，其他部分为线程共享的区域。

|    区域    | 是否线程共享 | 是否存在内存溢出 | 是否存在GC |
| :--------: | :----------: | :--------------: | :--------: |
| 本地方法栈 |      否      |        是        |     否     |
| 程序计数器 |      否      |        否        |     否     |
|  虚拟机栈  |      否      |        是        |     否     |
|    堆区    |      是      |        是        |     是     |
|   方法区   |      是      |        是        |     是     |

### 程序计数器

程序计数器(Program Counter Register)是对**物理PC寄存器的一种模拟，主要用于存储当前线程需要执行的字节码指令地址**。在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致。

例如下面的字节码文件，字节码左边的行号标识，它其实就是**指令地址**。

```java
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
```

> 注意：程序计算器是运行速度最快的存储区域，也是唯一一块不会出现OOM的内存区域。

### 虚拟机栈

常常有人把Java内存区域笼统地划分为堆内存(Heap)和栈内存(Stack)，这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。在Java中，“栈”通常就是指这里讲的虚拟机栈。

Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于**存储局部变量表、操作数栈、动态连接、方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **`OutOfMemoryError`：** 若Java虚拟机栈可以动态扩展，Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError 错误。

**扩展：方法/函数如何调用？**

栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器**。JVM直接对Java栈的操作只有两个：

- 每一次方法执行，都伴随着对应的栈帧压栈(进栈/入栈)。
- 每一个方法执行结束，都会有一个对应栈帧被弹出。

### 本地方法栈

本地方法栈(Native Method Stack)用于**管理本地方法的调用**。其中，本地方法(NatIve Method)就是调用非Java代码的接口，例如`java.lang.Thread`中的`private native void start0()`方法。

Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。因此虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(譬如Hot-Spot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈会在栈深度溢出或者栈扩展失败时分别抛出`StackOverflowError`和`OutOfMemoryError`异常。

### 堆区

对Java应用程序而言，Java堆(Java Heap)是虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例**，Java 世界里“几乎”所有的对象实例都在这里分配内存**。

> 注意：由于**逃逸分析**，**栈上分配**和**标量替换**等技术的发展，导致并不是所有对象实例一定要在堆中分配内存。

Java堆是垃圾收集器管理的主要区域，又称GC 堆(Garbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。新生代分细致一点有：Eden 空间、From Survivor、To Survivor 空间等。这样对堆进行分代划分是为了更好地回收内存，或者更快地分配内存。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。

JDK 1.7及之前堆内存逻辑上分为三部分：新生代+老年代+**永久代**

| 新生代                                    | 老年代                  | 永久代          |
| ----------------------------------------- | ----------------------- | --------------- |
| Young Generation Space                    | Tenure generation space | Permanent Space |
| Young/New（又被划分为Eden区和Survivor区） | Old/Tenure              | Perm            |

Java 8及之后堆内存逻辑上分为三部分：新生代+老年代+**元空间**

| 新生代                                    | 老年代                  | 元空间     |
| ----------------------------------------- | ----------------------- | ---------- |
| Young Generation Space                    | Tenure generation space | Meta Space |
| Young/New（又被划分为Eden区和Survivor区） | Old/Tenure              | Meta       |

### 方法区

方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机**加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。上面我们已经提到过，方法区还有一个别名叫做**Non-Heap(非堆)**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

但实际上，JDK 1.7 之前，方法区正是在堆内存的永久代中实现的，但这样导致Java更容易遇到内存溢出问题。JDK 1.7时，就已经把原本(JDK 1.6)放在永久代的字符串常量池、静态变量等移出到堆；而到了 JDK 1.8，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间(Metaspace)来代替，把JDK 1.7中永久代还剩余的内容(主要是类型信息)移到元空间中。

根据Java虚拟机规范，如果方法区无法满足新的内存分配需求时，也将抛出OutOfMemoryError异常。

>  方法区和永久代的关系：
>
>  《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，不同的 JVM 上方法区的实现是可以不同的。  **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

## Java对象在堆中分配过程？

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

* new的对象先放Eden区。
* 当Eden区的空间填满时，程序还需创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收(**MinorGC**，又称Young GC)，将Eden区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden区。
* 然后将Eden区中的幸存的对象移动到From区(Survivor From区)。

- 如果再次触发垃圾回收，此时Eden区和From区幸存下来的对象就会放到To区(Survivor To区)。
  - 此过程后From区对象都放到To区，故From区变To区，原To区变From区。

- 如果再次经历垃圾回收，此时Eden区对象会重新放回From区，接着再去To区。
- 啥时候能去养老区呢？当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，对象晋升至养老区。可以设置次数：`-Xx:MaxTenuringThreshold= N`，**默认是15次**。
- 当养老区内存不足时，再次触发垃圾回收(**Major GC**)，进行养老区的内存清理。
- 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。

特别注意，在Eden区满了的时候，才会触发MinorGC；而幸存者区满了后，不会触发MinorGC操作。如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\堆对象分配过程.png" width="600px"></div>

## TLAB是什么呢？ 

**为什么有TLAB？**

`TLAB：Thread Local Allocation Buffer`，也就是为每个线程单独分配了一个缓冲区。

堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**什么是TLAB**

从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为**每个线程分配了一个私有缓存区域**，它包含在Eden空间内。

多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略。所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。

在程序中，开发人员可以通过选项`-XX:UseTLAB`设置是否开启TLAB空间。默认情况下，TLAB空间的内存非常小，仅占有**整个Eden空间的1%**，当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden空间的百分比大小。

一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。

## 逃逸分析是什么？如何优化？

**问题引出：所有对象都在堆上分配吗？**

* 有一种特殊情况，那就是如果**经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

**什么是逃逸分析(Escape Analysis)？**

逃逸分析是一种有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生方法逃逸。
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中。

**逃逸分析后有哪些优化手段有哪些？**

* **栈上分配**：如果确定一个对象不会逃逸出线程之外，可以分配在栈上分配内存。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收。

  常见的栈上分配的场景：**给成员变量赋值、方法返回值、实例引用传递**。栈上分配可以支持方法逃逸，但不能支持线程逃逸。

* **同步省略**：如果一个同步代码块中完全不会发送逃逸，不会与其他线程发生锁竞争，同步措施就可以安全地消除掉。这个取消同步的过程就叫**同步省略**，也叫**锁消除**。

* **标量替换**：**标量(scalar)**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

  如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。对象拆分后，将在栈上分配。标量替换对逃逸程度的要求更高，不允许对象逃逸出方法范围内。


## 请简要描述 Java 对象的存储结构?

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\2020101115073675.png" width="1000px"></div>

# 垃圾回收基础概念

GC是英文词汇`Garbage Collection` 的缩写， 中文一般直译为 “ 垃圾收集 ”。垃圾回收器回收垃圾一般分为两阶段：(1)**Marking (标记)**，标记“存活”的对象；**Sweeping (清除)**， 清除"死亡"的垃圾对象，释放内存。

## (标记阶段)如何判断对象已死？

**引用计数算法**：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。

* 优点：实现简单，垃圾对象便于标识；判定效率高，无延迟。
* 缺点：计数器增加存储开销；更新计数增加时间开销；**无法处理循环引用**问题。

**可达性分析算法**：又称根搜索算法、追踪性垃圾收集(Tracing Garbage Collection)，其以根对象集合(GC Roots)为起始点，按照从**上至下的方式搜索被根对象集合所连接的目标对象是否可达**。如果目标对象没有任何引用链(Reference Chain，即搜索所走过的路径)相连，则是不可达的，意味着该对象己经死亡，可以标记为垃圾对象。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\可达性.png" width="600px"></div>

* 优点：实现简单和执行高效；能有效处理循环引用的问题。

## 哪些对象可以作为GC Roots?

有一些特定的对象能被指定为 **Garbage Collection Roots(GC根元素)**：

- 当前正在执行的方法里的局部变量和输入参数
- 活动线程(Active threads)
- 本地方法栈内JNI(通常说的本地方法)引用的对象
- 内存中所有类的静态字段(static field)
- 方法区中常量引用的对象，例如字符串常量池(String Table)里的引用。
- 所有被同步锁synchronized持有的对象。
- Java虚拟机内部的引用，例如基本数据类型对应的Class对象，一些常驻的异常对象(如：`NullPointerException`、`OutOfMemoryError`)，系统类加载器。
- 反映java虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等。

## (清除阶段)常见垃圾回收算法？

**(1) 标记-清除算法**

标记-清除算法(Mark-Sweep)思想很简单，就是直接清除掉垃圾对象(注意，标记的是可达的对象，不是垃圾对象)。

这种算法需要使用空闲表(**free-list**)，来记录所有的空闲区域，以及每个区域的大小。维护空闲表增加了对象分配时的开销。

* 如果内存规整，采用指针碰撞的方式进行内存分配；内存不规整，虚拟机需要维护一个列表，空闲列表分配。
* 清理出来的空闲内存大多是不连续的，产生内存碎片，仍然无法存放大对象。
* GC时需要暂停整个应用程序线程(STW)。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\标记清除算法.png" width="600px"></div>

**(2) 标记复制算法**

**标记-复制算法(Mark and Copy)**核心思想是，将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。

* 优点：实现简单，运行高效；保证了空间的连续性。
* 缺点：是将可用内存缩小为了原来的一半，空间浪费未免太多；对象存活率较高时就要进行较多的复制操作，效率会大大降低。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\标记复制算法.png" width="600px"></div>

**(3) 标记-整理算法**

标记-整理算法又称标记-压缩或标记-清除-压缩(Mark-Sweep-Compact)算法，其核心思想是让所有存活的对象都向内存空间一端移动(压缩到一端)，然后直接清理掉边界以外的内存。

* 优点：消除了标记-清除算法当中，内存区域分散的缺点；消除了复制算法当中，内存减半的高额代价。
* 缺点：GC时需要暂停整个应用程序线程(STW)；如果被移动对象被其他对象引用，则还需要调整引用的地址。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\标记整理算法.png" width="600px"></div>

**三者之间比较**

| 比较         | 标记-清除          | 标记-整理        | 标记-复制                             |
| ------------ | ------------------ | ---------------- | ------------------------------------- |
| **速率**     | 中等               | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是               | 是                                    |

> 没有最好的算法，只有最合适的算法。

**扩展——其他算法**：

分代收集算法(Generational Collecting)：对不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。目前几乎所有的GC都采用分代收集(Generational Collecting)算法执行垃圾回收的。

增量收集算法(Incremental Collecting)：让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

* 优点：对线程间冲突的妥善处理。
* 缺点：造成系统吞吐量的下降。

## 串行、并行、并发是什么？

并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：

- 串行(Serial)：在同一时间段内，只允许有一个CPU(单线程)用于执行垃圾回收操作，GC期间需暂停所有应用程序线程(STW)。
- 并行(Parallel)：在同一时间段内，可以运用多个CPU(多线程)同时执行垃圾回收，因此提升了应用的吞吐量，不过仍存在STW。如ParNew、Parallel Scavenge、Parallel old。
- 并发(Concurrent)：在同一时间段内，用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。

## STW是什么？

Stop The World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿。

- 分析工作必须在一个能确保一致性的快照中进行。
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。
- 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。

## 安全点与安全区域是什么？

程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safe point)”。

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

## 内存溢出与内存泄漏区别？

内存泄漏(Memory Leak)是指本来无用的对象却继续占用内存，没有在恰当的时机释放占用的内存的情况。比如对象间循环引用。

内存溢出(Out Of Memory，简称OOM)是指可使用的内存不足的情况。

一般来讲，内存泄漏是资源管理问题或程序BUG，而内存溢出则是内存空间不足和内存泄漏的最终结果。

**常见的内存泄漏情况**

1. 静态集合类引起的内存泄漏；
2. 当集合里面的对象属性被修改后，再调用remove() 方法时不起作用；
3. 监听器：释放对象的时候没有删除监听器；
4. 各种连接：比如数据库连接(dataSourse.getConnection())，网络连接(socket) 和 IO 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的；
5. 内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；
6. 单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在(以静态变量的⽅式)，如果单例对象持有 外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。

**尽量避免内存泄漏的方法？**

1. 尽量不要使用static 成员变量，减少生命周期；
2. 及时关闭资源；
3. 不用的对象，可以手动设置为 Null。

## 为什么要采用分代收集算法？

分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。 

*在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收*。

## Minor GC、Major GC、Full GC区别？

针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)。

**Minor GC/Young GC** ——新生代GC：当年轻代空间不足时触发(每次Minor GC会清理年轻代的内存)

- 因为Java对象大多都具备 朝生夕灭 的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

**Major GC/Old GC**——老年代GC：出现了MajorGC，经常会伴随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)

- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了。

**FullGC**——整堆收集。STW时间更长了，Full GC 是**开发或调优中尽量要避免。**触发Full GC执行的情况有：

- 在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小(或历次晋升的平均大小)，则触发一次 Full GC 。
- 显式调用 System#gc() 方法时。
- 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。

# 垃圾回收器

## 常用垃圾回收器组合

JDK 1.8之前，主要有7款不同的垃圾回收器。

- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 整堆收集器：G1

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\20201015092111694.png" width="600px"></div>

目前来说，常用的GC组合有：

(1) Serial GC：串行回收)Serial+Serial Old 实现单线程的低延迟垃圾回收机制；

(2) ParNew GC：并行回收)ParNew+Serial Old ，实现多线程的低延迟垃圾回收机制；

(3) Parallel GC：吞吐量优先)Parallel Scavenge+Parallel Old，实现多线程的高吞吐量垃圾回收机制。

### Serial GC：串行回收

Serial GC(`Serial/Serial Old`组合)是最基本、历史最悠久的垃圾收集器，其对年轻代使用标记-复制算法，对老年代使用标记-整理算法，年轻代和老年代的垃圾回收都会触发STW。适用于可用内存一般不大(几十MB至一两百MB)，可以在较短时间内完成垃圾收集(几十ms至一百多ms)的场景。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\Serial.png" width="650px"></div>

启动参数：`-XX:+UseSerialGC`

### ParNew GC：并行回收

ParNew GC(`ParNew/Serial Old` 组合)对年轻代使用标记-复制算法 ，在老年代使用标记-整理算法 ，是Serial GC的多线程版本，年轻代和老年代的垃圾回收都会触发STW。对于新生代，回收次数频繁，使用并行方式高效；对于老年代，回收次数少，使用串行方式节省资源。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\ParNew.png" width="650px"></div>

启动参数：`-XX:+UseParNewGC`，还可通过命令行参数`-XX:ParallelGCThreads=N`来指定 GC 线程数，其默认值为CPU核心数。

### Parallel GC：吞吐量优先

Parallel GC(`Parallel Scavenge/Parallel Old`组合)对年轻代使用标记-复制算法 ，在老年代使用标记-整理算法，同样具备并行回收功能，年轻代和老年代的垃圾回收都会触发STW。

* 和ParNew GC不同，Parallel GC采用自适应调节策略，目的则是**达到一个可控制的吞吐量(Throughput)**，它也被称为吞吐量优先的垃圾收集器。
* **在Java8中，默认是此垃圾收集器**。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\Parallel.png" width="650px"></div>

启动参数：`-XX:+UseParallelGC -XX:+UseParallelOldGC`。

## CMS：低延迟

CMS GC的官方名称为 “Mostly Concurrent Mark and Sweep Garbage Collector”(最大并发-标记-清除-垃圾收集器)。其对年轻代采用并行STW方式的标记-复制算法 ，对老年代主要使用并发标记-清除算法 ，它第一次实现了让垃圾收集线程与用户线程同时工作。

优点：**并发收集、低延迟**。

缺点：老年代内存碎片。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\CMS.png" width="750px"></div>

启动参数：`-XX:+UseConcMarkSweepGC`。

CMS整个过程比之前的收集器要复杂，整个过程分为6个主要阶段：

- **初始标记**(Initial-Mark)阶段：程序中所有的工作线程都将会因为**STW**机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
- **并发标记**(Concurrent-Mark)阶段：在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。
- **并发预处理**(Concurrent-Preclean)阶段：此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card(卡片)”的方式将发生了改变的区域标记为“脏”区，这就是所谓的卡片标记(Card Marking)。
- **最终标记**(Final-Remark)阶段：最终标记阶段是此次 GC 事件中的**第二次(也是最后一次)STW 停顿**。本阶段的目标是完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程 序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。
- **并发清除**(Concurrent-Sweep)阶段：此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收他们占用的内存空间。
- **并发重置**(Concurrent Reset)阶段：此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备。

## G1：可预测停顿

G1 的全称是`Garbage-First`，意为垃圾优先，哪一块的垃圾最多就优先清理它。G1 GC 最主要的设计目标是：(**可预测停顿**)将 STW 停顿的时间和分布，变成可预期且可配置的。

使用G1收集器时，它将整个Java堆划分成**约2048**个大小相同的独立堆区域(smaller heap regions)，每个Region块，可能一会被定义成 Eden区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来 就是年轻代，所有的 Old 区拼在一起那就是老年代。

G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**。

> **每个Region都有一个对应的Remembered Set**；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象)；如果不同，通过`CardTable`把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。

G1垃圾收集器还增加了一种新的内存区域，叫做`Humongous`内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。

> **设置H的原因：**对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。**如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储**。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\20201015092110555.png" width="600px"></div>

启动参数`-XX:+UseG1GC`。

G1 GC的垃圾回收过程主要包括如下三个环节：

**1、年轻代模式转移暂停(Evacuation Pause)**：当年轻代空间用满后，应用线程会被暂停(STW)，年轻代内存块中的存活对象被拷贝到存活区(标记-复制算法)。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。 拷贝的过程称为转移(Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。

**2、并发标记(Concurrent Marking)**： G1并发标记的过程与CMS基本上是一样的。

* **阶段 1: Initial Mark(初始标记)** ：标记所有从GC根对象直接可达的对象。在CMS中需要一次STW暂停，但G1里面通常是在转移暂停的同时处理这些事情，所以它的开销是很小的。 

* **阶段 2: Root Region Scan(Root区扫描)**：此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。因为在并发标记的过程中迁移对象会造成很多麻烦，所以此阶段必须在下一次转移暂停之前完成。如果必须 启动转移暂停，则会先要求根区域扫描中止，等它完成才能继续扫描。在当前版本的实现中，根区域是存活 的小堆块：包括下一次转移暂停中肯定会被清理的那部分年轻代小堆块。 

* **阶段 3: Concurrent Mark(并发标记)**：此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。 为了确保标记开始时的快照准确性，所有应用线程并发对对象图执行引用更新，G1 要求放弃前面阶段为了 标记目的而引用的过时引用。 

* **阶段 4: Remark(再次标记)**：和CMS类似，这是一次STW停顿(因为不是并发的阶段)，以完成标记过程。G1收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标 记开始时未被标记的存活对象。 

* **阶段 5: Cleanup(清理)**：这一阶段也执行某些额外的清理，如引用处理或者类卸载(class unloading)。 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC的效率(标记-整理算法)。此阶段也为下一次标记执行必需的所有整理工作(house-keeping activities)：维护并发标记 的内部状态。 

  所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的STW暂停，才能不受应用线程的影响并完成作业。

**3、转移暂停: 混合模式(Evacuation Pause (mixed))**：并发标记完成之后，G1将执行一次**混合收集(mixed collection)**，就是不只清理年轻代，还将一部分老年代区域也加入到回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次`young`模式的转移暂停。 具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。 其中包括指定的软实时性 能指标，存活性，以及在并发标记期间收集的GC效率等数据，外加一些可配置的JVM选项。混合收集的过 程，很大程度上和前面的`fully-young gc`是一样的。

## Shennandoah GC

Java 12 正式发布于2019年3月19日， 这个版本引入了一款新的垃圾收集器:Shenandoah。**Shenandoah 是一款超低延迟垃圾收集器(Ultra-Low-Pause-Time Garbage Collector)**，其设计目标是管理大型的多核服务器上，超大型的堆内存。GC线程与应用线程并发执行、使得 虚拟机的停顿时间非常短暂。

Shenandoah由 RedHat主持开发，立项时间早于ZGC。整体设计上和G1类似，在G1的基础上创新的抛弃了分代整理， 使**用“链接矩阵”代替RSet**并支持并整理，极大的缩短了Shenandoah 的STW时间。Shenandoah的垃圾回收流程整体上和G1类似，在最后的整理阶段G1通过STW对象复制转移来进行堆空间整理，而Shenandoah 这是通过这个过程拆分成复制、并发引用更新，最终引用更新和清理这几个阶段，实现大部分情况下并发执行。只有在复制、最终引用更新时候需要进行短暂的STW。计算机科学领域的任何问题都可以通过增加⼀个间接的中间层来解决。同样，Shenandoah通过增加⼀个**Brooks Pointer**和**读屏障**来解决并发整理过程中的对象定位问题。正因为并发整理的引入，Shenadoah 的暂停时间相较于传 统的垃圾收集器有了质的飞跃。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\Shennandoah.png" width="800px"></div>

部分日志如下：

```java
GC(3) Pause Init Mark 0.771ms
GC(3) Concurrent marking 76480M->77212M(102400M) 633.213ms
GC(3) Pause Final Mark 1.821ms
GC(3) Concurrent cleanup 77224M->66592M(102400M) 3.112ms
GC(3) Concurrent evacuation 66592M->75640M(102400M) 405.312ms
GC(3) Pause Init Update Refs 0.084ms
GC(3) Concurrent update references 75700M->76424M(102400M) 354.341ms
GC(3) Pause Final Update Refs 0.409ms
GC(3) Concurrent cleanup 76244M->56620M(102400M) 12.242ms
```

对应工作周期如下: 

1. **初始标记阶段(Init Mark)**:为堆和应用程序准备并发标记，然后扫描根对象集。这是GC周期的第一次 暂停，持续时间取决于根对象集的大小。因为根对象集很小，所以速度很快，暂停非常短。
2. **并发标记阶段(Concurrent Mark)**:并发标记遍历堆，并跟踪可到达的对象。该阶段与应用程序同时运 行，其持续时间取决于存活对象的数量以及堆中对象图的结构。由于应用程序可以在此阶段自由分配新 数据，因此在并发标记期间堆占用率会上升。 
3. **最终标记阶段(Final Mark)**:通过排空所有等待中的标记/更新队列，并重新扫描根对象集来完成并发 标记。这是GC周期中的第二次暂停，这里最主要的时间消耗在排空队列并扫描根对象集合。
4. **并发清理阶段(Concurrent Cleanup)**:并发清除会回收即时的垃圾区域，即在并发标记之后检测到的 没有活动对象的区域。
5. **并发转移阶段(Concurrent Evacuation)**:并发转移将对象从各个不同区域复制到指定区域。这是与其 他OpenJDK GC的主要区别。此阶段与应用程序还是可以同时运行，持续时间取决于要复制的集合大 小，不会导致程序暂停。
6. **初始引用更新阶段(Init Update Refs)**:本阶段确保所有GC和应用程序线程均已完成转移，然后为下一 阶段GC做准备。这是周期中的第三次暂停，是所有暂停中最短的一次。
7. **并发引用更新阶段(Concurrent Update References)**:遍历堆，并发更新引用，并将引用更新为在并 发转移期间移动的对象。 这是与其他OpenJDK GC的主要区别。 它的持续时间取决于堆中对象的数 量，而不在乎对象图结构，因为它会线性扫描堆。此阶段与应用程序同时运行。
8. **最终引用更新阶段(Final Update Refs)**:通过再次更新现有的根对象集合来完成更新引用阶段。这是 GC周期中的最后一个暂停，其持续时间取决于根对象集的大小。
9. **并发清理阶段(Concurrent cleanup)**:回收现阶段没有引用的区域。

使用 Shenandoah 时需要全面了解系统运行情况，综合分析系统响应时间。下图是官方给出的各种 GC 工 作负载对比：

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\Shennandoah2.png" width="800px"></div>

## ZGC

> [新一代垃圾回收器ZGC的探索与实践](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)

Shenandoah 由于不是Oracle官方开发的垃圾收集器，难免受到⼀些来自官方的排挤。“根正苗红”的 ZGC也有非常亮眼的表现，从技术⻆度来看ZGC采用了⼀条完全不同的路线。ZGC收集器也是一款基于Region内存布局的，(暂时)不设分代的，但他巧妙使用使用了**读屏障、染色指针**和内存多重映射等技术来实现可并发的标记-整理算法的，解决了并发整理过程中的对象定位问题，实现了超低延迟。

ZCG的GC周期如图所示:

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\ZGC周期.png" width="700px"></div>

每个GC周期分为6个小阶段: 

1. 暂停-标记开始阶段:第一次暂停，标记根对象集合指向的对象； 
2. 并发标记/重映射阶段:遍历对象图结构，标记对象；
3. 暂停-标记结束阶段:第二次暂停，同步点，弱根对象清理；
4. 并发准备重定位阶段:引用处理、弱对象清理等；
5. 暂停-重定位开始阶段:第三次暂停，根对象指向重定向集合；
6. 并发重定位阶段:重定向集合中的对象重定向。 

这6个阶段在绝大部分时间都是并发执行的，因此对应用运行的GC停顿影响很小。 ZGC采用了并发的设计方式，这个实现是非常有技术含量的: 

* 需要把一个对象拷贝到另一个地址，这时另外一个线程可能会读取或者修改原来的这个老对象； 
* 即使拷贝成功，在堆中依然会有很多引用指向老的地址，那么就需要将这些引用更新为新地址。 

为了解决这些问题，ZGC引入了两项关键技术:“ **着色指针** ”和“ **读屏障** ”。

大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。

**着色指针**

ZGC使用着色指针来标记所处的 GC阶段。 着色指针是从64位的指针中，挪用了几位出来标识表示 `Marked0 、 Marked1 、 Remapped 、 Finalizable `。 所以不支持32位系统，也不支持指针压缩技术， 堆内存的上限是4TB。 从这些标记上就可以知道对象目前的状态，判断是不是可以执行清理压缩之类的操作。

> ZGC目前只有64位适用，因为染色指针是42-45位。

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\着色指针.png" width="600px"></div>

**读屏障**

对于GC线程与用户线程并发执行时，业务线程修改对象的操作可能带来的不一致问题，ZGC使用的是读屏障, 这点与其他GC使用写屏障不同。 

有读屏障在，就可以留待之后的其他阶段，根据指针颜色快速的处理。 并且不是所有的读操作都需要屏 障，例如下面只有第一种语句(加载指针时)需要读屏障，后面三种都不需要，又或者是操作原生类型的时 候也不需要。

可以把 读屏障 理解为一段代码，或者是一个指令, 后面挂着对应的处理函数。

例如下面代码：

```java
Object a = obj.x;
Object b = obj.x;
```

两行load操作对应的代码都插入了读屏障，但ZGC在第一个读屏障触发之后，不但将a的值更新为最新的， 通过 self healing 机制使得 obj.x 的指针也会被修正，第二个读屏障再触发时就直接进入FastPath，基本 上没有什么性能损耗了； 而Shenandoah 则不会修正obj.x的值，所以第二个读屏障又要进行一次 SlowPath。

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。

着色指针和读屏障，相当于在内存管理和应用程序代码之间加了一个中间层，通过这个中间层就可以实现更多的功能。但是也可以看到算法本身有一定的开销，也带来了很多复杂性。

## 如何正确选择GC？

| 垃圾收集器             | 分类 | 作用位置       | 算法                    | 特点         | 使用场景                               |
| ---------------------- | ---- | -------------- | ----------------------- | ------------ | -------------------------------------- |
| Serial                 | 串行 | 新生代         | 标记-复制               | 响应速度优先 | 单CPU环境下的client模式                |
| Serial Old             | 串行 | 老年代         | 标记-整理               | 响应速度优先 | 单CPU环境下的client模式（CMS后备方案） |
| ParNew                 | 并行 | 新生代         | 标记-复制               | 响应速度优先 | 多CPU环境Server模式下与CMS配合使用     |
| Parallel <br/>Scavenge | 并行 | 新生代         | 标记-复制               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| Parallel Old           | 并行 | 老年代         | 标记-整理               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| CMS                    | 并发 | 老年代         | 标记-清除               | 响应速度优先 | 互联网站或B/S业务                      |
| G1                     | 并发 | 新生代、老年代 | 标记-复制<br/>标记-压缩 | 响应速度优先 | 面向服务端应用，将来替换CMS            |

JDK11与JDK12起，分别开始支持ZGC与Shennandoah GC：

* Shenandoah: G1的改进版本，跟ZGC类似，通过“链接矩阵”代替RSet，通过Brooks Pointer和读屏障来解决并发整理过程中的对象定位问题。
* ZGC(Z Garbage Collector): 通过着色指针和读屏障解决并发整理过程中的对象定位问题，实现几乎全部的并发执行，几毫秒级别的延迟，线性可扩展。

可以看出GC算法和实现的演进路线：

* **串行 -> 并行(Serial  GC-> ParNew GC)**: 重复利用多核CPU的优势，大幅降低GC暂停时间，提升吞吐量。
* **并行 -> 并发(ParNew GC -> Prallel GC)**: 不只开多个GC线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线 程一起并发执行，减少了单次GC暂停持续的时间，这能有效降低业务系统的延迟。
* **CMS -> G1**: G1可以说是在CMS基础上进行迭代和优化开发出来的。修正了CMS一些存在的问题，而且在GC思想上有了重大进步，也就是划分为多个小堆块进行增量回收，这样就更进一步地降低了单次 GC暂停的时间。 可以发现，随着硬件性能的提升，业界对延迟的需求也越来越迫切。
* **G1 -> ZGC**: ZGC号称无停顿垃圾收集器，这又是一次极大的改进。ZGC和G1有一些相似的地方，但是底层的算法和思想又有了全新的突破。 ZGC把一部分GC工作，通过读屏障触发陷阱处理程序的方式， 让业务线程也可以帮忙进行GC。这样业务线程会有一点点工作量，但是不用等，延迟也被极大地降下 来了。

选择正确的 GC，唯一可行的方式就是去尝试，一般性的指导原则： 

* 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
* 如果系统考虑低延迟，每次 GC 时间尽量短，用 CMS GC；
* 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。 

对于内存大小的考量： 

* 一般 4G 以上，算是比较大，用 G1 的性价比较高。 
* 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。

最后需要明确一个观点：

- 没有最好的收集器，更没有万能的收集器。
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。

## JDK 的默认 GC 是什么？ 

虽然推出了这么多不同的垃圾回收器，但是每个JDK版本默认GC变化不多：

- 在JDK 7，默认是Parallel Scavenge + Serial Old。
- 在JDK 8 及JDK 7u4之后的版本，默认是Parallel Scavenge + Parallel Old。(**并行GC**)
- 在JDK 9 到JDK 16，默认是G1。

# 执行引擎

## Java为什么是半解释半编译语言？

JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。我们编写的`.java`源文件先是通过javac编译器编译成bytecode字节码文件，然后通过JVM内嵌的解释器将字节码文件转换成机器码。但是，我们常用的JVM例如Hotspot JVM中，提供了 JIT(Just-In-Time)编译器，也就是所谓的动态编译器。JIT编译器能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就是属于编译执行了。

- 解释器(Interpreter)：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
- JIT(Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

**为什么还需要再使用解释器来“拖累”程序的执行性能呢？**比如JRockit VM内部就不包含解释器，字节码全部都依靠JIT编译器编译后执行。

我们需要明确的是，当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的编译时间；但编译为本地代码后，执行效率高。

所以，尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。

**HotSpot JVM执行方式**

当虚拟机启动的时候，**解释器可以首先发挥作用**，而不必等待JIT编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据**热点探测**功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。

## Java中编译器分类有哪些？

**前端编译器**

Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器(其实叫“编译器的前端”更准确一些)把`.java`文件转变成`.class`文件的过程。常见前端编译器：Sun的**javac**、Eclipse JDT中的增量式编译器(ECJ)。

**后端运行期编译器**

**JIT编译器**(Just In Time Compiler)，把字节码转变成机器码的过程。常见JIT编译器：HotSpot VM的C1、C2编译器。

- `-client`：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
- `-server`：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。(使用C++)

**静态提前编译器**

**AOT编译器**(Ahead of Time Compiler)。所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。常见AOT 编译器有：GNU Compiler for the Java(GCJ)、Excelsior JET。

```java
 .java -> .class -> (使用jaotc) -> .so
```

JDK9引入了AOT编译器和实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。AOT编译器的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行；不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验。

缺点：

- 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包。
- 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。
- 还需要继续优化中，最初只支持Linux X64 java base。

# 命令行参数与命令行工具

## JVM常用命令行参数 jmap、jps？

**jps：查看所有 Java 进程**

- jps：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID(Local Virtual Machine Identifier, LVMID)。
- jps -q ：只输出进程的本地虚拟机唯一 ID。
- jps -l：输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。
- jps -v：输出虚拟机进程启动时 JVM 参数。
- jps -m：输出传递给 Java 进程 main() 函数的参数。jps -mlv： 打印Java 各个进程的详尽参数。

**jinfo：实时地查看和调整虚拟机各项参数**

- jinfo vmid ：输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。
- jinfo -flag name vmid ：输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails ：详细 GC 日志模式，这两个都是默认关闭的)。

**jstat：监视虚拟机各种运行状态信息**

jstat 命令使用格式：`jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]`

比如 jstat -gc -h3 2848 1000 10表示分析进程 id 为 2848 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。

常见的 option 如下：

- jstat -class vmid ：类加载(Class loader)信息统计；
- jstat -compiler vmid ：JIT 即时编译器相关的统计信息；
- jstat -gc vmid ：GC 相关的堆内存信息；
- jstat -gccapacity vmid ： 各个内存池分代空间的容量；
- jstat -gccause vmid：看上次 GC，本次 GC(如果正在 GC 中)的原因， 其他 输出和 -gcutil 选项一致
- jstat -gcnew vmid ：年轻代的统计信息(New = Young = Eden + S0 + S1)；
- jstat -gcnewcapcacity vmid ：年轻代空间大小统计；
- jstat -gcold vmid ：老年代和元数据区的行为统计；
- jstat -gcoldcapacity vmid ：显示老年代的大小；
- jstat -gcpermcapacity vmid ：显示永久代大小；
- jstat -gcmetacapacity vmid： meta 区大小统计;
- jstat -gcutil vmid ：GC 相关区域的使用率(utilization)统计；

另外，加上 -t参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。

**jmap：生成堆转储快照**

- -heap pid ：打印堆内存(/内存池)的配置和 使用信息。
- -histo pid ：看哪些类占用的空间最多, 直方图。
- -dump:format=b,file=xxxx.hprof pid：生成堆转储快照。

**jstack ：生成虚拟机当前时刻的线程快照**

- -F 强制执行 thread dump，可在 Java 进程卡死 (hung 住)时使用，此选项可能需要系统权限。
- -m 混合模式(mixed mode)，将 Java 帧和 native 帧一起输出，此选项可能需要系统权限。
- -l 长列表模式，将线程相关的 locks 信息一起输 出，比如持有的锁，等待的锁。

**jhat：分析 heapdump 文件**

**jcmd：执行 JVM 相关分析命令(整合命令)**

- jcmd pid VM.version 
- jcmd pid VM.flags 
- jcmd pid VM.command_line 
- jcmd pid VM.system_properties
- jcmd pid Thread.print
-  jcmd pid GC.class_histogram
-  jcmd pid GC.heap_info

## 常用可视化工具有哪些？

**（1）jsonsole：Java 监视与管理控制台**

JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出`console`命令启动或者在 JDK 目录下的 bin 目录找到`jconsole.exe`然后双击启动。

JConsole具体使用教程可参考：

* https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html

**（2）jvisualvm**

VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<https://visualvm.github.io/> 。Visual VM 中文文档：<https://visualvm.github.io/documentation.html>。

<div align="center"> <img src="https://img-blog.csdnimg.cn/20210529151713143.png" width="700px"></div>

<div align="center"> <img src="https://img-blog.csdnimg.cn/20210529151913902.png" width="700px"></div>

下面这段话摘自《深入理解 Java 虚拟机》。

> VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。

 VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：

- **显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。**
- **监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。**
- **dump 以及分析堆转储快照（jmap、jhat）。**
- **方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。**
- **离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。**
- **其他 plugins 的无限的可能性......**

 VisualVM 的具体使用可参考:

- <https://visualvm.github.io/documentation.html>
- <https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html>

**（3）VisualGC**

IDEA中有插件VisualGC，安装后即在右下角：

<div align="center"> <img src="https://img-blog.csdnimg.cn/20210529152219910.png" width="700px"></div>

**（4）jmc**

jmc是目前Oracle提供最强大的JVM可视化工具，它支持远程连接JVM（通过JMX连接如果想要用jmc监控远程的JVM进程，配置方式和jvisualvm方式一一样即可），除此之外它还支持Java**飞行记录器**。

<div align="center"> <img src="https://img-blog.csdnimg.cn/20210529152824420.png" width="700px"></div>

详细使用可查看[https://cs.xieyonghui.com/java/java-flight-recorder_72.html](

## 生成内存转储文件有哪几种方式? 用什么工具进行分析?

* jmap/jcmd
* JVisualVM/JMC/jconsole 
* 自动执行堆内存转储: -XX:+HeapDumpOnOutOfMemoryError -XX:`HeapDumpPath=<file-or-path>` 
*  JMX 客户端工具
* 编程方式调用: HotSpotDiagnosticMXBean

## 如何监控和诊断JVM堆内和堆外内存使用？

了解 JVM 内存的方法有很多，具体能力范围也有区别，简单总结如下：

- 可以使用综合性的图形化工具，如 JConsole、VisualVM(注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中)等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。

以 JConsole 为例，其内存页面可以显示常见的**堆内存**和**各种堆外部分**使用状态。

- 也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。
- 或者，也可以使用 jmap 等提供的命令，生成堆转储(Heap Dump)文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。
- 如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。
- 另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。

这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking(NMT)特性，它会从 JVM 本地内存分配的角度进行解读。

# 性能调优

## 堆内存参数

**(1)显式指定堆内存–Xms和-Xmx**

`-Xmx`，指定最大堆内存。`-Xms`，指定堆内存空间的初始大小。 

通常会将`-Xms`和`-Xmx`两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

**(2)显式新生代内存**

通过`-Xmn`等价于`-XX:NewSize`来指定新生代内存大小，使用 G1 垃圾收集器不应该设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 `-Xmx` 的 `1/2 ~ 1/4`。

举个例子，如果我们要为 新生代分配 最小256m 的内存，最大 1024m的内存我们的参数应该这样来写：

```java
-XX:NewSize=256m

-XX:MaxNewSize=1024m
```

如果我们要为 新生代分配256m的内存(NewSize与MaxNewSize设为一致)，我们的参数应该这样来写：

```java
 -Xmn256m
```

另外，还可以通过`-XX:NewRatio=<int>`来设置新生代和老年代内存的比值。

(3)**显示指定永久代/元空间的大小**

从Java 8开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存(永久代并不会出现这种情况)。`-XX:MetaspaceSize=size`设置元空间初始大小，`-XX:MaxPermSize=size` 元空间最大内存,

JDK1.7 及之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小，JDK 1.8设置此类参数会无效。

```java
-XX:PermSize=size //方法区 (永久代) 初始大小  

-XX:MaxPermSize=size //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区(HotSpot 的永久代)被彻底移除了，取而代之是元空间，元空间使用的是直接内存。

```java
-XX:MetaspaceSize=size //设置 Metaspace 的初始(和最小大小) 
-XX:MaxMetaspaceSize=size //设置 Metaspace 的最大大小，Java8默认不限制Meta空间，一般不允许设置该选项。
```

(4)**其他常用参数**

`-XX：MaxDirectMemorySize=size`，系统可以使用的最大堆外内存，这个参数跟 `-Dsun.nio.MaxDirectMemorySize` 效果相同。

`-Xss`, 设置每个线程栈的字节数，影响栈的深度。 例如 `-Xss1m` 指定线程栈为 1MB，与`-XX:ThreadStackSize=1m` 等价。

下面我画了一张图，这样有助力理清`Xmx、Xms、Xmn、Meta、 DirectMemory、Xss `这些内存参数的关系：

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\JVM启动参数.png" width="850px"></div>

## GC设置参数

**垃圾回收器**

`-XX:+PrintGCDetails` 打印GC日志详情
`-Xloggc:gc.demo.log` 指定日志文件
`-Xloggc:/log/gc.demo.log` 指定GC日志文件存放的绝对路径
`-XX:+UseGCLogFileRotation` 
`-XX:NumberOfGCLogFiles=5` 
`-XX:GCLogFileSize=20M` log文件大小
`-XX:+PrintGCDateStamps` 打印GC事件发生的日期时间
`-XX:+PrintGCApplicationStoppedTime` 输出每次GC的持续时间和程序暂停时间

`-XX:+PrintReferenceGC` 输出GC清理了多少引用类型



```java
-XX:+UseSerialGC——使用串行垃圾回收器(Serial/Serial Old 组合)

-XX:+UseParallelGC——使用并行垃圾回收器(ParNew/Serial Old 组合)
    
-XX:+UseParallelGC -XX:+UseParallelOldGC——使用并发垃圾回收器(Parallel Scavenge/Parallel Old组合)

-XX:+UseConcMarkSweepGC——使用 CMS 垃圾回收器(只能与ParNew/Serial搭配)

-XX:+UseG1GC——使用 G1 垃圾回收器

// Java 11
+-XX:+UnlockExperimentalVMOptions -XX:+UseZGC——使用ZGC垃圾回收器

// Java 12
+-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC——使用Shenandoah垃圾回收器
```

**GC日志记录**

```java
-XX:+PrintGCDetails 打印GC日志详情
-Xloggc:gc.demo.log 指定日志文件
-Xloggc:/log/gc.demo.log 指定GC日志文件存放的绝对路径
-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=5 
-XX:GCLogFileSize=20M log文件大小
-XX:+PrintGCDateStamps 打印GC事件发生的日期时间
-XX:+PrintGCApplicationStoppedTime 输出每次GC的持续时间和程序暂停时间-XX:+PrintReferenceGC 输出GC清理了多少引用类型
```

例如使用 G1 垃圾收集器, 一般配置哪些启动参数：

```java
-Xmx4g -Xms4g -XX:+UseG1GC
-XX:MaxGCPauseMillis=50
-XX:ParallelGCThreads=4
```

## JVM 疑难情况问题分析步骤？

> 推荐Arthas 诊断分析工具。

发现问题，我们可以这样来分析：

1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等， 基础服务、外部 API 依赖 出现故障。 

2、查看系统资源和监控信息： 硬件信息、操作系统平台、系统架构； 

* 排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发竞争等情况； 
* 排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调整、超时、连接数。

3、查看性能指标，包括实时监控、历史数据。可以发现假死，卡顿、响应变慢等现象； 

* 排查数据库， 并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询数据量、redo 日志、undo、 binlog 日志、代理、工具 BUG。可以考虑的优化包括： 集群、主备、只读实例、分片、分区； 可能还需要关注系统中使用的各类中间件。

4、排查系统日志， 比如重启、崩溃、Kill 。 

5、APM，比如发现有些链路请求变慢等等。 

6、排查应用系统

* 排查配置文件: 启动参数配置、Spring 配置、JVM 监控参数、数据库参数、Log 参数、内存问题，比如是否存在内存泄漏，内存溢出、批处理导致的内存放大等等；
* GC 问题， 确定 GC 算法，GC 总耗时、GC 最大暂停时间、分析 GC 日志和监控指标： 内存分配速度，分代提升速度，内存使用率等数据，适当时修改内存配置； 
* 排查线程, 理解线程状态、并发线程数，线程 Dump，锁资源、锁等待，死锁； 排查代码， 比如安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三方 库、XSS、CORS、正则； 
* 单元测试：覆盖率、边界值、Mock测试、集成测试。

7、排除资源竞争、坏邻居效应。

8、疑难问题排查分析手段

* DUMP 线程/内存；
* 抽样分析/调整代码、异步化、削峰填谷。

## JVM优化Java代码时都做了什么？

JVM 在对代码执行的优化可分为运行时(runtime)优化和即时编译器(JIT)优化。运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制(如偏斜锁)、内存分配机制(如 TLAB)等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存(inline cache，用于优化虚方法调用的动态绑定)。

JVM 的即时编译器优化是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化(speculative/optimistic optimization)。这个怎么理解呢？比如我有一条 `instanceof` 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回 `instanceof` 的结果。如果出现了其他类，那么就抛弃这段编译后的机器码，并且切换回解释执行。

当然，JVM 的优化方式仅仅作用在运行应用代码的时候。如果应用代码本身阻塞了，比如说并发时等待另一线程的结果，这就不在 JVM 的优化范畴啦。

## 谈谈你的GC调优思路？

1、理解应用需求和问题，确定调优目标，性能角度来看关注三方面：**内存占用(footprint)、延时(latency)和吞吐量(throughput)**，主要侧重于其中一个或两个方面。

- 比如，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。

2、掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。

- 比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。

3、选择的 GC 类型是否符合我们的应用特征。如果符合，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不符合，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。

4、通过分析确定具体调整的参数或者软硬件配置。

5、验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。

## 线上OOM如何排查呢？

 <div align="center"> <img src="..\..\05-Java-Virtual-Machine\images\OOM.png" width="1000px"></div>

内存溢出错误（OutOfMemoryError：xxx）大致有如下九种错误：

**1、Java heap space**：堆内存（Heap Space）没有足够空间

1. 原因分析：超大对象 / 上游系统流量飙升、超过预期的访问量 / 过度使用终结器（Finalizer）且未被GC / 大量内存泄漏
2. 解决方案：
    1. 先通过 `-Xmx` 参数调高 JVM 堆内存空间
    2. 检查超大对象合理性，是否一次性查询数据库全部没有做结果数限制。
    3. 业务峰值压力，可以考虑添加机器资源，或者做限流降级。
    4. 内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。

**2、GC overhead limit exceeded**：应用程序已经基本耗尽了所有可用内存， GC 也无法回收

1. 当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 `java.lang.OutOfMemoryError:GC overhead limit exceeded` 错误。
2. 解决方案跟 `Javaheap space` 非常类似 

**3、PermGen space**：永久代（Permanent Generation）已用满

1. 原因分析：通常是因为加载的 class 数目太多或体积太大。
2. 解决方案：
    1. 程序启动报错，修改 `-XX:MaxPermSize` 启动参数，调大永久代空间。 
    2. 应用重新部署时报错，重启 JVM 试试。
    3. 运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 `-XX:+CMSClassUnloadingEnabled` 和 `-XX:+UseConcMarkSweepGC`这两个参数允许 JVM 卸载 class。 
    4. 通过 jmap 命令 dump 内存对象 `jmap-dump:format=b,file=dump.hprof<process-id>` ，然后利用 Eclipse MAT [https://www.eclipse.org/mat](https://www.eclipse.org/mat) 功能逐一分析开销最大的 classloader 和重复 class。 

**4、Metaspace**：表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。

- 解决方法跟 `Permgenspace` 非常类似，Metaspace 空间大小的启动参数为 `-XX:MaxMetaspaceSize`。 

**5、Unable to create new native thread**：没有足够的资源分配创建native thread

1. 原因分析：
    1. 线程数超过操作系统最大线程数 ulimit 限制；
    2. 线程数超过 kernel.pid_max（只能重启）；
    3. native 内存不足；
2. 解决方案：
    1. 升级配置，为机器提供更多的内存；
    2. 降低 Java Heap Space 大小；
    3. 修复应用程序的线程泄漏问题；
    4. 限制线程池大小；
    5. 使用 -Xss 参数减少线程栈的大小；
    6. 调高 OS 层面的线程最大数：执行 `ulimia-a` 查看最大线程数限制，使用 `ulimit-u xxx` 调整最大线程数限制。 

**6、Out of swap space**：虚拟内存已被耗尽

1. 原因分析：地址空间不足/物理内存已耗光/本地内存泄漏（native leak）/执行 `jmap-histo:live<pid>` 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。 
2. 解决方案：
    1. 升级地址空间为 64 bit；
    2. 使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。
    3. Direct ByteBuffer 问题可以通过启动参数 `-XX:MaxDirectMemorySize` 调低阈值。 
    4. 升级服务器配置/隔离部署，避免争用。

**7、Kill process or sacrifice child**：操作系统层面触发，进程被OOM Killer 杀死

1. 原因分析：Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。
2. 解决方案：升级服务器配置/隔离部署，避免争用/OOM Killer 调优

**8、Requested array size exceeds VM limit**：程序请求创建的数组超过最大长度限制

1. JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 `Integer.MAX_VALUE-2`。 
2. 通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。

**9、Direct Buffer Memory**：Direct ByteBuffer 的默认大小为 64 MB，使用超出这个限制

1. Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。
2. 解决方案：
    1. Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。
    2. 检查是否直接或间接使用了 NIO，如 netty，jetty 等。
    3. 通过启动参数 `-XX:MaxDirectMemorySize` 调整 Direct ByteBuffer 的上限值。 
    4. 检查 JVM 参数是否有 `-XX:+DisableExplicitGC` 选项，如果有就去掉，因为该参数会使 `System.gc()` 失效。 
    5. 检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 `sun.misc.Cleaner` 的 `clean()` 方法来主动释放被 Direct ByteBuffer 持有的内存空间。 
    6. 内存容量确实不足，升级配置。

查看到日志报出OOM后，我们[该如何排查问题呢？](https://time.geekbang.org/column/article/108582)这篇文章模拟了一个ThreadLoacl内存泄漏导致的内存溢出案例，它排查步骤如下：

1. 开启堆内存异常日志，通过命令启动应用程序:
```powershell
java -jar -Xms1000m -Xmx4000m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof  -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heapTest.log heapTest-0.0.1-SNAPSHOT.jar
```
2. 日志中发现是`Java heap space`异常。
3. top 命令查看进程在整个系统中内存的使用率，发现Java 进程内存使用率已经达到了 55%。
4. 通过 top -Hp pid 查看具体线程占用系统资源情况。
5. 再通过 jstack pid 查看具体线程的堆栈信息，可以发现该线程一直处于 TIMED_WAITING 状态，此时 CPU 使用率和负载并没有出现异常，我们可以排除死锁或 I/O 阻塞的异常问题。
6. 通过 jmap 查看堆内存的使用情况，发现，老年代的使用率几乎快占满，内存一直得不到释放。基本确定发生了内存泄漏。
7. jmap 查看存活对象的数量，Byte 对象占用内存明显异常，说明代码中 Byte 对象存在内存泄漏。
8. dump 文件，通过 MAT 打开 dump 的内存日志文件，发现 MAT 已经提示了 byte 内存异常。
9. 点击进入到 Histogram 页面，可以查看到对象数量排序，可以看到 Byte[]数组排在了第一位，选中对象后右击选择 with incomming reference 功能，可以查看到具体哪个对象引用了这个对象，很明显地查看到是 ThreadLocal代码出现问题。
