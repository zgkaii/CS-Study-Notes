<!-- MarkdownTOC -->
- [JVM体系结构](#jvm体系结构)
  - [JDK、JRE与JVM区别和联系？](#jdkjre与jvm区别和联系)
  - [什么是字节码，采用字节码的好处是什么？](#什么是字节码采用字节码的好处是什么)
  - [.class文件执行过程？](#class文件执行过程)
- [类加载](#类加载)
  - [请介绍类加载过程？](#请介绍类加载过程)
  - [什么是类加载器？](#什么是类加载器)
  - [Java类加载机制是什么？](#java类加载机制是什么)
- [内存模型](#内存模型)
  - [谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?](#谈谈jvm内存区域的划分哪些区域可能发生outofmemoryerror)
  - [程序计数器](#程序计数器)
  - [虚拟机栈](#虚拟机栈)
  - [本地方法栈](#本地方法栈)
  - [堆区](#堆区)
  - [方法区](#方法区)
  - [Java对象在堆中分配过程？](#java对象在堆中分配过程)
  - [TLAB是什么呢？](#tlab是什么呢)
  - [请简要描述 Java 对象的存储结构](#请简要描述-java-对象的存储结构)
- [垃圾回收基础概念](#垃圾回收基础概念)
  - [（标记阶段）如何判断对象已死？](#标记阶段如何判断对象已死)
  - [哪些对象可以作为GC Roots?](#哪些对象可以作为gc-roots)
  - [（清除阶段）常见垃圾回收算法？](#清除阶段常见垃圾回收算法)
  - [串行、并行、并发是什么？](#串行并行并发是什么)
  - [STW是什么？](#stw是什么)
  - [安全点与安全区域是什么？](#安全点与安全区域是什么)
  - [内存溢出与内存泄漏区别？](#内存溢出与内存泄漏区别)
  - [Minor GC、Major GC、Full GC区别？](#minor-gcmajor-gcfull-gc区别)
- [垃圾回收器](#垃圾回收器)
  - [常用垃圾回收器组合](#常用垃圾回收器组合)
    - [Serial GC：串行回收](#serial-gc串行回收)
    - [ParNew GC：并行回收](#parnew-gc并行回收)
    - [Parallel GC：吞吐量优先](#parallel-gc吞吐量优先)
  - [CMS垃圾回收器回收过程](#cms垃圾回收器回收过程)
  - [G1垃圾回收器回收过程](#g1垃圾回收器回收过程)
  - [如何选择GC呢？](#如何选择gc呢)
- [执行引擎](#执行引擎)
  - [Java为什么是半执行半编译语言？](#java为什么是半执行半编译语言)
  - [Java中编译器分类有哪些？](#java中编译器分类有哪些)
- [命令行参数与命令行工具](#命令行参数与命令行工具)
  - [JVM常用命令行参数 jmap、jps？](#jvm常用命令行参数-jmapjps)
  - [常用可视化工具有哪些？](#常用可视化工具有哪些)
  - [生成内存转储文件有哪几种方式? 用什么工具进行分析?](#生成内存转储文件有哪几种方式-用什么工具进行分析)
  - [如何监控和诊断JVM堆内和堆外内存使用？](#如何监控和诊断jvm堆内和堆外内存使用)
- [性能调优](#性能调优)
  - [堆内存参数](#堆内存参数)
  - [GC设置参数](#gc设置参数)
  - [JVM 疑难情况问题分析步骤？](#jvm-疑难情况问题分析步骤)
  - [JVM优化Java代码时都做了什么？](#jvm优化java代码时都做了什么)
  - [谈谈你的GC调优思路？](#谈谈你的gc调优思路)
  - [线上OOM如何排查呢？](#线上oom如何排查呢)

<!-- /MarkdownTOC -->

# JVM体系结构

## JDK、JRE与JVM区别和联系？

**JDK(Java Development Kit)**是用于开发Java应用程序的软件工具集合，主要包括了Java运行时环境（JRE）和一些Java开发工具（例如解释器`java.exe`，编译器`javac.exe`，打包工具`jar.exe`，文档生成器`javadoc.exe`等等）。

**JRE(Java RunTime Environment)**提供Java应用程序执行时所需的环境，由Java虚拟机（JVM）、核心类（libraries）及支持文件组成。

**JVM(Java Virtual Environment)**即所谓的Java虚拟机，它用于解释由`.java`文件编译生成的`.class`字节码文件，并将其映射到本地的CPU的指令集或OS系统调用中。虽然不同的操作系统使用不同的JVM映射规则，但JVM解释/编译字节码文件的规则一致，这使得Java语言具有了跨平台的特性。除此之外，JVM平台的不同语言还共享JVM所带来的垃圾回收器（GC）与即时编译器（JIT）。

<div align="center"> <img src="..\..\05-Java\images\jvm\runanywhere.png" width="600px"></div>

三者之间关系：

```html
JDK > JRE > JVM
JDK = JRE + tools => JRE = JVM + libraries
```

## 什么是字节码，采用字节码的好处是什么？

我们平时说的Java字节码（Java bytecode），指的是用Java语言编译成的字节码。不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。

Java虚拟机与Java语言并没有必然的联系，它只与特定的**二进制文件格式**——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心**“字节码”文件**。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，**只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行**。

Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。**这也就是解释了 Java 的编译与解释并存的特点**。

## .class文件执行过程？

Java虚拟机与Java语言并没有必然的联系，它只与特定的**二进制文件格式**——`.class文件`格式所关联，class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

<div align="center"> <img src="..\..\05-Java\images\jvm\class执行.png" width="600px"></div>

# 类加载

## 请介绍类加载过程？

一个类在JVM里的生命周期有7个阶段，分别是加载（Loading）、校验（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）、卸载（Unloading）。 其中前五个部分（**加载，验证，准备，解析，初始化**）统称为类加载。完整的流程图如下所示：

<div align="center"> <img src="..\..\05-Java\images\jvm\类的生命周期.png" width="600px"></div>

**加载阶段**：是整个“类加载”（Class Loading）过程中的第一个阶段，JVM需要完成三件事：

* 通过一个类的**全限定名获取定义此类的二进制字节流**，简单点说就是 **找到文件系统中/jar包中/或存在于任何地方的“ class文件 ”**。 如果找不到则会抛出 `NoClassDefFound `错误。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* **在内存中生成一个代表这个类的`java.lang.Class`对象**，作为方法区这个类的各种数据的访问入口。

**验证阶段**：确保Class文件的**字节流**中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

* 文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以**魔数0xCAFEBABE**开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
* 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类（除了`java.lang.Object`之外，所有的类都应当有父类）；这个类的父类是否继承了不允许被继承的类（被final修饰的类）... ...
* 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
* 符号引用验证：对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

**准备阶段**：为类的静态变量分配内存，并将其初始化为默认值。

这个阶段将会创建静态字段, 并将其初始化为标准默认值（**比如 null 或者 0值**，Boolean类型数据的零值为False ），并分配方法表，即在方法区中分配这些变量所使用的内存空间。

* **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化**；

* 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

**解析阶段**：解析符号引用阶段主要将**常量池**内的**符号引用转换为直接引用的过程**。

* 解析动作主要针**加载阶段**：是整个“类加载”（Class Loading）过程中的第一个阶段，JVM需要完成三件事：

  * 通过一个类的**全限定名获取定义此类的二进制字节流**，简单点说就是 **找到文件系统中/jar包中/或存在于任何地方的“ class文件 ”**。 如果找不到则会抛出 `NoClassDefFound `错误。
  * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  * **在内存中生成一个代表这个类的`java.lang.Class`对象**，作为方法区这个类的各种数据的访问入口。

  **校验阶段**：确保Class文件的**字节流**中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

  * 文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以**魔数0xCAFEBABE**开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
  * 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类（除了`java.lang.Object`之外，所有的类都应当有父类）；这个类的父类是否继承了不允许被继承的类（被final修饰的类）... ...
  * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
  * 符号引用验证：对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

  **准备阶段**：为类的静态变量分配内存，并将其初始化为默认值。

  这个阶段将会创建静态字段, 并将其初始化为标准默认值（**比如 null 或者 0值**，Boolean类型数据的零值为False ），并分配方法表，即在方法区中分配这些变量所使用的内存空间。

  * **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化**；

  * 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

  **解析阶段**：解析符号引用阶段主要将**常量池**内的**符号引用转换为直接引用的过程**。

  * 解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型**等。对应常量池中的`CONSTANT Class info、CONSTANT Fieldref info、CONSTANT_Methodref_info`等。

  **初始化阶段**：JVM规范明确规定, 必须在类的首次“主动使用”时才能执行类初始化。 初始化的过程包括执行： **类构造器方法，static静态变量赋值语句 和static静态代码块**。

  * 编译器收集`<clinit>()`动作按照源文件顺序执行。所以说，静态语句块中只能访问到定义在静态语句块之外的变量，静态语句块中访问静态语句块中的变量会提示“非法向前引用”。
  * 父类的`<cinit>()`方法优先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

## 什么是类加载器？

类加载过程可以描述为**“通过一个类的全限定类名来获取此类的class对象”，即所谓的全限定名来获取描述该类的二进制字节流）**，这个过程由**类加载器**（Class Loader）来完成。

在程序中我们最常见的类加载器主要有3类：**启动类加载器**（BootstrapClassLoader）、**扩展类加载器**（ExtClassLoader） 和**应用类加载器**（AppClassLoader）。

<div align="center"> <img src="..\..\05-Java\images\jvm\JVM 类加载器.png" width="800px"></div>

其中，启动类加载器又名引导类加载器，用C/C++语言实现，主要用于加载Java核心类库，如`rt.jar`。

扩展类加载器派生于`ClassLoader`类，主要加载`/lib/ext`扩展目录的jar包。

应用程序类加载器又名系统类加载器，派生于`ClassLoader`类，负责加载用户环境变量`CLASSPATH`或系统属性`java.class.path`指定路径下的类库，该类加载是程序中默认的类加载器。

用户自定义类加载器常用于实现隔离加载类、修改类加载的方式、扩展加载源与防止源码泄漏。实现自定义加载器步骤如下：

* 继承抽象类`java.lang.ClassLoader`类。
* JDK 1.2之前，重写`loadClass()`方法；JDK 1.2 之后，建议将类加载逻辑重写在`findclass()`方法中。
* 没有过于复杂的需求，可直接继承`URIClassLoader`类，这样可避免去编写`findclass()`方法及其获取字节码流的方式，

## Java类加载机制是什么？

Java中类加载机制为**双亲委派机制**，它指的是，当某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，**依次递归**，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

<div align="center"> <img src="..\..\05-Java\images\jvm\双亲委托.png" width="600px"></div>

**双亲委派机制的优势**：（1）避免类的重复加载（2）保护程序安全，防止核心API被随意篡改。

# 内存模型

## 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?

JVM在执行Java程序的过程中会把它所管理的内存主要划分5个不同的数据区域：**本地方法栈、程序计数器、虚拟机栈、堆、方法区**。这些区域有各自的用途和创建与销毁的时间。有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

 <div align="center"> <img src="..\..\05-Java\images\jvm\运行时数据区.png" width="800px"></div>

==注意==，《Java 虚拟机规范》中指明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择区进行垃圾收集或者进行压缩。” 但对于 HotSpotJVM 而言，方法区还有一个别名叫做**Non-Heap(非堆）**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

如上图所描述一样，在JDK 1.7 之前，方法区在**逻辑上**属于**非堆**，是一块独立的内存区域，但其实际物理内存其实是在堆区的（存放于永久代）；直到JDK 1.8后，方法区的实现才被移动至直接内存中的元空间（MetaSpace）中，逻辑内存与实际物理内存都与堆区分开。

一般来讲，黄色部分为线程隔离的数据区域，其他部分为线程共享的区域。

|    区域    | 是否线程共享 | 是否存在内存溢出 | 是否存在GC |
| :--------: | :----------: | :--------------: | :--------: |
| 本地方法栈 |      否      |        是        |     否     |
| 程序计数器 |      否      |        否        |     否     |
|  虚拟机栈  |      否      |        是        |     否     |
|    堆区    |      是      |        是        |     是     |
|   方法区   |      是      |        是        |     是     |

> 内存溢出与内存泄漏：
>
> 内存泄漏（Memory Leak）是指本来无用的对象却继续占用内存，没有在恰当的时机释放占用的内存的情况。
>
> 内存溢出（Out Of Memory，简称OOM）是指可使用的内存不足的情况。
>
> 一般来讲，内存泄漏是资源管理问题或程序BUG，而内存溢出则是内存空间不足和内存泄漏的最终结果。

## 程序计数器

程序计数器（Program Counter Register）是对物理PC寄存器的一种模拟，主要用于存储当前线程需要执行的字节码指令地址。在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致。

例如下面的字节码文件，字节码左边的行号标识，它其实就是**指令地址**。

```java
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
```

> 注意：程序计算器是运行速度最快的存储区域，也是唯一一块不会出现OOM的内存区域。

## 虚拟机栈

常常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。在Java中，“栈”通常就是指这里讲的虚拟机栈。

Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **`OutOfMemoryError`：** 若Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError 错误。

**扩展：方法/函数如何调用？**

栈是一种快速有效的分配存储方式，**访问速度仅次于程序计数器**。JVM直接对Java栈的操作只有两个：

- 每一次方法执行，都伴随着对应的栈帧压栈（进栈/入栈）。
- 每一个方法执行结束，都会有一个对应栈帧被弹出。

## 本地方法栈

本地方法栈（Native Method Stack）用于管理本地方法的调用。其中，本地方法（NatIve Method）就是调用非Java代码的接口，例如`java.lang.Thread`中的`private native void start0()`方法。

Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。因此虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

## 堆区

对Java应用程序而言，Java堆（Java Heap）是虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。

> 注意：由于逃逸分析，栈上分配和标量替换等技术的发展，导致并不是所有对象实例一定要在堆中分配内存。

Java堆是垃圾收集器管理的主要区域，又称GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。新生代分细致一点有：Eden 空间、From Survivor、To Survivor 空间等。这样对堆进行分代划分是为了更好地回收内存，或者更快地分配内存。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

JDK 1.7及之前堆内存逻辑上分为三部分：新生代+老年代+**永久代**

| 新生代                                    | 老年代                  | 永久代          |
| ----------------------------------------- | ----------------------- | --------------- |
| Young Generation Space                    | Tenure generation space | Permanent Space |
| Young/New（又被划分为Eden区和Survivor区） | Old/Tenure              | Perm            |

Java 8及之后堆内存逻辑上分为三部分：新生代+养老区+**元空间**

| 新生代                                    | 老年代                  | 元空间     |
| ----------------------------------------- | ----------------------- | ---------- |
| Young Generation Space                    | Tenure generation space | Meta Space |
| Young/New（又被划分为Eden区和Survivor区） | Old/Tenure              | Meta       |

## 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。上面我们已经提到过，方法区还有一个别名叫做**Non-Heap(非堆）**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

但实际上，JDK 1.7 之前，方法区正是在堆内存的永久代中实现的，但这样导致Java更容易遇到内存溢出问题。JDK 1.7时，就已经把原本（JDK 1.6）放在永久代的字符串常量池、静态变量等移出到堆；而到了 JDK 1.8，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间（Metaspace）来代替，把JDK 1.7中永久代还剩余的内容（主要是类型信息）移到元空间中。

根据Java虚拟机规范，如果方法区无法满足新的内存分配需求时，也将抛出OutOfMemoryError异常。

>  方法区和永久代的关系：
>
>  《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，不同的 JVM 上方法区的实现是可以不同的。  **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

## Java对象在堆中分配过程？

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

* new的对象先放Eden区。
* 当Eden区的空间填满时，程序还需创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收（**MinorGC**，又称Young GC），将Eden区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden区。
* 然后将Eden区中的幸存的对象移动到From区（Survivor From区）。

- 如果再次触发垃圾回收，此时Eden区和From区幸存下来的对象就会放到To区（Survivor To区）。
  - 此过程后From区对象都放到To区，故From区变To区，原To区变From区。

- 如果再次经历垃圾回收，此时Eden区对象会重新放回From区，接着再去To区。
- 啥时候能去养老区呢？当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，对象晋升至养老区。可以设置次数：`-Xx:MaxTenuringThreshold= N`，**默认是15次**。
- 当养老区内存不足时，再次触发垃圾回收（**Major GC**），进行养老区的内存清理。
- 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。

特别注意，在Eden区满了的时候，才会触发MinorGC；而幸存者区满了后，不会触发MinorGC操作。如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。

 <div align="center"> <img src="..\..\05-Java\images\jvm\堆对象分配过程.png" width="600px"></div>

## TLAB是什么呢？ 

**为什么有TLAB？**

`TLAB：Thread Local Allocation Buffer`，也就是为每个线程单独分配了一个缓冲区。

堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**什么是TLAB**

从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为**每个线程分配了一个私有缓存区域**，它包含在Eden空间内。

多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略。所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。

在程序中，开发人员可以通过选项`-XX:UseTLAB`设置是否开启TLAB空间。默认情况下，TLAB空间的内存非常小，仅占有**整个Eden空间的1%**，当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden空间的百分比大小。

一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。

## 请简要描述 Java 对象的存储结构

 <div align="center"> <img src="..\..\05-Java\images\jvm\2020101115073675.png" width="900px"></div>

# 垃圾回收基础概念

GC是英文词汇`Garbage Collection` 的缩写， 中文一般直译为 “ 垃圾收集 ”。垃圾回收器回收垃圾一般分为两阶段：（1）**Marking (标记)**，标记“存活”的对象；**Sweeping (清除)**， 清除"死亡"的垃圾对象，释放内存。

## （标记阶段）如何判断对象已死？

**引用计数算法**：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。

* 优点：实现简单，垃圾对象便于标识；判定效率高，无延迟。
* 缺点：计数器增加存储开销；更新计数增加时间开销；**无法处理循环引用**问题。

**可达性分析算法**：又称根搜索算法、追踪性垃圾收集（Tracing Garbage Collection），其以根对象集合（GC Roots）为起始点，按照从**上至下的方式搜索被根对象集合所连接的目标对象是否可达**。如果目标对象没有任何引用链（Reference Chain，即搜索所走过的路径）相连，则是不可达的，意味着该对象己经死亡，可以标记为垃圾对象。

 <div align="center"> <img src="..\..\05-Java\images\jvm\可达性.png" width="600px"></div>

* 优点：实现简单和执行高效；能有效处理循环引用的问题。

## 哪些对象可以作为GC Roots?

有一些特定的对象能被指定为 **Garbage Collection Roots(GC根元素)**：

- 当前正在执行的方法里的局部变量和输入参数
- 活动线程(Active threads)
- 本地方法栈内JNI（通常说的本地方法）引用的对象
- 内存中所有类的静态字段(static field)
- 方法区中常量引用的对象，例如字符串常量池（String Table）里的引用。
- 所有被同步锁synchronized持有的对象。
- Java虚拟机内部的引用，例如基本数据类型对应的Class对象，一些常驻的异常对象（如：`NullPointerException`、`OutOfMemoryError`），系统类加载器。
- 反映java虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等。

## （清除阶段）常见垃圾回收算法？

**（1）标记-清除算法**

标记-清除算法(Mark-Sweep)思想很简单，就是直接清除掉垃圾对象（注意，标记的是可达的对象，不是垃圾对象）。

这种算法需要使用空闲表(**free-list**)，来记录所有的空闲区域，以及每个区域的大小。维护空闲表增加了对象分配时的开销。

* 如果内存规整，采用指针碰撞的方式进行内存分配；内存不规整，虚拟机需要维护一个列表，空闲列表分配。
* 清理出来的空闲内存大多是不连续的，产生内存碎片，仍然无法存放大对象。
* GC时需要暂停整个应用程序线程（STW）。

 <div align="center"> <img src="..\..\05-Java\images\jvm\标记清除算法.png" width="600px"></div>

**（2）标记复制算法**

**标记-复制算法(Mark and Copy)**核心思想是，将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。

* 优点：实现简单，运行高效；保证了空间的连续性。
* 缺点：是将可用内存缩小为了原来的一半，空间浪费未免太多；对象存活率较高时就要进行较多的复制操作，效率会大大降低。

 <div align="center"> <img src="..\..\05-Java\images\jvm\标记复制算法.png" width="600px"></div>

**（3）标记-整理算法**

标记-整理算法又称标记-压缩或标记-清除-压缩（Mark-Sweep-Compact）算法，其核心思想是让所有存活的对象都向内存空间一端移动（压缩到一端），然后直接清理掉边界以外的内存。

* 优点：消除了标记-清除算法当中，内存区域分散的缺点；消除了复制算法当中，内存减半的高额代价。
* 缺点：GC时需要暂停整个应用程序线程（STW）；如果被移动对象被其他对象引用，则还需要调整引用的地址。

 <div align="center"> <img src="..\..\05-Java\images\jvm\标记整理算法.png" width="600px"></div>

**三者之间比较**

| 比较         | 标记-清除          | 标记-整理        | 标记-复制                             |
| ------------ | ------------------ | ---------------- | ------------------------------------- |
| **速率**     | 中等               | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** | 否                 | 是               | 是                                    |

> 没有最好的算法，只有最合适的算法。

**扩展——其他算法**：

分代收集算法（Generational Collecting）：对不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。目前几乎所有的GC都采用分代收集(Generational Collecting)算法执行垃圾回收的。

增量收集算法（Incremental Collecting）：让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

* 优点：对线程间冲突的妥善处理。
* 缺点：造成系统吞吐量的下降。

## 串行、并行、并发是什么？

并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：

- 串行（Serial）：在同一时间段内，只允许有一个CPU（单线程）用于执行垃圾回收操作，GC期间需暂停所有应用程序线程（STW）。
- 并行（Parallel）：在同一时间段内，可以运用多个CPU（多线程）同时执行垃圾回收，因此提升了应用的吞吐量，不过仍存在STW。如ParNew、Parallel Scavenge、Parallel old。
- 并发（Concurrent）：在同一时间段内，用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。

## STW是什么？

Stop The World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。

- 分析工作必须在一个能确保一致性的快照中进行。
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。
- 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。

## 安全点与安全区域是什么？

程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safe point）”。

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

## 内存溢出与内存泄漏区别？

内存泄漏（Memory Leak）是指本来无用的对象却继续占用内存，没有在恰当的时机释放占用的内存的情况。比如对象间循环引用。

内存溢出（Out Of Memory，简称OOM）是指可使用的内存不足的情况。

一般来讲，内存泄漏是资源管理问题或程序BUG，而内存溢出则是内存空间不足和内存泄漏的最终结果。

## Minor GC、Major GC、Full GC区别？

针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。

**Minor GC/Young GC** ——新生代GC：当年轻代空间不足时触发（每次Minor GC会清理年轻代的内存）

- 因为Java对象大多都具备 朝生夕灭 的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

**Major GC/Old GC**——老年代GC：出现了MajorGC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）

- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了。

**FullGC**——整堆收集。STW时间更长了，Full GC 是**开发或调优中尽量要避免。**触发Full GC执行的情况有：

- 在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。
- 显式调用 System#gc() 方法时。
- 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。

# 垃圾回收器

## 常用垃圾回收器组合

JDK 1.8之前，主要有7款不同的垃圾回收器。

- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 整堆收集器：G1

 <div align="center"> <img src="..\..\05-Java\images\jvm\20201015092111694.png" width="600px"></div>

目前来说，常用的GC组合有：

（1）（Serial GC：串行回收）Serial+Serial Old 实现单线程的低延迟垃圾回收机制；

（2）（ParNew GC：并行回收）ParNew+Serial Old ，实现多线程的低延迟垃圾回收机制；

（3）（Parallel GC：吞吐量优先）Parallel Scavenge+Parallel Old，实现多线程的高吞吐量垃圾回收机制。

**JDK8 的默认 GC 是什么？ JDK9，JDK10，JDK11…等等默认的 GC 是什么**？

虽然推出了这么多不同的垃圾回收器，但是每个JDK版本默认GC变化不多：

- 在JDK 7，默认是Parallel Scavenge + Serial Old。
- 在JDK 8 及JDK 7u4之后的版本，默认是Parallel Scavenge + Parallel Old。
- 在JDK 9 到JDK 16，默认是G1。

### Serial GC：串行回收

Serial GC（`Serial/Serial Old`组合）是最基本、历史最悠久的垃圾收集器，其对年轻代使用标记-复制算法，对老年代使用标记-整理算法，年轻代和老年代的垃圾回收都会触发STW。适用于可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms）的场景。

 <div align="center"> <img src="..\..\05-Java\images\jvm\Serial.png" width="650px"></div>

启动参数：`-XX:+UseSerialGC`

### ParNew GC：并行回收

ParNew GC（`ParNew/Serial Old` 组合）对年轻代使用标记-复制算法 ，在老年代使用标记-整理算法 ，是Serial GC的多线程版本，年轻代和老年代的垃圾回收都会触发STW。对于新生代，回收次数频繁，使用并行方式高效；对于老年代，回收次数少，使用串行方式节省资源。

 <div align="center"> <img src="..\..\05-Java\images\jvm\ParNew.png" width="650px"></div>

启动参数：`-XX:+UseParNewGC`，还可通过命令行参数`-XX:ParallelGCThreads=N`来指定 GC 线程数，其默认值为CPU核心数。

### Parallel GC：吞吐量优先

Parallel GC（`Parallel Scavenge/Parallel Old`组合）对年轻代使用标记-复制算法 ，在老年代使用标记-整理算法，同样具备并行回收功能，年轻代和老年代的垃圾回收都会触发STW。

* 和ParNew GC不同，Parallel GC采用自适应调节策略，目的则是**达到一个可控制的吞吐量（Throughput）**，它也被称为吞吐量优先的垃圾收集器。
* **在Java8中，默认是此垃圾收集器**。

 <div align="center"> <img src="..\..\05-Java\images\jvm\Parallel.png" width="650px"></div>

启动参数：`-XX:+UseParallelGC -XX:+UseParallelOldGC`。

## CMS垃圾回收器回收过程

CMS GC的官方名称为 “Mostly Concurrent Mark and Sweep Garbage Collector”（最大并发-标记-清除-垃圾收集器）。其对年轻代采用并行STW方式的标记-复制算法 ，对老年代主要使用并发标记-清除算法 ，它第一次实现了让垃圾收集线程与用户线程同时工作。

优点：并发收集、低延迟。

缺点：老年代内存碎片。

 <div align="center"> <img src="..\..\05-Java\images\jvm\CMS.png" width="750px"></div>

启动参数：*-XX:+UseConcMarkSweepGC*。

CMS整个过程比之前的收集器要复杂，整个过程分为6个主要阶段：

- **初始标记**（Initial-Mark）阶段：程序中所有的工作线程都将会因为**STW**机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
- **并发标记**（Concurrent-Mark）阶段：在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。
- **并发预处理**（Concurrent-Preclean）阶段：此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的卡片标记（Card Marking）。
- **最终标记**（Final-Remark）阶段：最终标记阶段是此次 GC 事件中的**第二次（也是最后一次）STW 停顿**。本阶段的目标是完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程 序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。
- **并发清除**（Concurrent-Sweep）阶段：此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收他们占用的内存空间。
- **并发重置**（Concurrent Reset）阶段：此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备。

## G1垃圾回收器回收过程

G1 的全称是`Garbage-First`，意为垃圾优先，哪一块的垃圾最多就优先清理它。G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。

使用G1收集器时，它将整个Java堆划分成**约2048**个大小相同的独立堆区域(smaller heap regions)，每个Region块，可能一会被定义成 Eden区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来 就是年轻代，所有的 Old 区拼在一起那就是老年代。

G1垃圾收集器还增加了一种新的内存区域，叫做`Humongous`内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。

 <div align="center"> <img src="..\..\05-Java\images\jvm\20201015092110555.png" width="600px"></div>

启动参数`-XX:+UseG1GC`。

G1 GC的垃圾回收过程主要包括如下三个环节：

**年轻代模式转移暂停（Evacuation Pause）**：当年轻代空间用满后，应用线程会被暂停（STW），年轻代内存块中的存活对象被拷贝到存活区（标记-复制算法）。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。 拷贝的过程称为转移(Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。

**并发标记（Concurrent Marking）**： G1并发标记的过程与CMS基本上是一样的。

* **阶段 1: Initial Mark(初始标记)** ：标记所有从GC根对象直接可达的对象。在CMS中需要一次STW暂停，但G1里面通常是在转移暂停的同时处理这些事情，所以它的开销是很小的。 

  **阶段 2: Root Region Scan(Root区扫描)**：此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。因为在并发标记的过程中迁移对象会造成很多麻烦，所以此阶段必须在下一次转移暂停之前完成。如果必须 启动转移暂停，则会先要求根区域扫描中止，等它完成才能继续扫描。在当前版本的实现中，根区域是存活 的小堆块：包括下一次转移暂停中肯定会被清理的那部分年轻代小堆块。 

  **阶段 3: Concurrent Mark(并发标记)**：此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。 为了确保标记开始时的快照准确性，所有应用线程并发对对象图执行引用更新，G1 要求放弃前面阶段为了 标记目的而引用的过时引用。 

  **阶段 4: Remark(再次标记)**：和CMS类似，这是一次STW停顿(因为不是并发的阶段)，以完成标记过程。G1收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标 记开始时未被标记的存活对象。 

  **阶段 5: Cleanup(清理)**：这一阶段也执行某些额外的清理，如引用处理或者类卸载(class unloading)。 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC的效率（标记-整理算法）。此阶段也为下一次标记执行必需的所有整理工作(house-keeping activities)：维护并发标记 的内部状态。 

  * 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的STW暂停，才能不受应用线程的影响并完成作业。

**转移暂停: 混合模式（Evacuation Pause (mixed)）**：并发标记完成之后，G1将执行一次**混合收集（mixed collection）**，就是不只清理年轻代，还将一部分老年代区域也加入到回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次`young`模式的转移暂停。 具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。 其中包括指定的软实时性 能指标，存活性，以及在并发标记期间收集的GC效率等数据，外加一些可配置的JVM选项。混合收集的过 程，很大程度上和前面的`fully-young gc`是一样的。

## 如何选择GC呢？

| 垃圾收集器             | 分类 | 作用位置       | 算法                    | 特点         | 使用场景                               |
| ---------------------- | ---- | -------------- | ----------------------- | ------------ | -------------------------------------- |
| Serial                 | 串行 | 新生代         | 标记-复制               | 响应速度优先 | 单CPU环境下的client模式                |
| Serial Old             | 串行 | 老年代         | 标记-整理               | 响应速度优先 | 单CPU环境下的client模式（CMS后备方案） |
| ParNew                 | 并行 | 新生代         | 标记-复制               | 响应速度优先 | 多CPU环境Server模式下与CMS配合使用     |
| Parallel <br/>Scavenge | 并行 | 新生代         | 标记-复制               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| Parallel Old           | 并行 | 老年代         | 标记-整理               | 吞吐量优先   | 后台运算而不需要太多交互的场景         |
| CMS                    | 并发 | 老年代         | 标记-清除               | 响应速度优先 | 互联网站或B/S业务                      |
| G1                     | 并发 | 新生代、老年代 | 标记-复制<br/>标记-压缩 | 响应速度优先 | 面向服务端应用，将来替换CMS            |

JDK11与JDK12起，分别开始支持ZGC与Shennandoah GC：

* ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几毫秒级别的延 迟，线性可扩展；
* Shenandoah: G1的改进版本，跟ZGC类似。

可以看出GC算法和实现的演进路线：

* `串行 -> 并行`: 重复利用多核CPU的优势，大幅降低GC暂停时间，提升吞吐量。
* `并行 -> 并发`: 不只开多个GC线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线 程一起并发执行，减少了单次GC暂停持续的时间，这能有效降低业务系统的延迟。
* `CMS -> G1`: G1可以说是在CMS基础上进行迭代和优化开发出来的。修正了CMS一些存在的问题，而 且在GC思想上有了重大进步，也就是划分为多个小堆块进行增量回收，这样就更进一步地降低了单次 GC暂停的时间。 可以发现，随着硬件性能的提升，业界对延迟的需求也越来越迫切。
* `G1 -> ZGC`: ZGC号称无停顿垃圾收集器，这又是一次极大的改进。ZGC和G1有一些相似的地方，但是 底层的算法和思想又有了全新的突破。 ZGC把一部分GC工作，通过读屏障触发陷阱处理程序的方式， 让业务线程也可以帮忙进行GC。这样业务线程会有一点点工作量，但是不用等，延迟也被极大地降下 来了。

选择正确的 GC，唯一可行的方式就是去尝试，一般性的指导原则： 

* 如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；
* 如果系统考虑低延迟，每次 GC 时间尽量短，用 CMS GC；
* 如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。 

对于内存大小的考量： 

* 一般 4G 以上，算是比较大，用 G1 的性价比较高。 
* 一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。

最后需要明确一个观点：

- 没有最好的收集器，更没有万能的收集器。
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。

# 执行引擎

## Java为什么是半执行半编译语言？

JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。我们编写的.java源文件先是通过javac编译器编译成bytecode字节码文件，然后通过JVM内嵌的解释器将字节码文件转换成机器码。但是，我们常用的JVM例如Hotspot JVM中，提供了 JIT（Just-In-Time）编译器，也就是所谓的动态编译器。JIT编译器能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就是属于编译执行了。

- 解释器（Interpreter）：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
- JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

**为什么还需要再使用解释器来“拖累”程序的执行性能呢？**比如JRockit VM内部就不包含解释器，字节码全部都依靠JIT编译器编译后执行。

我们需要明确的是，当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的编译时间；但编译为本地代码后，执行效率高。

所以，尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。

**HotSpot JVM执行方式**

当虚拟机启动的时候，**解释器可以首先发挥作用**，而不必等待JIT编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据**热点探测**功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。

## Java中编译器分类有哪些？

**前端编译器**

Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。常见前端编译器：Sun的**javac**、Eclipse JDT中的增量式编译器（ECJ）。

**后端运行期编译器**

**JIT编译器**（Just In Time Compiler），把字节码转变成机器码的过程。常见JIT编译器：HotSpot VM的C1、C2编译器。**
**

- `-client`：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
- `-server`：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）

**静态提前编译器**

**AOT编译器**（Ahead of Time Compiler）。所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。常见AOT 编译器有：GNU Compiler for the Java（GCJ）、Excelsior JET。

```java
 .java -> .class -> (使用jaotc) -> .so
```

JDK9引入了AOT编译器和实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。AOT编译器的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行；不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验。

缺点：

- 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包。
- 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。
- 还需要继续优化中，最初只支持Linux X64 java base。

# 命令行参数与命令行工具

## JVM常用命令行参数 jmap、jps？

**jps：查看所有 Java 进程**

- jps：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier, LVMID）。
- jps -q ：只输出进程的本地虚拟机唯一 ID。
- jps -l：输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。
- jps -v：输出虚拟机进程启动时 JVM 参数。
- jps -m：输出传递给 Java 进程 main() 函数的参数。jps -mlv： 打印Java 各个进程的详尽参数。

**jinfo：实时地查看和调整虚拟机各项参数**

- jinfo vmid ：输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。
- jinfo -flag name vmid ：输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails ：详细 GC 日志模式，这两个都是默认关闭的)。

**jstat：监视虚拟机各种运行状态信息**

jstat 命令使用格式：`jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]`

比如 jstat -gc -h3 2848 1000 10表示分析进程 id 为 2848 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。

常见的 option 如下：

- jstat -class vmid ：类加载(Class loader)信息统计；
- jstat -compiler vmid ：JIT 即时编译器相关的统计信息；
- jstat -gc vmid ：GC 相关的堆内存信息；
- jstat -gccapacity vmid ： 各个内存池分代空间的容量；
- jstat -gccause vmid：看上次 GC，本次 GC（如果正在 GC 中）的原因， 其他 输出和 -gcutil 选项一致
- jstat -gcnew vmid ：年轻代的统计信息（New = Young = Eden + S0 + S1）；
- jstat -gcnewcapcacity vmid ：年轻代空间大小统计；
- jstat -gcold vmid ：老年代和元数据区的行为统计；
- jstat -gcoldcapacity vmid ：显示老年代的大小；
- jstat -gcpermcapacity vmid ：显示永久代大小；
- jstat -gcmetacapacity vmid： meta 区大小统计;
- jstat -gcutil vmid ：GC 相关区域的使用率（utilization）统计；

另外，加上 -t参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。

**jmap：生成堆转储快照**

- -heap pid ：打印堆内存（/内存池）的配置和 使用信息。
- -histo pid ：看哪些类占用的空间最多, 直方图。
- -dump:format=b,file=xxxx.hprof pid：生成堆转储快照。

**jstack ：生成虚拟机当前时刻的线程快照**

- -F 强制执行 thread dump，可在 Java 进程卡死 （hung 住）时使用，此选项可能需要系统权限。
- -m 混合模式（mixed mode)，将 Java 帧和 native 帧一起输出，此选项可能需要系统权限。
- -l 长列表模式，将线程相关的 locks 信息一起输 出，比如持有的锁，等待的锁。

**jhat：分析 heapdump 文件**

**jcmd：执行 JVM 相关分析命令（整合命令）**

- jcmd pid VM.version 
- jcmd pid VM.flags 
- jcmd pid VM.command_line 
- jcmd pid VM.system_properties
- jcmd pid Thread.print
-  jcmd pid GC.class_histogram
-  jcmd pid GC.heap_info

## 常用可视化工具有哪些？

**（1）jsonsole**：Java 监视与管理控制台

JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出console命令启动或者在 JDK 目录下的 bin 目录找到jconsole.exe然后双击启动。

**（2）jvisualvm**

VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。

**（3）VisualGC**

**（4）jmc**

jmc是目前Oracle提供最强大的JVM可视化工具，它支持远程连接JVM（通过JMX连接如果想要用jmc监控远程的JVM进程，配置方式和jvisualvm方式一一样即可），除此之外它还支持Java**飞行记录器**。

## 生成内存转储文件有哪几种方式? 用什么工具进行分析?

* jmap/jcmd
* JVisualVM/JMC/jconsole 
* 自动执行堆内存转储: -XX:+HeapDumpOnOutOfMemoryError -XX:`HeapDumpPath=<file-or-path>` 
*  JMX 客户端工具
* 编程方式调用: HotSpotDiagnosticMXBean

## 如何监控和诊断JVM堆内和堆外内存使用？

了解 JVM 内存的方法有很多，具体能力范围也有区别，简单总结如下：

- 可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。

以 JConsole 为例，其内存页面可以显示常见的**堆内存**和**各种堆外部分**使用状态。

- 也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。
- 或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。
- 如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。
- 另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。

这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。

# 性能调优

## 堆内存参数

**（1）显式指定堆内存–Xms和-Xmx**

`-Xmx`，指定最大堆内存。`-Xms`，指定堆内存空间的初始大小。 

通常会将`-Xms`和`-Xmx`两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

**（2）显式新生代内存**

通过`-Xmn`等价于`-XX:NewSize`来指定新生代内存大小，使用 G1 垃圾收集器不应该设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 `-Xmx` 的 `1/2 ~ 1/4`。

举个栗子，如果我们要为 新生代分配 最小256m 的内存，最大 1024m的内存我们的参数应该这样来写：

```java
-XX:NewSize=256m

-XX:MaxNewSize=1024m
```

如果我们要为 新生代分配256m的内存（NewSize与MaxNewSize设为一致），我们的参数应该这样来写：

```java
 -Xmn256m
```

另外，还可以通过`-XX:NewRatio=<int>`来设置新生代和老年代内存的比值。

（3）**显示指定永久代/元空间的大小**

从Java 8开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。

JDK1.7 及之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小，JDK 1.8设置此类参数会无效。

```java
-XX:PermSize=size //方法区 (永久代) 初始大小  

-XX:MaxPermSize=size //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了，取而代之是元空间，元空间使用的是直接内存。

```java
-XX:MetaspaceSize=size //设置 Metaspace 的初始（和最小大小） 
-XX:MaxMetaspaceSize=size //设置 Metaspace 的最大大小，Java8默认不限制Meta空间，一般不允许设置该选项。
```

（4）**其他常用参数**

-XX：MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟 -Dsun.nio.MaxDirectMemorySize 效果相同。

-Xss, 设置每个线程栈的字节数，影响栈的深度。 例如 -Xss1m 指定线程栈为 1MB，与-XX:ThreadStackSize=1m 等价。

下面我画了一张图，这样有助力理清`Xmx、Xms、Xmn、Meta、 DirectMemory、Xss `这些内存参数的关系：

 <div align="center"> <img src="..\..\05-Java\images\jvm\JVM启动参数.png" width="850px"></div>

## GC设置参数

**垃圾回收器**

```java
-XX:+UseSerialGC——使用串行垃圾回收器（Serial/Serial Old 组合）

-XX:+UseParallelGC——使用并行垃圾回收器（ParNew/Serial Old 组合）
    
-XX:+UseParallelGC -XX:+UseParallelOldGC——使用并行垃圾回收器（Parallel Scavenge/Parallel Old组合）

-XX:+UseConcMarkSweepGC——使用 CMS 垃圾回收器（只能与ParNew/Serial搭配）

-XX:+UseG1GC——使用 G1 垃圾回收器

// Java 11
+-XX:+UnlockExperimentalVMOptions -XX:+UseZGC——使用ZGC垃圾回收器

// Java 12
+-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC——使用Shenandoah垃圾回收器
```

**GC日志记录**

```java
-XX:+PrintGCDetails 打印GC日志详情
-Xloggc:gc.demo.log 指定日志文件
-Xloggc:/log/gc.demo.log 指定GC日志文件存放的绝对路径
-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=5 
-XX:GCLogFileSize=20M log文件大小
-XX:+PrintGCDateStamps 打印GC事件发生的日期时间
-XX:+PrintGCApplicationStoppedTime 输出每次GC的持续时间和程序暂停时间-XX:+PrintReferenceGC 输出GC清理了多少引用类型
```

例如使用 G1 垃圾收集器, 一般配置哪些启动参数：

```java
-Xmx4g -Xms4g -XX:+UseG1GC
-XX:MaxGCPauseMillis=50
-XX:ParallelGCThreads=4
```

## JVM 疑难情况问题分析步骤？

> 推荐Arthas 诊断分析工具。

发现问题，我们可以这样来分析：

1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等， 基础服务、外部 API 依赖 出现故障。 

2、查看系统资源和监控信息： 硬件信息、操作系统平台、系统架构； 

* 排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发竞争等 情况； 
* 排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调整、超 时、连接数。

3、查看性能指标，包括实时监控、历史数据。可以发现假死，卡顿、响应变慢等现象； 

* 排查数据库， 并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询数据 量、redo 日志、undo、 binlog 日志、代理、工具 BUG。可以考虑的优化包括： 集群、主备、只读实例、分 片、分区； 可能还需要关注系统中使用的各类中间件。

4、排查系统日志， 比如重启、崩溃、Kill 。 

5、APM，比如发现有些链路请求变慢等等。 

6、排查应用系统

* 排查配置文件: 启动参数配置、Spring 配置、JVM 监控参数、数据库参数、Log 参数、内存问题，比如是否存 在内存泄漏，内存溢出、批处理导致的内存放大等等；
* GC 问题， 确定 GC 算法，GC 总耗时、GC 最大暂停时间、分析 GC 日志和监控指标： 内存分配速度，分代提 升速度，内存使用率等数据，适当时修改内存配置； 
* 排查线程, 理解线程状态、并发线程数，线程 Dump，锁资源、锁等待，死锁； 排查代码， 比如安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三方 库、XSS、CORS、正则； 
* 单元测试：覆盖率、边界值、Mock测试、集成测试。

7、排除资源竞争、坏邻居效应。

8、疑难问题排查分析手段

* DUMP 线程/内存；
* 抽样分析/调整代码、异步化、削峰填谷。

## JVM优化Java代码时都做了什么？

JVM 在对代码执行的优化可分为运行时（runtime）优化和即时编译器（JIT）优化。运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。

JVM 的即时编译器优化是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化（speculative/optimistic optimization）。这个怎么理解呢？比如我有一条 `instanceof` 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回 `instanceof` 的结果。如果出现了其他类，那么就抛弃这段编译后的机器码，并且切换回解释执行。

当然，JVM 的优化方式仅仅作用在运行应用代码的时候。如果应用代码本身阻塞了，比如说并发时等待另一线程的结果，这就不在 JVM 的优化范畴啦。

## 谈谈你的GC调优思路？

谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。

基本的调优思路可以总结为：

- 理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。
- 掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。
- 这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。
- 通过分析确定具体调整的参数或者软硬件配置。
- 验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。

## 线上OOM如何排查呢？

平时遇到的内存溢出问题一般分为两种，一种是由于大峰值下没有限流，瞬间创建大量对象而导致的内存溢出；另一种则是由于内存泄漏而导致的内存溢出。

使用限流，我们一般就可以解决第一种内存溢出问题，但其实很多时候，内存溢出往往是内存泄漏导致的，这种问题就是程序的 BUG，我们需要及时找到问题代码。

内存溢出错误大致有如下几种错误：

```java
OutOfMemoryError: Java heap space						
OutOfMemoryError: GC overhead limit exceeded
OutOfMemoryError: PermGen space
OutOfMemoryError: Metaspace
OutOfMemoryError: Unable to create new native thread
OutOfMemoryError: Out of swap space
OutOfMemoryError: Requested array size exceeds VM limit
OutOfMemoryError: Kill process or sacrifice child
OutOfMemoryError: reason stack_trace_with_native_method
OutOfMemoryError: Direct Buffer Memory
OutOfMemoryError: Map failed
```

[内存持续上升，我该如何排查问题？](https://time.geekbang.org/column/article/108582)一文模拟了一个内存泄漏导致的内存溢出案例，可学习一下。

到目前为止，暂时没有发现详细介绍排查OOM的文章，没有一个统一方法论... ...待编写。