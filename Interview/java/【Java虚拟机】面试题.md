## 01 JDK、JRE、JVM有什么关系？

JDK是用于开发Java应用程序的软件工具集合，主要包括了Java运行时环境（JRE）和一些Java开发工具（例如解释器`java.exe`、编译器`javac.exe`、打包工具`jar.exe`、文档生成器`javadoc.exe`等）

JRE提供Java应用程序执行时所需的环境，由Java虚拟机（JVM）、核心类（lib）及支持文件组成。

JVM即是所谓的Java虚拟机，它的主要工作是解释Java 程序生成的字节码文件（`.class`）并将其映射到本地的CPU的指令集或OS的系统调用中。Java语言之所以能跨平台运行，是因为不同的操作系统使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。

**三者之间关系**：`JDK > JRE > JVM`。

```html
JDK = JRE + tools
JRE = JVM + libraries
```



## 02 什么是字节码，采用字节码的好处是什么？

我们平时说的Java字节码（Java bytecode），指的是用Java语言编译成的字节码。不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。

Java虚拟机与Java语言并没有必然的联系，它只与特定的**二进制文件格式**——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心**“字节码”文件**。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，**只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行**。

Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。**这也就是解释了 Java 的编译与解释并存的特点**。



## 03 请介绍类加载过程？

一个类在JVM里的生命周期有7个阶段，分别是加载（Loading）、校验（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）、卸载（Unloading）。 其中前五个部分（**加载，验证，准备，解析，初始化**）统称为类加载。完整的流程图如下所示：

<div align="center"> <img src="..\..\images\jvm\类的生命周期.png" width="600px"></div>

**加载阶段**：是整个“类加载”（Class Loading）过程中的第一个阶段，JVM需要完成三件事：

* 通过一个类的**全限定名获取定义此类的二进制字节流**，简单点说就是 **找到文件系统中/jar包中/或存在于任何地方的“ class文件 ”**。 如果找不到则会抛出 `NoClassDefFound `错误。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* **在内存中生成一个代表这个类的`java.lang.Class`对象**，作为方法区这个类的各种数据的访问入口。

**验证阶段**：确保Class文件的**字节流**中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。

* 文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以**魔数0xCAFEBABE**开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
* 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类（除了`java.lang.Object`之外，所有的类都应当有父类）；这个类的父类是否继承了不允许被继承的类（被final修饰的类）... ...
* 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
* 符号引用验证：对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

**准备阶段**：为类的静态变量分配内存，并将其初始化为默认值。

这个阶段将会创建静态字段, 并将其初始化为标准默认值（**比如 null 或者 0值**，Boolean类型数据的零值为False ），并分配方法表，即在方法区中分配这些变量所使用的内存空间。

* **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化**；

* 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

**解析阶段**：解析符号引用阶段主要将**常量池**内的**符号引用转换为直接引用的过程**。

* 解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型**等。对应常量池中的`CONSTANT Class info、CONSTANT Fieldref info、CONSTANT_Methodref_info`等。

**初始化阶段**：JVM规范明确规定, 必须在类的首次“主动使用”时才能执行类初始化。 初始化的过程包括执行： **类构造器方法，static静态变量赋值语句 和static静态代码块**。



## 04 什么是类加载器？Java类加载机制是什么？

类加载过程可以描述为“通过一个类的全限定类名来获取此类的class对象”，即所谓的全限定名来获取描述该类的二进制字节流），这个过程由**类加载器**（Class Loader）来完成。

在程序中我们最常见的类加载器主要有3类：**启动类加载器**（BootstrapClassLoader）、**扩展类加载器**（ExtClassLoader） 和**应用类加载器**（AppClassLoader）。

Java中类加载机制为**双亲委派机制**，它指的是，当某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，**依次递归**，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

**双亲委派机制的优势**：（1）避免类的重复加载（2）保护程序安全，防止核心API被随意篡改。

<div align="center"> <img src="..\..\images\jvm\双亲委托.png" width="600px"></div>



## 05 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?

JVM在执行Java程序的过程中会把它所管理的内存主要划分5个不同的数据区域：**本地方法栈、程序计数器、虚拟机栈、堆、方法区**。这些区域有各自的用途和创建与销毁的时间。有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

* **程序计数器**是对物理PC寄存器的一种模拟，主要用于存储当前线程需要执行的字节码指令地址。在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程生命周期保持一致。

* **本地方法栈**用于管理本地方法的调用。其中，本地方法（NatIve Method）就是调用非Java代码的接口，例如`java.lang.Thread`中的`private native void start0()`方法。
* **虚拟机栈**也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
* **堆区**是虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。
* **方法区**与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

 <div align="center"> <img src="..\..\images\jvm\运行时数据区.png" width="800px"></div>

==注意==《Java 虚拟机规范》中指明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择区进行垃圾收集或者进行压缩。” 但对于`HotSpot VM`而言，方法区还有一个别名叫做**Non-Heap(非堆）**，目的就是要和堆分开。所以**方法区看作是一块独立于 Java 堆的内存空间**。

如上图所描述一样，在JDK 1.7 之前，方法区在**逻辑上**属于**非堆**，是一块独立的内存区域，但其实际物理内存其实是在堆区的（存放于永久代）；直到JDK 1.8后，方法区的实现才被移动至直接内存中的元空间（Meta Space）中，逻辑内存与实际物理内存都与堆区分开。

一般来讲，黄色部分为线程隔离的数据区域，其他部分为线程共享的区域。

|    区域    | 是否线程共享 | 是否存在内存溢出 | 是否存在GC |
| :--------: | :----------: | :--------------: | :--------: |
| 本地方法栈 |      否      |        是        |     否     |
| 程序计数器 |      否      |      **否**      |     否     |
|  虚拟机栈  |      否      |        是        |     否     |
|    堆区    |      是      |        是        |     是     |
|   方法区   |      是      |        是        |     是     |

> 内存泄漏（Memory Leak）是指本来无用的对象却继续占用内存，没有在恰当的时机释放占用的内存的情况。
>
> 内存溢出（Out Of Memory，简称OOM）是指可使用的内存不足的情况。
>
> 一般来讲，内存泄漏是资源管理问题或程序BUG，而内存溢出则是内存空间不足和内存泄漏的最终结果。



## 06 如何监控和诊断JVM堆内和堆外内存使用？

了解 JVM 内存的方法有很多，具体能力范围也有区别，简单总结如下：

- 可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。

以 JConsole 为例，其内存页面可以显示常见的**堆内存**和**各种堆外部分**使用状态。

- 也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。
- 或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。
- 如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。
- 另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。

这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。



## 07 Java常见的垃圾收集器有哪些？

实际上，垃圾收集器（GC，Garbage Collector）是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle），不同版本的 JVM，提供的选择也不同。接下来，我来谈谈最主流的 Oracle JDK。

- Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。
  从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。
  Serial GC 的对应 JVM 参数是：

```powershell
-XX:+UseSerialGC
```

- ParNew GC，很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数

```powershell
-XX:+UseConcMarkSweepGC -XX:+UseParNewGC
```

- CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。
- Parrallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。
  开启选项是：

```powershell
-XX:+UseParallelGC
```

另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：

```powershell
-XX:MaxGCPauseMillis=value
-XX:GCTimeRatio=N // GC 时间和用户时间比例 = 1 / (N+1)
```

- G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。
  G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。
  G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。



## 08 谈谈你的GC调优思路？

谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。

基本的调优思路可以总结为：

- 理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。
- 掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。
- 这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。
- 通过分析确定具体调整的参数或者软硬件配置。
- 验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。



## 09 Java内存模型中的happen-before是什么？

Happen-before 关系，是 Java 内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。

它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面，例如：

- 线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。
- 对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。
- 对于一个锁的解锁操作，保证 happen-before 加锁操作。
- 对象构建完成，保证 happen-before 于 finalizer 的开始动作。
- 甚至是类似线程内部操作的完成，保证 happen-before 其他 `Thread.join() `的线程等。

这些 happen-before 关系是存在着传递性的，如果满足 a happen-before b 和 b happen-before c，那么 a happen-before c 也成立。

前面我一直用 happen-before，而不是简单说前后，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。



## 10 JVM优化Java代码时都做了什么？

JVM 在对代码执行的优化可分为运行时（runtime）优化和即时编译器（JIT）优化。运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。

JVM 的即时编译器优化是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化（speculative/optimistic optimization）。这个怎么理解呢？比如我有一条 `instanceof` 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回 `instanceof` 的结果。如果出现了其他类，那么就抛弃这段编译后的机器码，并且切换回解释执行。

当然，JVM 的优化方式仅仅作用在运行应用代码的时候。如果应用代码本身阻塞了，比如说并发时等待另一线程的结果，这就不在 JVM 的优化范畴啦。



- [ ] 什么是字节码？采用字节码的最大好处是什么？
- [ ] 字节码织入方式？手动织入？
- [ ] jvm内存模型

- [ ] jvm垃圾回收算法
- [ ] jvm标记算法，可达性分析法中哪些对象可以作为ROOT节点
- [ ] jvm参数有哪些
- [ ] 垃圾回收器如何搭配
- [ ] CMS垃圾回收器垃圾回收有哪些步骤？CMS GC有什么问题？(并发清除算法，浮动垃圾，短暂停顿)
- [ ] G1为什么适合作为高并发系统垃圾回收
- [ ] 回收过程是怎么样的？(young gc、并发阶段、混合阶段、full gc，说了Remember Set)你提到的Remember Set底层是怎么实现的？
- [ ] 线上oom如何排查（加分点）
- [ ] jvm性能调优有哪些参数
- [ ] jvm常用命令 jmap、jps等等
- [ ] 项目中一般jvm报警，垃圾回收情况 有没有经历过？
- [ ] 简单介绍垃圾回收的整个流程？项目中使用哪种垃圾回收器？
- [ ] 程序计数器为什么是私有的?
- [ ] 虚拟机栈和本地方法栈为什么是私有的?
- [ ] 什么是上下文切换?
- [ ] 说说并发与并行的区别?
- [ ] 什么是线程死锁?如何避免死锁?如何检测死锁？
- [ ] JVM怎么判断对象是无用对象？（根搜索算法，从GC Root出发，对象没有引用，就判定为无用对象）
- [ ] 根搜索算法中的根节点可以是哪些对象？（类对象，虚拟机栈的对象，常量引用的对象）